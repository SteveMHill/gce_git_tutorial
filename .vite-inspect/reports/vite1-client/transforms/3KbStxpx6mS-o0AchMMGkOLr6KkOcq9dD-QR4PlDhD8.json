{
  "resolvedId": "/Users/stevenhill/gce_git_tutorial/node_modules/@slidev/client/composables/useDragElements.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import type { SlidePatch } from '@slidev/types'\nimport type { CSSProperties, DirectiveBinding, InjectionKey, WatchStopHandle } from 'vue'\nimport { debounce, ensureSuffix } from '@antfu/utils'\nimport { injectLocal, onClickOutside, useWindowFocus } from '@vueuse/core'\nimport { computed, ref, watch } from 'vue'\nimport { injectionCurrentPage, injectionFrontmatter, injectionRenderContext, injectionSlideElement, injectionSlideScale, injectionSlideZoom } from '../constants'\nimport { makeId } from '../logic/utils'\nimport { activeDragElement } from '../state'\nimport { directiveInject } from '../utils'\nimport { useNav } from './useNav'\nimport { useSlideBounds } from './useSlideBounds'\nimport { useDynamicSlideInfo } from './useSlideInfo'\n\nexport type DragElementDataSource = 'frontmatter' | 'prop' | 'directive'\n/**\n * Markdown source position, injected by markdown-it plugin\n */\nexport type DragElementMarkdownSource = [startLine: number, endLine: number, index: number]\n\nexport type DragElementsUpdater = (id: string, posStr: string, type: DragElementDataSource, markdownSource?: DragElementMarkdownSource) => void\n\nconst map: Record<number, DragElementsUpdater> = {}\n\nexport function useDragElementsUpdater(no: number) {\n  if (!(__DEV__ && __SLIDEV_FEATURE_EDITOR__))\n    return () => {}\n\n  if (map[no])\n    return map[no]\n\n  const { info, update } = useDynamicSlideInfo(no)\n\n  let newPatch: SlidePatch | null = null\n  async function save() {\n    if (newPatch) {\n      await update({\n        ...newPatch,\n        skipHmr: true,\n      })\n      newPatch = null\n    }\n  }\n  const debouncedSave = debounce(500, save)\n\n  return map[no] = (id, posStr, type, markdownSource) => {\n    if (!info.value)\n      return\n\n    if (type === 'frontmatter') {\n      const frontmatter = info.value.frontmatter\n      frontmatter.dragPos ||= {}\n      if (frontmatter.dragPos[id] === posStr)\n        return\n      frontmatter.dragPos[id] = posStr\n      newPatch = {\n        frontmatter: {\n          dragPos: frontmatter.dragPos,\n        },\n      }\n    }\n    else {\n      if (!markdownSource)\n        throw new Error(`[Slidev] VDrag Element ${id} is missing markdown source`)\n\n      const [startLine, endLine, idx] = markdownSource\n      const lines = info.value.content.split(/\\r?\\n/g)\n\n      let section = lines.slice(startLine, endLine).join('\\n')\n      let replaced = false\n\n      section = type === 'prop'\n      // eslint-disable-next-line regexp/no-super-linear-backtracking\n        ? section.replace(/<(v-?drag-?\\w*)(.*?)(\\/)?>/gi, (full, tag, attrs, selfClose = '', index) => {\n            if (index === idx) {\n              replaced = true\n              const posMatch = attrs.match(/pos=\".*?\"/)\n              if (!posMatch)\n                return `<${tag}${ensureSuffix(' ', attrs)}pos=\"${posStr}\"${selfClose}>`\n              const start = posMatch.index\n              const end = start + posMatch[0].length\n              return `<${tag}${attrs.slice(0, start)}pos=\"${posStr}\"${attrs.slice(end)}${selfClose}>`\n            }\n            return full\n          })\n        : section.replace(/(?<![</\\w])v-drag(?:=\".*?\")?/gi, (full, index) => {\n            if (index === idx) {\n              replaced = true\n              return `v-drag=\"${posStr}\"`\n            }\n            return full\n          })\n\n      if (!replaced)\n        throw new Error(`[Slidev] VDrag Element ${id} is not found in the markdown source`)\n\n      lines.splice(\n        startLine,\n        endLine - startLine,\n        section,\n      )\n\n      const newContent = lines.join('\\n')\n      if (info.value.content === newContent)\n        return\n      newPatch = {\n        content: newContent,\n      }\n      info.value = {\n        ...info.value,\n        content: newContent,\n      }\n    }\n    debouncedSave()\n  }\n}\n\nexport function useDragElement(directive: DirectiveBinding | null, posRaw?: string | number | number[], markdownSource?: DragElementMarkdownSource, isArrow = false) {\n  function inject<T>(key: InjectionKey<T> | string): T | undefined {\n    return directive\n      ? directiveInject(directive, key)\n      : injectLocal(key)\n  }\n\n  const renderContext = inject(injectionRenderContext)!\n  const frontmatter = inject(injectionFrontmatter) ?? {}\n  const page = inject(injectionCurrentPage)!\n  const updater = computed(() => useDragElementsUpdater(page.value))\n  const scale = inject(injectionSlideScale) ?? ref(1)\n  const zoom = inject(injectionSlideZoom) ?? ref(1)\n  const { left: slideLeft, top: slideTop, stop: stopWatchBounds } = useSlideBounds(inject(injectionSlideElement) ?? ref())\n  const { isPrintMode } = useNav()\n  const enabled = ['slide', 'presenter'].includes(renderContext.value) && !isPrintMode.value\n\n  let dataSource: DragElementDataSource = directive ? 'directive' : 'prop'\n  let dragId: string = makeId()\n  let pos: number[] | undefined\n  if (Array.isArray(posRaw)) {\n    pos = posRaw\n  }\n  else if (typeof posRaw === 'string' && posRaw.includes(',')) {\n    pos = posRaw.split(',').map(Number)\n  }\n  else if (posRaw != null) {\n    dataSource = 'frontmatter'\n    dragId = `${posRaw}`\n    posRaw = frontmatter?.dragPos?.[dragId]\n    pos = (posRaw as string)?.split(',').map(Number)\n  }\n\n  if (dataSource !== 'frontmatter' && !markdownSource)\n    throw new Error('[Slidev] Can not identify the source position of the v-drag element, please provide an explicit `id` prop.')\n\n  const watchStopHandles: WatchStopHandle[] = [stopWatchBounds]\n\n  const autoHeight = !isArrow && posRaw != null && !Number.isFinite(pos?.[3])\n  pos ??= [Number.NaN, Number.NaN, 0]\n  const width = ref(pos[2])\n  const x0 = ref(pos[0] + pos[2] / 2)\n\n  const rotate = ref(isArrow ? 0 : (pos[4] ?? 0))\n  const rotateRad = computed(() => rotate.value * Math.PI / 180)\n  const rotateSin = computed(() => Math.sin(rotateRad.value))\n  const rotateCos = computed(() => Math.cos(rotateRad.value))\n\n  const container = ref<HTMLElement>()\n  const bounds = ref({ left: 0, top: 0, width: 0, height: 0 })\n  const actualHeight = ref(0)\n  function updateBounds() {\n    if (!container.value)\n      return\n    const rect = container.value.getBoundingClientRect()\n    bounds.value = {\n      left: rect.left / zoom.value,\n      top: rect.top / zoom.value,\n      width: rect.width / zoom.value,\n      height: rect.height / zoom.value,\n    }\n    actualHeight.value = ((bounds.value.width + bounds.value.height) / scale.value / (Math.abs(rotateSin.value) + Math.abs(rotateCos.value)) - width.value)\n  }\n  watchStopHandles.push(watch(width, updateBounds, { flush: 'post' }))\n\n  const configuredHeight = ref(pos[3] ?? 0)\n  const height = autoHeight\n    ? computed({\n        get: () => (autoHeight ? actualHeight.value : configuredHeight.value) || 0,\n        set: v => !autoHeight && (configuredHeight.value = v),\n      })\n    : configuredHeight\n  const configuredY0 = autoHeight ? ref(pos[1]) : ref(pos[1] + pos[3] / 2)\n  const y0 = autoHeight\n    ? computed({\n        get: () => configuredY0.value + height.value / 2,\n        set: v => configuredY0.value = v - height.value / 2,\n      })\n    : configuredY0\n\n  const containerStyle = computed(() => {\n    return Number.isFinite(x0.value)\n      ? {\n        position: 'absolute',\n        zIndex: 100,\n        left: `${x0.value - width.value / 2}px`,\n        top: `${y0.value - height.value / 2}px`,\n        width: `${width.value}px`,\n        height: autoHeight ? undefined : `${height.value}px`,\n        transformOrigin: 'center center',\n        transform: `rotate(${rotate.value}deg)`,\n      } satisfies CSSProperties\n      : {\n        position: 'absolute',\n        zIndex: 100,\n      } satisfies CSSProperties\n  })\n\n  watchStopHandles.push(\n    watch(\n      [x0, y0, width, height, rotate],\n      ([x0, y0, w, h, r]) => {\n        let posStr = [x0 - w / 2, y0 - h / 2, w].map(Math.round).join()\n        if (autoHeight)\n          posStr += dataSource === 'directive' ? ',NaN' : ',_'\n        else\n          posStr += `,${Math.round(h)}`\n        if (Math.round(r) !== 0)\n          posStr += `,${Math.round(r)}`\n\n        if (dataSource === 'directive')\n          posStr = `[${posStr}]`\n\n        updater.value(dragId, posStr, dataSource, markdownSource)\n      },\n    ),\n  )\n\n  const state = {\n    dragId,\n    dataSource,\n    markdownSource,\n    isArrow,\n    zoom,\n    autoHeight,\n    x0,\n    y0,\n    width,\n    height,\n    rotate,\n    container,\n    containerStyle,\n    watchStopHandles,\n    dragging: computed((): boolean => activeDragElement.value === state),\n    mounted() {\n      if (!enabled)\n        return\n      updateBounds()\n      if (!posRaw) {\n        setTimeout(() => {\n          updateBounds()\n          x0.value = (bounds.value.left + bounds.value.width / 2 - slideLeft.value) / scale.value\n          y0.value = (bounds.value.top - slideTop.value) / scale.value\n          width.value = bounds.value.width / scale.value\n          height.value = bounds.value.height / scale.value\n        }, 100)\n      }\n    },\n    unmounted() {\n      if (!enabled)\n        return\n      state.stopDragging()\n    },\n    startDragging(): void {\n      if (!enabled)\n        return\n      updateBounds()\n      activeDragElement.value = state\n    },\n    stopDragging(): void {\n      if (!enabled)\n        return\n      if (activeDragElement.value === state)\n        activeDragElement.value = null\n    },\n  }\n\n  watchStopHandles.push(\n    onClickOutside(container, (ev) => {\n      const container = document.querySelector('#drag-control-container')\n      if (container && ev.target && container.contains(ev.target as HTMLElement))\n        return\n      state.stopDragging()\n    }),\n    watch(useWindowFocus(), (focused) => {\n      if (!focused)\n        state.stopDragging()\n    }),\n  )\n\n  return state\n}\n\nexport type DragElementState = ReturnType<typeof useDragElement>\n",
      "start": 1743409708466,
      "end": 1743409708469,
      "sourcemaps": null
    },
    {
      "name": "unplugin-vue-markdown",
      "start": 1743409708469,
      "end": 1743409708469,
      "order": "pre"
    },
    {
      "name": "slidev:flags",
      "start": 1743409708469,
      "end": 1743409708469,
      "order": "pre"
    },
    {
      "name": "unocss:transformers:pre",
      "start": 1743409708469,
      "end": 1743409708469,
      "order": "pre"
    },
    {
      "name": "unocss:global:build:scan",
      "start": 1743409708469,
      "end": 1743409708469,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1743409708469,
      "end": 1743409708469,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import { debounce, ensureSuffix } from \"@antfu/utils\";\nimport { injectLocal, onClickOutside, useWindowFocus } from \"@vueuse/core\";\nimport { computed, ref, watch } from \"vue\";\nimport { injectionCurrentPage, injectionFrontmatter, injectionRenderContext, injectionSlideElement, injectionSlideScale, injectionSlideZoom } from \"../constants\";\nimport { makeId } from \"../logic/utils\";\nimport { activeDragElement } from \"../state\";\nimport { directiveInject } from \"../utils\";\nimport { useNav } from \"./useNav\";\nimport { useSlideBounds } from \"./useSlideBounds\";\nimport { useDynamicSlideInfo } from \"./useSlideInfo\";\nconst map = {};\nexport function useDragElementsUpdater(no) {\n  if (!(__DEV__ && __SLIDEV_FEATURE_EDITOR__))\n    return () => {\n    };\n  if (map[no])\n    return map[no];\n  const { info, update } = useDynamicSlideInfo(no);\n  let newPatch = null;\n  async function save() {\n    if (newPatch) {\n      await update({\n        ...newPatch,\n        skipHmr: true\n      });\n      newPatch = null;\n    }\n  }\n  const debouncedSave = debounce(500, save);\n  return map[no] = (id, posStr, type, markdownSource) => {\n    if (!info.value)\n      return;\n    if (type === \"frontmatter\") {\n      const frontmatter = info.value.frontmatter;\n      frontmatter.dragPos ||= {};\n      if (frontmatter.dragPos[id] === posStr)\n        return;\n      frontmatter.dragPos[id] = posStr;\n      newPatch = {\n        frontmatter: {\n          dragPos: frontmatter.dragPos\n        }\n      };\n    } else {\n      if (!markdownSource)\n        throw new Error(`[Slidev] VDrag Element ${id} is missing markdown source`);\n      const [startLine, endLine, idx] = markdownSource;\n      const lines = info.value.content.split(/\\r?\\n/g);\n      let section = lines.slice(startLine, endLine).join(\"\\n\");\n      let replaced = false;\n      section = type === \"prop\" ? section.replace(/<(v-?drag-?\\w*)(.*?)(\\/)?>/gi, (full, tag, attrs, selfClose = \"\", index) => {\n        if (index === idx) {\n          replaced = true;\n          const posMatch = attrs.match(/pos=\".*?\"/);\n          if (!posMatch)\n            return `<${tag}${ensureSuffix(\" \", attrs)}pos=\"${posStr}\"${selfClose}>`;\n          const start = posMatch.index;\n          const end = start + posMatch[0].length;\n          return `<${tag}${attrs.slice(0, start)}pos=\"${posStr}\"${attrs.slice(end)}${selfClose}>`;\n        }\n        return full;\n      }) : section.replace(/(?<![</\\w])v-drag(?:=\".*?\")?/gi, (full, index) => {\n        if (index === idx) {\n          replaced = true;\n          return `v-drag=\"${posStr}\"`;\n        }\n        return full;\n      });\n      if (!replaced)\n        throw new Error(`[Slidev] VDrag Element ${id} is not found in the markdown source`);\n      lines.splice(\n        startLine,\n        endLine - startLine,\n        section\n      );\n      const newContent = lines.join(\"\\n\");\n      if (info.value.content === newContent)\n        return;\n      newPatch = {\n        content: newContent\n      };\n      info.value = {\n        ...info.value,\n        content: newContent\n      };\n    }\n    debouncedSave();\n  };\n}\nexport function useDragElement(directive, posRaw, markdownSource, isArrow = false) {\n  function inject(key) {\n    return directive ? directiveInject(directive, key) : injectLocal(key);\n  }\n  const renderContext = inject(injectionRenderContext);\n  const frontmatter = inject(injectionFrontmatter) ?? {};\n  const page = inject(injectionCurrentPage);\n  const updater = computed(() => useDragElementsUpdater(page.value));\n  const scale = inject(injectionSlideScale) ?? ref(1);\n  const zoom = inject(injectionSlideZoom) ?? ref(1);\n  const { left: slideLeft, top: slideTop, stop: stopWatchBounds } = useSlideBounds(inject(injectionSlideElement) ?? ref());\n  const { isPrintMode } = useNav();\n  const enabled = [\"slide\", \"presenter\"].includes(renderContext.value) && !isPrintMode.value;\n  let dataSource = directive ? \"directive\" : \"prop\";\n  let dragId = makeId();\n  let pos;\n  if (Array.isArray(posRaw)) {\n    pos = posRaw;\n  } else if (typeof posRaw === \"string\" && posRaw.includes(\",\")) {\n    pos = posRaw.split(\",\").map(Number);\n  } else if (posRaw != null) {\n    dataSource = \"frontmatter\";\n    dragId = `${posRaw}`;\n    posRaw = frontmatter?.dragPos?.[dragId];\n    pos = posRaw?.split(\",\").map(Number);\n  }\n  if (dataSource !== \"frontmatter\" && !markdownSource)\n    throw new Error(\"[Slidev] Can not identify the source position of the v-drag element, please provide an explicit `id` prop.\");\n  const watchStopHandles = [stopWatchBounds];\n  const autoHeight = !isArrow && posRaw != null && !Number.isFinite(pos?.[3]);\n  pos ??= [Number.NaN, Number.NaN, 0];\n  const width = ref(pos[2]);\n  const x0 = ref(pos[0] + pos[2] / 2);\n  const rotate = ref(isArrow ? 0 : pos[4] ?? 0);\n  const rotateRad = computed(() => rotate.value * Math.PI / 180);\n  const rotateSin = computed(() => Math.sin(rotateRad.value));\n  const rotateCos = computed(() => Math.cos(rotateRad.value));\n  const container = ref();\n  const bounds = ref({ left: 0, top: 0, width: 0, height: 0 });\n  const actualHeight = ref(0);\n  function updateBounds() {\n    if (!container.value)\n      return;\n    const rect = container.value.getBoundingClientRect();\n    bounds.value = {\n      left: rect.left / zoom.value,\n      top: rect.top / zoom.value,\n      width: rect.width / zoom.value,\n      height: rect.height / zoom.value\n    };\n    actualHeight.value = (bounds.value.width + bounds.value.height) / scale.value / (Math.abs(rotateSin.value) + Math.abs(rotateCos.value)) - width.value;\n  }\n  watchStopHandles.push(watch(width, updateBounds, { flush: \"post\" }));\n  const configuredHeight = ref(pos[3] ?? 0);\n  const height = autoHeight ? computed({\n    get: () => (autoHeight ? actualHeight.value : configuredHeight.value) || 0,\n    set: (v) => !autoHeight && (configuredHeight.value = v)\n  }) : configuredHeight;\n  const configuredY0 = autoHeight ? ref(pos[1]) : ref(pos[1] + pos[3] / 2);\n  const y0 = autoHeight ? computed({\n    get: () => configuredY0.value + height.value / 2,\n    set: (v) => configuredY0.value = v - height.value / 2\n  }) : configuredY0;\n  const containerStyle = computed(() => {\n    return Number.isFinite(x0.value) ? {\n      position: \"absolute\",\n      zIndex: 100,\n      left: `${x0.value - width.value / 2}px`,\n      top: `${y0.value - height.value / 2}px`,\n      width: `${width.value}px`,\n      height: autoHeight ? void 0 : `${height.value}px`,\n      transformOrigin: \"center center\",\n      transform: `rotate(${rotate.value}deg)`\n    } : {\n      position: \"absolute\",\n      zIndex: 100\n    };\n  });\n  watchStopHandles.push(\n    watch(\n      [x0, y0, width, height, rotate],\n      ([x02, y02, w, h, r]) => {\n        let posStr = [x02 - w / 2, y02 - h / 2, w].map(Math.round).join();\n        if (autoHeight)\n          posStr += dataSource === \"directive\" ? \",NaN\" : \",_\";\n        else\n          posStr += `,${Math.round(h)}`;\n        if (Math.round(r) !== 0)\n          posStr += `,${Math.round(r)}`;\n        if (dataSource === \"directive\")\n          posStr = `[${posStr}]`;\n        updater.value(dragId, posStr, dataSource, markdownSource);\n      }\n    )\n  );\n  const state = {\n    dragId,\n    dataSource,\n    markdownSource,\n    isArrow,\n    zoom,\n    autoHeight,\n    x0,\n    y0,\n    width,\n    height,\n    rotate,\n    container,\n    containerStyle,\n    watchStopHandles,\n    dragging: computed(() => activeDragElement.value === state),\n    mounted() {\n      if (!enabled)\n        return;\n      updateBounds();\n      if (!posRaw) {\n        setTimeout(() => {\n          updateBounds();\n          x0.value = (bounds.value.left + bounds.value.width / 2 - slideLeft.value) / scale.value;\n          y0.value = (bounds.value.top - slideTop.value) / scale.value;\n          width.value = bounds.value.width / scale.value;\n          height.value = bounds.value.height / scale.value;\n        }, 100);\n      }\n    },\n    unmounted() {\n      if (!enabled)\n        return;\n      state.stopDragging();\n    },\n    startDragging() {\n      if (!enabled)\n        return;\n      updateBounds();\n      activeDragElement.value = state;\n    },\n    stopDragging() {\n      if (!enabled)\n        return;\n      if (activeDragElement.value === state)\n        activeDragElement.value = null;\n    }\n  };\n  watchStopHandles.push(\n    onClickOutside(container, (ev) => {\n      const container2 = document.querySelector(\"#drag-control-container\");\n      if (container2 && ev.target && container2.contains(ev.target))\n        return;\n      state.stopDragging();\n    }),\n    watch(useWindowFocus(), (focused) => {\n      if (!focused)\n        state.stopDragging();\n    })\n  );\n  return state;\n}\n",
      "start": 1743409708469,
      "end": 1743409708519,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "/Users/stevenhill/gce_git_tutorial/node_modules/@slidev/client/composables/useDragElements.ts"
        ],
        "sourcesContent": [
          "import type { SlidePatch } from '@slidev/types'\nimport type { CSSProperties, DirectiveBinding, InjectionKey, WatchStopHandle } from 'vue'\nimport { debounce, ensureSuffix } from '@antfu/utils'\nimport { injectLocal, onClickOutside, useWindowFocus } from '@vueuse/core'\nimport { computed, ref, watch } from 'vue'\nimport { injectionCurrentPage, injectionFrontmatter, injectionRenderContext, injectionSlideElement, injectionSlideScale, injectionSlideZoom } from '../constants'\nimport { makeId } from '../logic/utils'\nimport { activeDragElement } from '../state'\nimport { directiveInject } from '../utils'\nimport { useNav } from './useNav'\nimport { useSlideBounds } from './useSlideBounds'\nimport { useDynamicSlideInfo } from './useSlideInfo'\n\nexport type DragElementDataSource = 'frontmatter' | 'prop' | 'directive'\n/**\n * Markdown source position, injected by markdown-it plugin\n */\nexport type DragElementMarkdownSource = [startLine: number, endLine: number, index: number]\n\nexport type DragElementsUpdater = (id: string, posStr: string, type: DragElementDataSource, markdownSource?: DragElementMarkdownSource) => void\n\nconst map: Record<number, DragElementsUpdater> = {}\n\nexport function useDragElementsUpdater(no: number) {\n  if (!(__DEV__ && __SLIDEV_FEATURE_EDITOR__))\n    return () => {}\n\n  if (map[no])\n    return map[no]\n\n  const { info, update } = useDynamicSlideInfo(no)\n\n  let newPatch: SlidePatch | null = null\n  async function save() {\n    if (newPatch) {\n      await update({\n        ...newPatch,\n        skipHmr: true,\n      })\n      newPatch = null\n    }\n  }\n  const debouncedSave = debounce(500, save)\n\n  return map[no] = (id, posStr, type, markdownSource) => {\n    if (!info.value)\n      return\n\n    if (type === 'frontmatter') {\n      const frontmatter = info.value.frontmatter\n      frontmatter.dragPos ||= {}\n      if (frontmatter.dragPos[id] === posStr)\n        return\n      frontmatter.dragPos[id] = posStr\n      newPatch = {\n        frontmatter: {\n          dragPos: frontmatter.dragPos,\n        },\n      }\n    }\n    else {\n      if (!markdownSource)\n        throw new Error(`[Slidev] VDrag Element ${id} is missing markdown source`)\n\n      const [startLine, endLine, idx] = markdownSource\n      const lines = info.value.content.split(/\\r?\\n/g)\n\n      let section = lines.slice(startLine, endLine).join('\\n')\n      let replaced = false\n\n      section = type === 'prop'\n      // eslint-disable-next-line regexp/no-super-linear-backtracking\n        ? section.replace(/<(v-?drag-?\\w*)(.*?)(\\/)?>/gi, (full, tag, attrs, selfClose = '', index) => {\n            if (index === idx) {\n              replaced = true\n              const posMatch = attrs.match(/pos=\".*?\"/)\n              if (!posMatch)\n                return `<${tag}${ensureSuffix(' ', attrs)}pos=\"${posStr}\"${selfClose}>`\n              const start = posMatch.index\n              const end = start + posMatch[0].length\n              return `<${tag}${attrs.slice(0, start)}pos=\"${posStr}\"${attrs.slice(end)}${selfClose}>`\n            }\n            return full\n          })\n        : section.replace(/(?<![</\\w])v-drag(?:=\".*?\")?/gi, (full, index) => {\n            if (index === idx) {\n              replaced = true\n              return `v-drag=\"${posStr}\"`\n            }\n            return full\n          })\n\n      if (!replaced)\n        throw new Error(`[Slidev] VDrag Element ${id} is not found in the markdown source`)\n\n      lines.splice(\n        startLine,\n        endLine - startLine,\n        section,\n      )\n\n      const newContent = lines.join('\\n')\n      if (info.value.content === newContent)\n        return\n      newPatch = {\n        content: newContent,\n      }\n      info.value = {\n        ...info.value,\n        content: newContent,\n      }\n    }\n    debouncedSave()\n  }\n}\n\nexport function useDragElement(directive: DirectiveBinding | null, posRaw?: string | number | number[], markdownSource?: DragElementMarkdownSource, isArrow = false) {\n  function inject<T>(key: InjectionKey<T> | string): T | undefined {\n    return directive\n      ? directiveInject(directive, key)\n      : injectLocal(key)\n  }\n\n  const renderContext = inject(injectionRenderContext)!\n  const frontmatter = inject(injectionFrontmatter) ?? {}\n  const page = inject(injectionCurrentPage)!\n  const updater = computed(() => useDragElementsUpdater(page.value))\n  const scale = inject(injectionSlideScale) ?? ref(1)\n  const zoom = inject(injectionSlideZoom) ?? ref(1)\n  const { left: slideLeft, top: slideTop, stop: stopWatchBounds } = useSlideBounds(inject(injectionSlideElement) ?? ref())\n  const { isPrintMode } = useNav()\n  const enabled = ['slide', 'presenter'].includes(renderContext.value) && !isPrintMode.value\n\n  let dataSource: DragElementDataSource = directive ? 'directive' : 'prop'\n  let dragId: string = makeId()\n  let pos: number[] | undefined\n  if (Array.isArray(posRaw)) {\n    pos = posRaw\n  }\n  else if (typeof posRaw === 'string' && posRaw.includes(',')) {\n    pos = posRaw.split(',').map(Number)\n  }\n  else if (posRaw != null) {\n    dataSource = 'frontmatter'\n    dragId = `${posRaw}`\n    posRaw = frontmatter?.dragPos?.[dragId]\n    pos = (posRaw as string)?.split(',').map(Number)\n  }\n\n  if (dataSource !== 'frontmatter' && !markdownSource)\n    throw new Error('[Slidev] Can not identify the source position of the v-drag element, please provide an explicit `id` prop.')\n\n  const watchStopHandles: WatchStopHandle[] = [stopWatchBounds]\n\n  const autoHeight = !isArrow && posRaw != null && !Number.isFinite(pos?.[3])\n  pos ??= [Number.NaN, Number.NaN, 0]\n  const width = ref(pos[2])\n  const x0 = ref(pos[0] + pos[2] / 2)\n\n  const rotate = ref(isArrow ? 0 : (pos[4] ?? 0))\n  const rotateRad = computed(() => rotate.value * Math.PI / 180)\n  const rotateSin = computed(() => Math.sin(rotateRad.value))\n  const rotateCos = computed(() => Math.cos(rotateRad.value))\n\n  const container = ref<HTMLElement>()\n  const bounds = ref({ left: 0, top: 0, width: 0, height: 0 })\n  const actualHeight = ref(0)\n  function updateBounds() {\n    if (!container.value)\n      return\n    const rect = container.value.getBoundingClientRect()\n    bounds.value = {\n      left: rect.left / zoom.value,\n      top: rect.top / zoom.value,\n      width: rect.width / zoom.value,\n      height: rect.height / zoom.value,\n    }\n    actualHeight.value = ((bounds.value.width + bounds.value.height) / scale.value / (Math.abs(rotateSin.value) + Math.abs(rotateCos.value)) - width.value)\n  }\n  watchStopHandles.push(watch(width, updateBounds, { flush: 'post' }))\n\n  const configuredHeight = ref(pos[3] ?? 0)\n  const height = autoHeight\n    ? computed({\n        get: () => (autoHeight ? actualHeight.value : configuredHeight.value) || 0,\n        set: v => !autoHeight && (configuredHeight.value = v),\n      })\n    : configuredHeight\n  const configuredY0 = autoHeight ? ref(pos[1]) : ref(pos[1] + pos[3] / 2)\n  const y0 = autoHeight\n    ? computed({\n        get: () => configuredY0.value + height.value / 2,\n        set: v => configuredY0.value = v - height.value / 2,\n      })\n    : configuredY0\n\n  const containerStyle = computed(() => {\n    return Number.isFinite(x0.value)\n      ? {\n        position: 'absolute',\n        zIndex: 100,\n        left: `${x0.value - width.value / 2}px`,\n        top: `${y0.value - height.value / 2}px`,\n        width: `${width.value}px`,\n        height: autoHeight ? undefined : `${height.value}px`,\n        transformOrigin: 'center center',\n        transform: `rotate(${rotate.value}deg)`,\n      } satisfies CSSProperties\n      : {\n        position: 'absolute',\n        zIndex: 100,\n      } satisfies CSSProperties\n  })\n\n  watchStopHandles.push(\n    watch(\n      [x0, y0, width, height, rotate],\n      ([x0, y0, w, h, r]) => {\n        let posStr = [x0 - w / 2, y0 - h / 2, w].map(Math.round).join()\n        if (autoHeight)\n          posStr += dataSource === 'directive' ? ',NaN' : ',_'\n        else\n          posStr += `,${Math.round(h)}`\n        if (Math.round(r) !== 0)\n          posStr += `,${Math.round(r)}`\n\n        if (dataSource === 'directive')\n          posStr = `[${posStr}]`\n\n        updater.value(dragId, posStr, dataSource, markdownSource)\n      },\n    ),\n  )\n\n  const state = {\n    dragId,\n    dataSource,\n    markdownSource,\n    isArrow,\n    zoom,\n    autoHeight,\n    x0,\n    y0,\n    width,\n    height,\n    rotate,\n    container,\n    containerStyle,\n    watchStopHandles,\n    dragging: computed((): boolean => activeDragElement.value === state),\n    mounted() {\n      if (!enabled)\n        return\n      updateBounds()\n      if (!posRaw) {\n        setTimeout(() => {\n          updateBounds()\n          x0.value = (bounds.value.left + bounds.value.width / 2 - slideLeft.value) / scale.value\n          y0.value = (bounds.value.top - slideTop.value) / scale.value\n          width.value = bounds.value.width / scale.value\n          height.value = bounds.value.height / scale.value\n        }, 100)\n      }\n    },\n    unmounted() {\n      if (!enabled)\n        return\n      state.stopDragging()\n    },\n    startDragging(): void {\n      if (!enabled)\n        return\n      updateBounds()\n      activeDragElement.value = state\n    },\n    stopDragging(): void {\n      if (!enabled)\n        return\n      if (activeDragElement.value === state)\n        activeDragElement.value = null\n    },\n  }\n\n  watchStopHandles.push(\n    onClickOutside(container, (ev) => {\n      const container = document.querySelector('#drag-control-container')\n      if (container && ev.target && container.contains(ev.target as HTMLElement))\n        return\n      state.stopDragging()\n    }),\n    watch(useWindowFocus(), (focused) => {\n      if (!focused)\n        state.stopDragging()\n    }),\n  )\n\n  return state\n}\n\nexport type DragElementState = ReturnType<typeof useDragElement>\n"
        ],
        "mappings": "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",
        "names": [
          "x0",
          "y0",
          "container"
        ]
      }
    },
    {
      "name": "vite:json",
      "start": 1743409708519,
      "end": 1743409708519,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1743409708519,
      "end": 1743409708519,
      "order": "normal"
    },
    {
      "name": "slidev:layout-wrapper",
      "start": 1743409708519,
      "end": 1743409708519,
      "order": "normal"
    },
    {
      "name": "slidev:context-injection",
      "start": 1743409708519,
      "end": 1743409708519,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1743409708519,
      "end": 1743409708519,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1743409708519,
      "end": 1743409708519,
      "order": "normal"
    },
    {
      "name": "slidev:hmr-patch",
      "start": 1743409708519,
      "end": 1743409708519,
      "order": "normal"
    },
    {
      "name": "unocss:transformers:undefined",
      "start": 1743409708519,
      "end": 1743409708519,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { debounce, ensureSuffix } from \"@antfu/utils\";\nimport { injectLocal, onClickOutside, useWindowFocus } from \"@vueuse/core\";\nimport { computed, ref, watch } from \"vue\";\nimport { injectionCurrentPage, injectionFrontmatter, injectionRenderContext, injectionSlideElement, injectionSlideScale, injectionSlideZoom } from \"../constants\";\nimport { makeId } from \"../logic/utils\";\nimport { activeDragElement } from \"../state\";\nimport { directiveInject } from \"../utils\";\nimport { useNav } from \"./useNav\";\nimport { useSlideBounds } from \"./useSlideBounds\";\nimport { useDynamicSlideInfo } from \"./useSlideInfo\";\nconst map = {};\nexport function useDragElementsUpdater(no) {\n  if (true)\n    return () => {\n    };\n  if (map[no])\n    return map[no];\n  const { info, update } = useDynamicSlideInfo(no);\n  let newPatch = null;\n  async function save() {\n    if (newPatch) {\n      await update({\n        ...newPatch,\n        skipHmr: true\n      });\n      newPatch = null;\n    }\n  }\n  const debouncedSave = debounce(500, save);\n  return map[no] = (id, posStr, type, markdownSource) => {\n    if (!info.value)\n      return;\n    if (type === \"frontmatter\") {\n      const frontmatter = info.value.frontmatter;\n      frontmatter.dragPos ||= {};\n      if (frontmatter.dragPos[id] === posStr)\n        return;\n      frontmatter.dragPos[id] = posStr;\n      newPatch = {\n        frontmatter: {\n          dragPos: frontmatter.dragPos\n        }\n      };\n    } else {\n      if (!markdownSource)\n        throw new Error(`[Slidev] VDrag Element ${id} is missing markdown source`);\n      const [startLine, endLine, idx] = markdownSource;\n      const lines = info.value.content.split(/\\r?\\n/g);\n      let section = lines.slice(startLine, endLine).join(\"\\n\");\n      let replaced = false;\n      section = type === \"prop\" ? section.replace(/<(v-?drag-?\\w*)(.*?)(\\/)?>/gi, (full, tag, attrs, selfClose = \"\", index) => {\n        if (index === idx) {\n          replaced = true;\n          const posMatch = attrs.match(/pos=\".*?\"/);\n          if (!posMatch)\n            return `<${tag}${ensureSuffix(\" \", attrs)}pos=\"${posStr}\"${selfClose}>`;\n          const start = posMatch.index;\n          const end = start + posMatch[0].length;\n          return `<${tag}${attrs.slice(0, start)}pos=\"${posStr}\"${attrs.slice(end)}${selfClose}>`;\n        }\n        return full;\n      }) : section.replace(/(?<![</\\w])v-drag(?:=\".*?\")?/gi, (full, index) => {\n        if (index === idx) {\n          replaced = true;\n          return `v-drag=\"${posStr}\"`;\n        }\n        return full;\n      });\n      if (!replaced)\n        throw new Error(`[Slidev] VDrag Element ${id} is not found in the markdown source`);\n      lines.splice(\n        startLine,\n        endLine - startLine,\n        section\n      );\n      const newContent = lines.join(\"\\n\");\n      if (info.value.content === newContent)\n        return;\n      newPatch = {\n        content: newContent\n      };\n      info.value = {\n        ...info.value,\n        content: newContent\n      };\n    }\n    debouncedSave();\n  };\n}\nexport function useDragElement(directive, posRaw, markdownSource, isArrow = false) {\n  function inject(key) {\n    return directive ? directiveInject(directive, key) : injectLocal(key);\n  }\n  const renderContext = inject(injectionRenderContext);\n  const frontmatter = inject(injectionFrontmatter) ?? {};\n  const page = inject(injectionCurrentPage);\n  const updater = computed(() => useDragElementsUpdater(page.value));\n  const scale = inject(injectionSlideScale) ?? ref(1);\n  const zoom = inject(injectionSlideZoom) ?? ref(1);\n  const { left: slideLeft, top: slideTop, stop: stopWatchBounds } = useSlideBounds(inject(injectionSlideElement) ?? ref());\n  const { isPrintMode } = useNav();\n  const enabled = [\"slide\", \"presenter\"].includes(renderContext.value) && !isPrintMode.value;\n  let dataSource = directive ? \"directive\" : \"prop\";\n  let dragId = makeId();\n  let pos;\n  if (Array.isArray(posRaw)) {\n    pos = posRaw;\n  } else if (typeof posRaw === \"string\" && posRaw.includes(\",\")) {\n    pos = posRaw.split(\",\").map(Number);\n  } else if (posRaw != null) {\n    dataSource = \"frontmatter\";\n    dragId = `${posRaw}`;\n    posRaw = frontmatter?.dragPos?.[dragId];\n    pos = posRaw?.split(\",\").map(Number);\n  }\n  if (dataSource !== \"frontmatter\" && !markdownSource)\n    throw new Error(\"[Slidev] Can not identify the source position of the v-drag element, please provide an explicit `id` prop.\");\n  const watchStopHandles = [stopWatchBounds];\n  const autoHeight = !isArrow && posRaw != null && !Number.isFinite(pos?.[3]);\n  pos ??= [Number.NaN, Number.NaN, 0];\n  const width = ref(pos[2]);\n  const x0 = ref(pos[0] + pos[2] / 2);\n  const rotate = ref(isArrow ? 0 : pos[4] ?? 0);\n  const rotateRad = computed(() => rotate.value * Math.PI / 180);\n  const rotateSin = computed(() => Math.sin(rotateRad.value));\n  const rotateCos = computed(() => Math.cos(rotateRad.value));\n  const container = ref();\n  const bounds = ref({ left: 0, top: 0, width: 0, height: 0 });\n  const actualHeight = ref(0);\n  function updateBounds() {\n    if (!container.value)\n      return;\n    const rect = container.value.getBoundingClientRect();\n    bounds.value = {\n      left: rect.left / zoom.value,\n      top: rect.top / zoom.value,\n      width: rect.width / zoom.value,\n      height: rect.height / zoom.value\n    };\n    actualHeight.value = (bounds.value.width + bounds.value.height) / scale.value / (Math.abs(rotateSin.value) + Math.abs(rotateCos.value)) - width.value;\n  }\n  watchStopHandles.push(watch(width, updateBounds, { flush: \"post\" }));\n  const configuredHeight = ref(pos[3] ?? 0);\n  const height = autoHeight ? computed({\n    get: () => (autoHeight ? actualHeight.value : configuredHeight.value) || 0,\n    set: (v) => !autoHeight && (configuredHeight.value = v)\n  }) : configuredHeight;\n  const configuredY0 = autoHeight ? ref(pos[1]) : ref(pos[1] + pos[3] / 2);\n  const y0 = autoHeight ? computed({\n    get: () => configuredY0.value + height.value / 2,\n    set: (v) => configuredY0.value = v - height.value / 2\n  }) : configuredY0;\n  const containerStyle = computed(() => {\n    return Number.isFinite(x0.value) ? {\n      position: \"absolute\",\n      zIndex: 100,\n      left: `${x0.value - width.value / 2}px`,\n      top: `${y0.value - height.value / 2}px`,\n      width: `${width.value}px`,\n      height: autoHeight ? void 0 : `${height.value}px`,\n      transformOrigin: \"center center\",\n      transform: `rotate(${rotate.value}deg)`\n    } : {\n      position: \"absolute\",\n      zIndex: 100\n    };\n  });\n  watchStopHandles.push(\n    watch(\n      [x0, y0, width, height, rotate],\n      ([x02, y02, w, h, r]) => {\n        let posStr = [x02 - w / 2, y02 - h / 2, w].map(Math.round).join();\n        if (autoHeight)\n          posStr += dataSource === \"directive\" ? \",NaN\" : \",_\";\n        else\n          posStr += `,${Math.round(h)}`;\n        if (Math.round(r) !== 0)\n          posStr += `,${Math.round(r)}`;\n        if (dataSource === \"directive\")\n          posStr = `[${posStr}]`;\n        updater.value(dragId, posStr, dataSource, markdownSource);\n      }\n    )\n  );\n  const state = {\n    dragId,\n    dataSource,\n    markdownSource,\n    isArrow,\n    zoom,\n    autoHeight,\n    x0,\n    y0,\n    width,\n    height,\n    rotate,\n    container,\n    containerStyle,\n    watchStopHandles,\n    dragging: computed(() => activeDragElement.value === state),\n    mounted() {\n      if (!enabled)\n        return;\n      updateBounds();\n      if (!posRaw) {\n        setTimeout(() => {\n          updateBounds();\n          x0.value = (bounds.value.left + bounds.value.width / 2 - slideLeft.value) / scale.value;\n          y0.value = (bounds.value.top - slideTop.value) / scale.value;\n          width.value = bounds.value.width / scale.value;\n          height.value = bounds.value.height / scale.value;\n        }, 100);\n      }\n    },\n    unmounted() {\n      if (!enabled)\n        return;\n      state.stopDragging();\n    },\n    startDragging() {\n      if (!enabled)\n        return;\n      updateBounds();\n      activeDragElement.value = state;\n    },\n    stopDragging() {\n      if (!enabled)\n        return;\n      if (activeDragElement.value === state)\n        activeDragElement.value = null;\n    }\n  };\n  watchStopHandles.push(\n    onClickOutside(container, (ev) => {\n      const container2 = document.querySelector(\"#drag-control-container\");\n      if (container2 && ev.target && container2.contains(ev.target))\n        return;\n      state.stopDragging();\n    }),\n    watch(useWindowFocus(), (focused) => {\n      if (!focused)\n        state.stopDragging();\n    })\n  );\n  return state;\n}\n",
      "start": 1743409708519,
      "end": 1743409708624,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "normal"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "post"
    },
    {
      "name": "unocss:transformers:post",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1743409708624,
      "end": 1743409708624,
      "order": "normal"
    }
  ]
}
