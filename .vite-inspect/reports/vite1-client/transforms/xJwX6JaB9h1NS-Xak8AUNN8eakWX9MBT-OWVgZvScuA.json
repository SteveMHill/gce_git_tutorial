{
  "resolvedId": "/Users/stevenhill/gce_git_tutorial/node_modules/mermaid/dist/chunks/mermaid.esm/architectureDiagram-RWNHDUBN.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import {\n  cytoscape as cytoscape2\n} from \"./chunk-COUQ6RZ3.mjs\";\nimport {\n  ImperativeState\n} from \"./chunk-YJGJQOYZ.mjs\";\nimport {\n  populateCommonDb\n} from \"./chunk-K2ZEYYM2.mjs\";\nimport {\n  parse\n} from \"./chunk-XIYN7VYH.mjs\";\nimport \"./chunk-SDBY772Q.mjs\";\nimport \"./chunk-CCYIEPPW.mjs\";\nimport \"./chunk-OTG2ZAWT.mjs\";\nimport \"./chunk-7JTU5PD2.mjs\";\nimport {\n  selectSvgElement\n} from \"./chunk-YIX7P6T4.mjs\";\nimport {\n  getIconSVG,\n  registerIconPacks,\n  unknownIcon\n} from \"./chunk-Q7X626QO.mjs\";\nimport {\n  createText\n} from \"./chunk-STFVS7YW.mjs\";\nimport \"./chunk-YFKFDTKC.mjs\";\nimport \"./chunk-GKOISANM.mjs\";\nimport {\n  clear,\n  defaultConfig_default,\n  getAccDescription,\n  getAccTitle,\n  getConfig2 as getConfig,\n  getDiagramTitle,\n  log,\n  select_default,\n  setAccDescription,\n  setAccTitle,\n  setDiagramTitle,\n  setupGraphViewbox\n} from \"./chunk-3L32CQKD.mjs\";\nimport \"./chunk-GTV5PL3S.mjs\";\nimport \"./chunk-4AQQYWZS.mjs\";\nimport \"./chunk-R4WPHL2B.mjs\";\nimport \"./chunk-TGZYFRKZ.mjs\";\nimport \"./chunk-GRZAG2UZ.mjs\";\nimport \"./chunk-HD3LK5B5.mjs\";\nimport {\n  __commonJS,\n  __name,\n  __toESM\n} from \"./chunk-DLQEHMXD.mjs\";\n\n// ../../node_modules/.pnpm/layout-base@2.0.1/node_modules/layout-base/layout-base.js\nvar require_layout_base = __commonJS({\n  \"../../node_modules/.pnpm/layout-base@2.0.1/node_modules/layout-base/layout-base.js\"(exports, module) {\n    \"use strict\";\n    (/* @__PURE__ */ __name(function webpackUniversalModuleDefinition(root, factory) {\n      if (typeof exports === \"object\" && typeof module === \"object\")\n        module.exports = factory();\n      else if (typeof define === \"function\" && define.amd)\n        define([], factory);\n      else if (typeof exports === \"object\")\n        exports[\"layoutBase\"] = factory();\n      else\n        root[\"layoutBase\"] = factory();\n    }, \"webpackUniversalModuleDefinition\"))(exports, function() {\n      return (\n        /******/\n        function(modules) {\n          var installedModules = {};\n          function __webpack_require__(moduleId) {\n            if (installedModules[moduleId]) {\n              return installedModules[moduleId].exports;\n            }\n            var module2 = installedModules[moduleId] = {\n              /******/\n              i: moduleId,\n              /******/\n              l: false,\n              /******/\n              exports: {}\n              /******/\n            };\n            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);\n            module2.l = true;\n            return module2.exports;\n          }\n          __name(__webpack_require__, \"__webpack_require__\");\n          __webpack_require__.m = modules;\n          __webpack_require__.c = installedModules;\n          __webpack_require__.i = function(value) {\n            return value;\n          };\n          __webpack_require__.d = function(exports2, name, getter) {\n            if (!__webpack_require__.o(exports2, name)) {\n              Object.defineProperty(exports2, name, {\n                /******/\n                configurable: false,\n                /******/\n                enumerable: true,\n                /******/\n                get: getter\n                /******/\n              });\n            }\n          };\n          __webpack_require__.n = function(module2) {\n            var getter = module2 && module2.__esModule ? (\n              /******/\n              /* @__PURE__ */ __name(function getDefault() {\n                return module2[\"default\"];\n              }, \"getDefault\")\n            ) : (\n              /******/\n              /* @__PURE__ */ __name(function getModuleExports() {\n                return module2;\n              }, \"getModuleExports\")\n            );\n            __webpack_require__.d(getter, \"a\", getter);\n            return getter;\n          };\n          __webpack_require__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n          };\n          __webpack_require__.p = \"\";\n          return __webpack_require__(__webpack_require__.s = 28);\n        }([\n          /* 0 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function LayoutConstants() {\n            }\n            __name(LayoutConstants, \"LayoutConstants\");\n            LayoutConstants.QUALITY = 1;\n            LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\n            LayoutConstants.DEFAULT_INCREMENTAL = false;\n            LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\n            LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\n            LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\n            LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n            LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n            LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n            LayoutConstants.SIMPLE_NODE_SIZE = 40;\n            LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n            LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n            LayoutConstants.MIN_EDGE_LENGTH = 1;\n            LayoutConstants.WORLD_BOUNDARY = 1e6;\n            LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1e3;\n            LayoutConstants.WORLD_CENTER_X = 1200;\n            LayoutConstants.WORLD_CENTER_Y = 900;\n            module2.exports = LayoutConstants;\n          },\n          /* 1 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var LGraphObject = __webpack_require__(2);\n            var IGeometry = __webpack_require__(8);\n            var IMath = __webpack_require__(9);\n            function LEdge(source, target, vEdge) {\n              LGraphObject.call(this, vEdge);\n              this.isOverlapingSourceAndTarget = false;\n              this.vGraphObject = vEdge;\n              this.bendpoints = [];\n              this.source = source;\n              this.target = target;\n            }\n            __name(LEdge, \"LEdge\");\n            LEdge.prototype = Object.create(LGraphObject.prototype);\n            for (var prop in LGraphObject) {\n              LEdge[prop] = LGraphObject[prop];\n            }\n            LEdge.prototype.getSource = function() {\n              return this.source;\n            };\n            LEdge.prototype.getTarget = function() {\n              return this.target;\n            };\n            LEdge.prototype.isInterGraph = function() {\n              return this.isInterGraph;\n            };\n            LEdge.prototype.getLength = function() {\n              return this.length;\n            };\n            LEdge.prototype.isOverlapingSourceAndTarget = function() {\n              return this.isOverlapingSourceAndTarget;\n            };\n            LEdge.prototype.getBendpoints = function() {\n              return this.bendpoints;\n            };\n            LEdge.prototype.getLca = function() {\n              return this.lca;\n            };\n            LEdge.prototype.getSourceInLca = function() {\n              return this.sourceInLca;\n            };\n            LEdge.prototype.getTargetInLca = function() {\n              return this.targetInLca;\n            };\n            LEdge.prototype.getOtherEnd = function(node) {\n              if (this.source === node) {\n                return this.target;\n              } else if (this.target === node) {\n                return this.source;\n              } else {\n                throw \"Node is not incident with this edge\";\n              }\n            };\n            LEdge.prototype.getOtherEndInGraph = function(node, graph) {\n              var otherEnd = this.getOtherEnd(node);\n              var root = graph.getGraphManager().getRoot();\n              while (true) {\n                if (otherEnd.getOwner() == graph) {\n                  return otherEnd;\n                }\n                if (otherEnd.getOwner() == root) {\n                  break;\n                }\n                otherEnd = otherEnd.getOwner().getParent();\n              }\n              return null;\n            };\n            LEdge.prototype.updateLength = function() {\n              var clipPointCoordinates = new Array(4);\n              this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n              if (!this.isOverlapingSourceAndTarget) {\n                this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n                this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n                if (Math.abs(this.lengthX) < 1) {\n                  this.lengthX = IMath.sign(this.lengthX);\n                }\n                if (Math.abs(this.lengthY) < 1) {\n                  this.lengthY = IMath.sign(this.lengthY);\n                }\n                this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n              }\n            };\n            LEdge.prototype.updateLengthSimple = function() {\n              this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n              this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n              if (Math.abs(this.lengthX) < 1) {\n                this.lengthX = IMath.sign(this.lengthX);\n              }\n              if (Math.abs(this.lengthY) < 1) {\n                this.lengthY = IMath.sign(this.lengthY);\n              }\n              this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n            };\n            module2.exports = LEdge;\n          },\n          /* 2 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function LGraphObject(vGraphObject) {\n              this.vGraphObject = vGraphObject;\n            }\n            __name(LGraphObject, \"LGraphObject\");\n            module2.exports = LGraphObject;\n          },\n          /* 3 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var LGraphObject = __webpack_require__(2);\n            var Integer = __webpack_require__(10);\n            var RectangleD = __webpack_require__(13);\n            var LayoutConstants = __webpack_require__(0);\n            var RandomSeed = __webpack_require__(16);\n            var PointD = __webpack_require__(5);\n            function LNode(gm, loc, size, vNode) {\n              if (size == null && vNode == null) {\n                vNode = loc;\n              }\n              LGraphObject.call(this, vNode);\n              if (gm.graphManager != null) gm = gm.graphManager;\n              this.estimatedSize = Integer.MIN_VALUE;\n              this.inclusionTreeDepth = Integer.MAX_VALUE;\n              this.vGraphObject = vNode;\n              this.edges = [];\n              this.graphManager = gm;\n              if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);\n              else this.rect = new RectangleD();\n            }\n            __name(LNode, \"LNode\");\n            LNode.prototype = Object.create(LGraphObject.prototype);\n            for (var prop in LGraphObject) {\n              LNode[prop] = LGraphObject[prop];\n            }\n            LNode.prototype.getEdges = function() {\n              return this.edges;\n            };\n            LNode.prototype.getChild = function() {\n              return this.child;\n            };\n            LNode.prototype.getOwner = function() {\n              return this.owner;\n            };\n            LNode.prototype.getWidth = function() {\n              return this.rect.width;\n            };\n            LNode.prototype.setWidth = function(width) {\n              this.rect.width = width;\n            };\n            LNode.prototype.getHeight = function() {\n              return this.rect.height;\n            };\n            LNode.prototype.setHeight = function(height) {\n              this.rect.height = height;\n            };\n            LNode.prototype.getCenterX = function() {\n              return this.rect.x + this.rect.width / 2;\n            };\n            LNode.prototype.getCenterY = function() {\n              return this.rect.y + this.rect.height / 2;\n            };\n            LNode.prototype.getCenter = function() {\n              return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n            };\n            LNode.prototype.getLocation = function() {\n              return new PointD(this.rect.x, this.rect.y);\n            };\n            LNode.prototype.getRect = function() {\n              return this.rect;\n            };\n            LNode.prototype.getDiagonal = function() {\n              return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n            };\n            LNode.prototype.getHalfTheDiagonal = function() {\n              return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n            };\n            LNode.prototype.setRect = function(upperLeft, dimension) {\n              this.rect.x = upperLeft.x;\n              this.rect.y = upperLeft.y;\n              this.rect.width = dimension.width;\n              this.rect.height = dimension.height;\n            };\n            LNode.prototype.setCenter = function(cx, cy) {\n              this.rect.x = cx - this.rect.width / 2;\n              this.rect.y = cy - this.rect.height / 2;\n            };\n            LNode.prototype.setLocation = function(x, y) {\n              this.rect.x = x;\n              this.rect.y = y;\n            };\n            LNode.prototype.moveBy = function(dx, dy) {\n              this.rect.x += dx;\n              this.rect.y += dy;\n            };\n            LNode.prototype.getEdgeListToNode = function(to) {\n              var edgeList = [];\n              var edge;\n              var self = this;\n              self.edges.forEach(function(edge2) {\n                if (edge2.target == to) {\n                  if (edge2.source != self) throw \"Incorrect edge source!\";\n                  edgeList.push(edge2);\n                }\n              });\n              return edgeList;\n            };\n            LNode.prototype.getEdgesBetween = function(other) {\n              var edgeList = [];\n              var edge;\n              var self = this;\n              self.edges.forEach(function(edge2) {\n                if (!(edge2.source == self || edge2.target == self)) throw \"Incorrect edge source and/or target\";\n                if (edge2.target == other || edge2.source == other) {\n                  edgeList.push(edge2);\n                }\n              });\n              return edgeList;\n            };\n            LNode.prototype.getNeighborsList = function() {\n              var neighbors = /* @__PURE__ */ new Set();\n              var self = this;\n              self.edges.forEach(function(edge) {\n                if (edge.source == self) {\n                  neighbors.add(edge.target);\n                } else {\n                  if (edge.target != self) {\n                    throw \"Incorrect incidency!\";\n                  }\n                  neighbors.add(edge.source);\n                }\n              });\n              return neighbors;\n            };\n            LNode.prototype.withChildren = function() {\n              var withNeighborsList = /* @__PURE__ */ new Set();\n              var childNode;\n              var children;\n              withNeighborsList.add(this);\n              if (this.child != null) {\n                var nodes = this.child.getNodes();\n                for (var i = 0; i < nodes.length; i++) {\n                  childNode = nodes[i];\n                  children = childNode.withChildren();\n                  children.forEach(function(node) {\n                    withNeighborsList.add(node);\n                  });\n                }\n              }\n              return withNeighborsList;\n            };\n            LNode.prototype.getNoOfChildren = function() {\n              var noOfChildren = 0;\n              var childNode;\n              if (this.child == null) {\n                noOfChildren = 1;\n              } else {\n                var nodes = this.child.getNodes();\n                for (var i = 0; i < nodes.length; i++) {\n                  childNode = nodes[i];\n                  noOfChildren += childNode.getNoOfChildren();\n                }\n              }\n              if (noOfChildren == 0) {\n                noOfChildren = 1;\n              }\n              return noOfChildren;\n            };\n            LNode.prototype.getEstimatedSize = function() {\n              if (this.estimatedSize == Integer.MIN_VALUE) {\n                throw \"assert failed\";\n              }\n              return this.estimatedSize;\n            };\n            LNode.prototype.calcEstimatedSize = function() {\n              if (this.child == null) {\n                return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n              } else {\n                this.estimatedSize = this.child.calcEstimatedSize();\n                this.rect.width = this.estimatedSize;\n                this.rect.height = this.estimatedSize;\n                return this.estimatedSize;\n              }\n            };\n            LNode.prototype.scatter = function() {\n              var randomCenterX;\n              var randomCenterY;\n              var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n              var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n              randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n              var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n              var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n              randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n              this.rect.x = randomCenterX;\n              this.rect.y = randomCenterY;\n            };\n            LNode.prototype.updateBounds = function() {\n              if (this.getChild() == null) {\n                throw \"assert failed\";\n              }\n              if (this.getChild().getNodes().length != 0) {\n                var childGraph = this.getChild();\n                childGraph.updateBounds(true);\n                this.rect.x = childGraph.getLeft();\n                this.rect.y = childGraph.getTop();\n                this.setWidth(childGraph.getRight() - childGraph.getLeft());\n                this.setHeight(childGraph.getBottom() - childGraph.getTop());\n                if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                  var width = childGraph.getRight() - childGraph.getLeft();\n                  var height = childGraph.getBottom() - childGraph.getTop();\n                  if (this.labelWidth) {\n                    if (this.labelPosHorizontal == \"left\") {\n                      this.rect.x -= this.labelWidth;\n                      this.setWidth(width + this.labelWidth);\n                    } else if (this.labelPosHorizontal == \"center\" && this.labelWidth > width) {\n                      this.rect.x -= (this.labelWidth - width) / 2;\n                      this.setWidth(this.labelWidth);\n                    } else if (this.labelPosHorizontal == \"right\") {\n                      this.setWidth(width + this.labelWidth);\n                    }\n                  }\n                  if (this.labelHeight) {\n                    if (this.labelPosVertical == \"top\") {\n                      this.rect.y -= this.labelHeight;\n                      this.setHeight(height + this.labelHeight);\n                    } else if (this.labelPosVertical == \"center\" && this.labelHeight > height) {\n                      this.rect.y -= (this.labelHeight - height) / 2;\n                      this.setHeight(this.labelHeight);\n                    } else if (this.labelPosVertical == \"bottom\") {\n                      this.setHeight(height + this.labelHeight);\n                    }\n                  }\n                }\n              }\n            };\n            LNode.prototype.getInclusionTreeDepth = function() {\n              if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n                throw \"assert failed\";\n              }\n              return this.inclusionTreeDepth;\n            };\n            LNode.prototype.transform = function(trans) {\n              var left = this.rect.x;\n              if (left > LayoutConstants.WORLD_BOUNDARY) {\n                left = LayoutConstants.WORLD_BOUNDARY;\n              } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n                left = -LayoutConstants.WORLD_BOUNDARY;\n              }\n              var top = this.rect.y;\n              if (top > LayoutConstants.WORLD_BOUNDARY) {\n                top = LayoutConstants.WORLD_BOUNDARY;\n              } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n                top = -LayoutConstants.WORLD_BOUNDARY;\n              }\n              var leftTop = new PointD(left, top);\n              var vLeftTop = trans.inverseTransformPoint(leftTop);\n              this.setLocation(vLeftTop.x, vLeftTop.y);\n            };\n            LNode.prototype.getLeft = function() {\n              return this.rect.x;\n            };\n            LNode.prototype.getRight = function() {\n              return this.rect.x + this.rect.width;\n            };\n            LNode.prototype.getTop = function() {\n              return this.rect.y;\n            };\n            LNode.prototype.getBottom = function() {\n              return this.rect.y + this.rect.height;\n            };\n            LNode.prototype.getParent = function() {\n              if (this.owner == null) {\n                return null;\n              }\n              return this.owner.getParent();\n            };\n            module2.exports = LNode;\n          },\n          /* 4 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var LayoutConstants = __webpack_require__(0);\n            function FDLayoutConstants() {\n            }\n            __name(FDLayoutConstants, \"FDLayoutConstants\");\n            for (var prop in LayoutConstants) {\n              FDLayoutConstants[prop] = LayoutConstants[prop];\n            }\n            FDLayoutConstants.MAX_ITERATIONS = 2500;\n            FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n            FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\n            FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500;\n            FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1;\n            FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\n            FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\n            FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\n            FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1e3;\n            FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5e3;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\n            FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10;\n            FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\n            FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\n            FDLayoutConstants.MIN_EDGE_LENGTH = 1;\n            FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n            module2.exports = FDLayoutConstants;\n          },\n          /* 5 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function PointD(x, y) {\n              if (x == null && y == null) {\n                this.x = 0;\n                this.y = 0;\n              } else {\n                this.x = x;\n                this.y = y;\n              }\n            }\n            __name(PointD, \"PointD\");\n            PointD.prototype.getX = function() {\n              return this.x;\n            };\n            PointD.prototype.getY = function() {\n              return this.y;\n            };\n            PointD.prototype.setX = function(x) {\n              this.x = x;\n            };\n            PointD.prototype.setY = function(y) {\n              this.y = y;\n            };\n            PointD.prototype.getDifference = function(pt) {\n              return new DimensionD(this.x - pt.x, this.y - pt.y);\n            };\n            PointD.prototype.getCopy = function() {\n              return new PointD(this.x, this.y);\n            };\n            PointD.prototype.translate = function(dim) {\n              this.x += dim.width;\n              this.y += dim.height;\n              return this;\n            };\n            module2.exports = PointD;\n          },\n          /* 6 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var LGraphObject = __webpack_require__(2);\n            var Integer = __webpack_require__(10);\n            var LayoutConstants = __webpack_require__(0);\n            var LGraphManager = __webpack_require__(7);\n            var LNode = __webpack_require__(3);\n            var LEdge = __webpack_require__(1);\n            var RectangleD = __webpack_require__(13);\n            var Point2 = __webpack_require__(12);\n            var LinkedList = __webpack_require__(11);\n            function LGraph(parent, obj2, vGraph) {\n              LGraphObject.call(this, vGraph);\n              this.estimatedSize = Integer.MIN_VALUE;\n              this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n              this.edges = [];\n              this.nodes = [];\n              this.isConnected = false;\n              this.parent = parent;\n              if (obj2 != null && obj2 instanceof LGraphManager) {\n                this.graphManager = obj2;\n              } else if (obj2 != null && obj2 instanceof Layout) {\n                this.graphManager = obj2.graphManager;\n              }\n            }\n            __name(LGraph, \"LGraph\");\n            LGraph.prototype = Object.create(LGraphObject.prototype);\n            for (var prop in LGraphObject) {\n              LGraph[prop] = LGraphObject[prop];\n            }\n            LGraph.prototype.getNodes = function() {\n              return this.nodes;\n            };\n            LGraph.prototype.getEdges = function() {\n              return this.edges;\n            };\n            LGraph.prototype.getGraphManager = function() {\n              return this.graphManager;\n            };\n            LGraph.prototype.getParent = function() {\n              return this.parent;\n            };\n            LGraph.prototype.getLeft = function() {\n              return this.left;\n            };\n            LGraph.prototype.getRight = function() {\n              return this.right;\n            };\n            LGraph.prototype.getTop = function() {\n              return this.top;\n            };\n            LGraph.prototype.getBottom = function() {\n              return this.bottom;\n            };\n            LGraph.prototype.isConnected = function() {\n              return this.isConnected;\n            };\n            LGraph.prototype.add = function(obj1, sourceNode, targetNode) {\n              if (sourceNode == null && targetNode == null) {\n                var newNode = obj1;\n                if (this.graphManager == null) {\n                  throw \"Graph has no graph mgr!\";\n                }\n                if (this.getNodes().indexOf(newNode) > -1) {\n                  throw \"Node already in graph!\";\n                }\n                newNode.owner = this;\n                this.getNodes().push(newNode);\n                return newNode;\n              } else {\n                var newEdge = obj1;\n                if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n                  throw \"Source or target not in graph!\";\n                }\n                if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n                  throw \"Both owners must be this graph!\";\n                }\n                if (sourceNode.owner != targetNode.owner) {\n                  return null;\n                }\n                newEdge.source = sourceNode;\n                newEdge.target = targetNode;\n                newEdge.isInterGraph = false;\n                this.getEdges().push(newEdge);\n                sourceNode.edges.push(newEdge);\n                if (targetNode != sourceNode) {\n                  targetNode.edges.push(newEdge);\n                }\n                return newEdge;\n              }\n            };\n            LGraph.prototype.remove = function(obj) {\n              var node = obj;\n              if (obj instanceof LNode) {\n                if (node == null) {\n                  throw \"Node is null!\";\n                }\n                if (!(node.owner != null && node.owner == this)) {\n                  throw \"Owner graph is invalid!\";\n                }\n                if (this.graphManager == null) {\n                  throw \"Owner graph manager is invalid!\";\n                }\n                var edgesToBeRemoved = node.edges.slice();\n                var edge;\n                var s = edgesToBeRemoved.length;\n                for (var i = 0; i < s; i++) {\n                  edge = edgesToBeRemoved[i];\n                  if (edge.isInterGraph) {\n                    this.graphManager.remove(edge);\n                  } else {\n                    edge.source.owner.remove(edge);\n                  }\n                }\n                var index = this.nodes.indexOf(node);\n                if (index == -1) {\n                  throw \"Node not in owner node list!\";\n                }\n                this.nodes.splice(index, 1);\n              } else if (obj instanceof LEdge) {\n                var edge = obj;\n                if (edge == null) {\n                  throw \"Edge is null!\";\n                }\n                if (!(edge.source != null && edge.target != null)) {\n                  throw \"Source and/or target is null!\";\n                }\n                if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n                  throw \"Source and/or target owner is invalid!\";\n                }\n                var sourceIndex = edge.source.edges.indexOf(edge);\n                var targetIndex = edge.target.edges.indexOf(edge);\n                if (!(sourceIndex > -1 && targetIndex > -1)) {\n                  throw \"Source and/or target doesn't know this edge!\";\n                }\n                edge.source.edges.splice(sourceIndex, 1);\n                if (edge.target != edge.source) {\n                  edge.target.edges.splice(targetIndex, 1);\n                }\n                var index = edge.source.owner.getEdges().indexOf(edge);\n                if (index == -1) {\n                  throw \"Not in owner's edge list!\";\n                }\n                edge.source.owner.getEdges().splice(index, 1);\n              }\n            };\n            LGraph.prototype.updateLeftTop = function() {\n              var top = Integer.MAX_VALUE;\n              var left = Integer.MAX_VALUE;\n              var nodeTop;\n              var nodeLeft;\n              var margin;\n              var nodes = this.getNodes();\n              var s = nodes.length;\n              for (var i = 0; i < s; i++) {\n                var lNode = nodes[i];\n                nodeTop = lNode.getTop();\n                nodeLeft = lNode.getLeft();\n                if (top > nodeTop) {\n                  top = nodeTop;\n                }\n                if (left > nodeLeft) {\n                  left = nodeLeft;\n                }\n              }\n              if (top == Integer.MAX_VALUE) {\n                return null;\n              }\n              if (nodes[0].getParent().paddingLeft != void 0) {\n                margin = nodes[0].getParent().paddingLeft;\n              } else {\n                margin = this.margin;\n              }\n              this.left = left - margin;\n              this.top = top - margin;\n              return new Point2(this.left, this.top);\n            };\n            LGraph.prototype.updateBounds = function(recursive) {\n              var left = Integer.MAX_VALUE;\n              var right = -Integer.MAX_VALUE;\n              var top = Integer.MAX_VALUE;\n              var bottom = -Integer.MAX_VALUE;\n              var nodeLeft;\n              var nodeRight;\n              var nodeTop;\n              var nodeBottom;\n              var margin;\n              var nodes = this.nodes;\n              var s = nodes.length;\n              for (var i = 0; i < s; i++) {\n                var lNode = nodes[i];\n                if (recursive && lNode.child != null) {\n                  lNode.updateBounds();\n                }\n                nodeLeft = lNode.getLeft();\n                nodeRight = lNode.getRight();\n                nodeTop = lNode.getTop();\n                nodeBottom = lNode.getBottom();\n                if (left > nodeLeft) {\n                  left = nodeLeft;\n                }\n                if (right < nodeRight) {\n                  right = nodeRight;\n                }\n                if (top > nodeTop) {\n                  top = nodeTop;\n                }\n                if (bottom < nodeBottom) {\n                  bottom = nodeBottom;\n                }\n              }\n              var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n              if (left == Integer.MAX_VALUE) {\n                this.left = this.parent.getLeft();\n                this.right = this.parent.getRight();\n                this.top = this.parent.getTop();\n                this.bottom = this.parent.getBottom();\n              }\n              if (nodes[0].getParent().paddingLeft != void 0) {\n                margin = nodes[0].getParent().paddingLeft;\n              } else {\n                margin = this.margin;\n              }\n              this.left = boundingRect.x - margin;\n              this.right = boundingRect.x + boundingRect.width + margin;\n              this.top = boundingRect.y - margin;\n              this.bottom = boundingRect.y + boundingRect.height + margin;\n            };\n            LGraph.calculateBounds = function(nodes) {\n              var left = Integer.MAX_VALUE;\n              var right = -Integer.MAX_VALUE;\n              var top = Integer.MAX_VALUE;\n              var bottom = -Integer.MAX_VALUE;\n              var nodeLeft;\n              var nodeRight;\n              var nodeTop;\n              var nodeBottom;\n              var s = nodes.length;\n              for (var i = 0; i < s; i++) {\n                var lNode = nodes[i];\n                nodeLeft = lNode.getLeft();\n                nodeRight = lNode.getRight();\n                nodeTop = lNode.getTop();\n                nodeBottom = lNode.getBottom();\n                if (left > nodeLeft) {\n                  left = nodeLeft;\n                }\n                if (right < nodeRight) {\n                  right = nodeRight;\n                }\n                if (top > nodeTop) {\n                  top = nodeTop;\n                }\n                if (bottom < nodeBottom) {\n                  bottom = nodeBottom;\n                }\n              }\n              var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n              return boundingRect;\n            };\n            LGraph.prototype.getInclusionTreeDepth = function() {\n              if (this == this.graphManager.getRoot()) {\n                return 1;\n              } else {\n                return this.parent.getInclusionTreeDepth();\n              }\n            };\n            LGraph.prototype.getEstimatedSize = function() {\n              if (this.estimatedSize == Integer.MIN_VALUE) {\n                throw \"assert failed\";\n              }\n              return this.estimatedSize;\n            };\n            LGraph.prototype.calcEstimatedSize = function() {\n              var size = 0;\n              var nodes = this.nodes;\n              var s = nodes.length;\n              for (var i = 0; i < s; i++) {\n                var lNode = nodes[i];\n                size += lNode.calcEstimatedSize();\n              }\n              if (size == 0) {\n                this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n              } else {\n                this.estimatedSize = size / Math.sqrt(this.nodes.length);\n              }\n              return this.estimatedSize;\n            };\n            LGraph.prototype.updateConnected = function() {\n              var self = this;\n              if (this.nodes.length == 0) {\n                this.isConnected = true;\n                return;\n              }\n              var queue = new LinkedList();\n              var visited = /* @__PURE__ */ new Set();\n              var currentNode = this.nodes[0];\n              var neighborEdges;\n              var currentNeighbor;\n              var childrenOfNode = currentNode.withChildren();\n              childrenOfNode.forEach(function(node) {\n                queue.push(node);\n                visited.add(node);\n              });\n              while (queue.length !== 0) {\n                currentNode = queue.shift();\n                neighborEdges = currentNode.getEdges();\n                var size = neighborEdges.length;\n                for (var i = 0; i < size; i++) {\n                  var neighborEdge = neighborEdges[i];\n                  currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n                  if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n                    var childrenOfNeighbor = currentNeighbor.withChildren();\n                    childrenOfNeighbor.forEach(function(node) {\n                      queue.push(node);\n                      visited.add(node);\n                    });\n                  }\n                }\n              }\n              this.isConnected = false;\n              if (visited.size >= this.nodes.length) {\n                var noOfVisitedInThisGraph = 0;\n                visited.forEach(function(visitedNode) {\n                  if (visitedNode.owner == self) {\n                    noOfVisitedInThisGraph++;\n                  }\n                });\n                if (noOfVisitedInThisGraph == this.nodes.length) {\n                  this.isConnected = true;\n                }\n              }\n            };\n            module2.exports = LGraph;\n          },\n          /* 7 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var LGraph;\n            var LEdge = __webpack_require__(1);\n            function LGraphManager(layout) {\n              LGraph = __webpack_require__(6);\n              this.layout = layout;\n              this.graphs = [];\n              this.edges = [];\n            }\n            __name(LGraphManager, \"LGraphManager\");\n            LGraphManager.prototype.addRoot = function() {\n              var ngraph = this.layout.newGraph();\n              var nnode = this.layout.newNode(null);\n              var root = this.add(ngraph, nnode);\n              this.setRootGraph(root);\n              return this.rootGraph;\n            };\n            LGraphManager.prototype.add = function(newGraph, parentNode, newEdge, sourceNode, targetNode) {\n              if (newEdge == null && sourceNode == null && targetNode == null) {\n                if (newGraph == null) {\n                  throw \"Graph is null!\";\n                }\n                if (parentNode == null) {\n                  throw \"Parent node is null!\";\n                }\n                if (this.graphs.indexOf(newGraph) > -1) {\n                  throw \"Graph already in this graph mgr!\";\n                }\n                this.graphs.push(newGraph);\n                if (newGraph.parent != null) {\n                  throw \"Already has a parent!\";\n                }\n                if (parentNode.child != null) {\n                  throw \"Already has a child!\";\n                }\n                newGraph.parent = parentNode;\n                parentNode.child = newGraph;\n                return newGraph;\n              } else {\n                targetNode = newEdge;\n                sourceNode = parentNode;\n                newEdge = newGraph;\n                var sourceGraph = sourceNode.getOwner();\n                var targetGraph = targetNode.getOwner();\n                if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n                  throw \"Source not in this graph mgr!\";\n                }\n                if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n                  throw \"Target not in this graph mgr!\";\n                }\n                if (sourceGraph == targetGraph) {\n                  newEdge.isInterGraph = false;\n                  return sourceGraph.add(newEdge, sourceNode, targetNode);\n                } else {\n                  newEdge.isInterGraph = true;\n                  newEdge.source = sourceNode;\n                  newEdge.target = targetNode;\n                  if (this.edges.indexOf(newEdge) > -1) {\n                    throw \"Edge already in inter-graph edge list!\";\n                  }\n                  this.edges.push(newEdge);\n                  if (!(newEdge.source != null && newEdge.target != null)) {\n                    throw \"Edge source and/or target is null!\";\n                  }\n                  if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n                    throw \"Edge already in source and/or target incidency list!\";\n                  }\n                  newEdge.source.edges.push(newEdge);\n                  newEdge.target.edges.push(newEdge);\n                  return newEdge;\n                }\n              }\n            };\n            LGraphManager.prototype.remove = function(lObj) {\n              if (lObj instanceof LGraph) {\n                var graph = lObj;\n                if (graph.getGraphManager() != this) {\n                  throw \"Graph not in this graph mgr\";\n                }\n                if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n                  throw \"Invalid parent node!\";\n                }\n                var edgesToBeRemoved = [];\n                edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n                var edge;\n                var s = edgesToBeRemoved.length;\n                for (var i = 0; i < s; i++) {\n                  edge = edgesToBeRemoved[i];\n                  graph.remove(edge);\n                }\n                var nodesToBeRemoved = [];\n                nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n                var node;\n                s = nodesToBeRemoved.length;\n                for (var i = 0; i < s; i++) {\n                  node = nodesToBeRemoved[i];\n                  graph.remove(node);\n                }\n                if (graph == this.rootGraph) {\n                  this.setRootGraph(null);\n                }\n                var index = this.graphs.indexOf(graph);\n                this.graphs.splice(index, 1);\n                graph.parent = null;\n              } else if (lObj instanceof LEdge) {\n                edge = lObj;\n                if (edge == null) {\n                  throw \"Edge is null!\";\n                }\n                if (!edge.isInterGraph) {\n                  throw \"Not an inter-graph edge!\";\n                }\n                if (!(edge.source != null && edge.target != null)) {\n                  throw \"Source and/or target is null!\";\n                }\n                if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n                  throw \"Source and/or target doesn't know this edge!\";\n                }\n                var index = edge.source.edges.indexOf(edge);\n                edge.source.edges.splice(index, 1);\n                index = edge.target.edges.indexOf(edge);\n                edge.target.edges.splice(index, 1);\n                if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n                  throw \"Edge owner graph or owner graph manager is null!\";\n                }\n                if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n                  throw \"Not in owner graph manager's edge list!\";\n                }\n                var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n                edge.source.owner.getGraphManager().edges.splice(index, 1);\n              }\n            };\n            LGraphManager.prototype.updateBounds = function() {\n              this.rootGraph.updateBounds(true);\n            };\n            LGraphManager.prototype.getGraphs = function() {\n              return this.graphs;\n            };\n            LGraphManager.prototype.getAllNodes = function() {\n              if (this.allNodes == null) {\n                var nodeList = [];\n                var graphs = this.getGraphs();\n                var s = graphs.length;\n                for (var i = 0; i < s; i++) {\n                  nodeList = nodeList.concat(graphs[i].getNodes());\n                }\n                this.allNodes = nodeList;\n              }\n              return this.allNodes;\n            };\n            LGraphManager.prototype.resetAllNodes = function() {\n              this.allNodes = null;\n            };\n            LGraphManager.prototype.resetAllEdges = function() {\n              this.allEdges = null;\n            };\n            LGraphManager.prototype.resetAllNodesToApplyGravitation = function() {\n              this.allNodesToApplyGravitation = null;\n            };\n            LGraphManager.prototype.getAllEdges = function() {\n              if (this.allEdges == null) {\n                var edgeList = [];\n                var graphs = this.getGraphs();\n                var s = graphs.length;\n                for (var i = 0; i < graphs.length; i++) {\n                  edgeList = edgeList.concat(graphs[i].getEdges());\n                }\n                edgeList = edgeList.concat(this.edges);\n                this.allEdges = edgeList;\n              }\n              return this.allEdges;\n            };\n            LGraphManager.prototype.getAllNodesToApplyGravitation = function() {\n              return this.allNodesToApplyGravitation;\n            };\n            LGraphManager.prototype.setAllNodesToApplyGravitation = function(nodeList) {\n              if (this.allNodesToApplyGravitation != null) {\n                throw \"assert failed\";\n              }\n              this.allNodesToApplyGravitation = nodeList;\n            };\n            LGraphManager.prototype.getRoot = function() {\n              return this.rootGraph;\n            };\n            LGraphManager.prototype.setRootGraph = function(graph) {\n              if (graph.getGraphManager() != this) {\n                throw \"Root not in this graph mgr!\";\n              }\n              this.rootGraph = graph;\n              if (graph.parent == null) {\n                graph.parent = this.layout.newNode(\"Root node\");\n              }\n            };\n            LGraphManager.prototype.getLayout = function() {\n              return this.layout;\n            };\n            LGraphManager.prototype.isOneAncestorOfOther = function(firstNode, secondNode) {\n              if (!(firstNode != null && secondNode != null)) {\n                throw \"assert failed\";\n              }\n              if (firstNode == secondNode) {\n                return true;\n              }\n              var ownerGraph = firstNode.getOwner();\n              var parentNode;\n              do {\n                parentNode = ownerGraph.getParent();\n                if (parentNode == null) {\n                  break;\n                }\n                if (parentNode == secondNode) {\n                  return true;\n                }\n                ownerGraph = parentNode.getOwner();\n                if (ownerGraph == null) {\n                  break;\n                }\n              } while (true);\n              ownerGraph = secondNode.getOwner();\n              do {\n                parentNode = ownerGraph.getParent();\n                if (parentNode == null) {\n                  break;\n                }\n                if (parentNode == firstNode) {\n                  return true;\n                }\n                ownerGraph = parentNode.getOwner();\n                if (ownerGraph == null) {\n                  break;\n                }\n              } while (true);\n              return false;\n            };\n            LGraphManager.prototype.calcLowestCommonAncestors = function() {\n              var edge;\n              var sourceNode;\n              var targetNode;\n              var sourceAncestorGraph;\n              var targetAncestorGraph;\n              var edges = this.getAllEdges();\n              var s = edges.length;\n              for (var i = 0; i < s; i++) {\n                edge = edges[i];\n                sourceNode = edge.source;\n                targetNode = edge.target;\n                edge.lca = null;\n                edge.sourceInLca = sourceNode;\n                edge.targetInLca = targetNode;\n                if (sourceNode == targetNode) {\n                  edge.lca = sourceNode.getOwner();\n                  continue;\n                }\n                sourceAncestorGraph = sourceNode.getOwner();\n                while (edge.lca == null) {\n                  edge.targetInLca = targetNode;\n                  targetAncestorGraph = targetNode.getOwner();\n                  while (edge.lca == null) {\n                    if (targetAncestorGraph == sourceAncestorGraph) {\n                      edge.lca = targetAncestorGraph;\n                      break;\n                    }\n                    if (targetAncestorGraph == this.rootGraph) {\n                      break;\n                    }\n                    if (edge.lca != null) {\n                      throw \"assert failed\";\n                    }\n                    edge.targetInLca = targetAncestorGraph.getParent();\n                    targetAncestorGraph = edge.targetInLca.getOwner();\n                  }\n                  if (sourceAncestorGraph == this.rootGraph) {\n                    break;\n                  }\n                  if (edge.lca == null) {\n                    edge.sourceInLca = sourceAncestorGraph.getParent();\n                    sourceAncestorGraph = edge.sourceInLca.getOwner();\n                  }\n                }\n                if (edge.lca == null) {\n                  throw \"assert failed\";\n                }\n              }\n            };\n            LGraphManager.prototype.calcLowestCommonAncestor = function(firstNode, secondNode) {\n              if (firstNode == secondNode) {\n                return firstNode.getOwner();\n              }\n              var firstOwnerGraph = firstNode.getOwner();\n              do {\n                if (firstOwnerGraph == null) {\n                  break;\n                }\n                var secondOwnerGraph = secondNode.getOwner();\n                do {\n                  if (secondOwnerGraph == null) {\n                    break;\n                  }\n                  if (secondOwnerGraph == firstOwnerGraph) {\n                    return secondOwnerGraph;\n                  }\n                  secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n                } while (true);\n                firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n              } while (true);\n              return firstOwnerGraph;\n            };\n            LGraphManager.prototype.calcInclusionTreeDepths = function(graph, depth) {\n              if (graph == null && depth == null) {\n                graph = this.rootGraph;\n                depth = 1;\n              }\n              var node;\n              var nodes = graph.getNodes();\n              var s = nodes.length;\n              for (var i = 0; i < s; i++) {\n                node = nodes[i];\n                node.inclusionTreeDepth = depth;\n                if (node.child != null) {\n                  this.calcInclusionTreeDepths(node.child, depth + 1);\n                }\n              }\n            };\n            LGraphManager.prototype.includesInvalidEdge = function() {\n              var edge;\n              var edgesToRemove = [];\n              var s = this.edges.length;\n              for (var i = 0; i < s; i++) {\n                edge = this.edges[i];\n                if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n                  edgesToRemove.push(edge);\n                }\n              }\n              for (var i = 0; i < edgesToRemove.length; i++) {\n                this.remove(edgesToRemove[i]);\n              }\n              return false;\n            };\n            module2.exports = LGraphManager;\n          },\n          /* 8 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var Point2 = __webpack_require__(12);\n            function IGeometry() {\n            }\n            __name(IGeometry, \"IGeometry\");\n            IGeometry.calcSeparationAmount = function(rectA, rectB, overlapAmount, separationBuffer) {\n              if (!rectA.intersects(rectB)) {\n                throw \"assert failed\";\n              }\n              var directions = new Array(2);\n              this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n              overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n              overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n              if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n                overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n              } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n                overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n              }\n              if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n                overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n              } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n                overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n              }\n              var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n              if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n                slope = 1;\n              }\n              var moveByY = slope * overlapAmount[0];\n              var moveByX = overlapAmount[1] / slope;\n              if (overlapAmount[0] < moveByX) {\n                moveByX = overlapAmount[0];\n              } else {\n                moveByY = overlapAmount[1];\n              }\n              overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n              overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n            };\n            IGeometry.decideDirectionsForOverlappingNodes = function(rectA, rectB, directions) {\n              if (rectA.getCenterX() < rectB.getCenterX()) {\n                directions[0] = -1;\n              } else {\n                directions[0] = 1;\n              }\n              if (rectA.getCenterY() < rectB.getCenterY()) {\n                directions[1] = -1;\n              } else {\n                directions[1] = 1;\n              }\n            };\n            IGeometry.getIntersection2 = function(rectA, rectB, result) {\n              var p1x = rectA.getCenterX();\n              var p1y = rectA.getCenterY();\n              var p2x = rectB.getCenterX();\n              var p2y = rectB.getCenterY();\n              if (rectA.intersects(rectB)) {\n                result[0] = p1x;\n                result[1] = p1y;\n                result[2] = p2x;\n                result[3] = p2y;\n                return true;\n              }\n              var topLeftAx = rectA.getX();\n              var topLeftAy = rectA.getY();\n              var topRightAx = rectA.getRight();\n              var bottomLeftAx = rectA.getX();\n              var bottomLeftAy = rectA.getBottom();\n              var bottomRightAx = rectA.getRight();\n              var halfWidthA = rectA.getWidthHalf();\n              var halfHeightA = rectA.getHeightHalf();\n              var topLeftBx = rectB.getX();\n              var topLeftBy = rectB.getY();\n              var topRightBx = rectB.getRight();\n              var bottomLeftBx = rectB.getX();\n              var bottomLeftBy = rectB.getBottom();\n              var bottomRightBx = rectB.getRight();\n              var halfWidthB = rectB.getWidthHalf();\n              var halfHeightB = rectB.getHeightHalf();\n              var clipPointAFound = false;\n              var clipPointBFound = false;\n              if (p1x === p2x) {\n                if (p1y > p2y) {\n                  result[0] = p1x;\n                  result[1] = topLeftAy;\n                  result[2] = p2x;\n                  result[3] = bottomLeftBy;\n                  return false;\n                } else if (p1y < p2y) {\n                  result[0] = p1x;\n                  result[1] = bottomLeftAy;\n                  result[2] = p2x;\n                  result[3] = topLeftBy;\n                  return false;\n                } else {\n                }\n              } else if (p1y === p2y) {\n                if (p1x > p2x) {\n                  result[0] = topLeftAx;\n                  result[1] = p1y;\n                  result[2] = topRightBx;\n                  result[3] = p2y;\n                  return false;\n                } else if (p1x < p2x) {\n                  result[0] = topRightAx;\n                  result[1] = p1y;\n                  result[2] = topLeftBx;\n                  result[3] = p2y;\n                  return false;\n                } else {\n                }\n              } else {\n                var slopeA = rectA.height / rectA.width;\n                var slopeB = rectB.height / rectB.width;\n                var slopePrime = (p2y - p1y) / (p2x - p1x);\n                var cardinalDirectionA = void 0;\n                var cardinalDirectionB = void 0;\n                var tempPointAx = void 0;\n                var tempPointAy = void 0;\n                var tempPointBx = void 0;\n                var tempPointBy = void 0;\n                if (-slopeA === slopePrime) {\n                  if (p1x > p2x) {\n                    result[0] = bottomLeftAx;\n                    result[1] = bottomLeftAy;\n                    clipPointAFound = true;\n                  } else {\n                    result[0] = topRightAx;\n                    result[1] = topLeftAy;\n                    clipPointAFound = true;\n                  }\n                } else if (slopeA === slopePrime) {\n                  if (p1x > p2x) {\n                    result[0] = topLeftAx;\n                    result[1] = topLeftAy;\n                    clipPointAFound = true;\n                  } else {\n                    result[0] = bottomRightAx;\n                    result[1] = bottomLeftAy;\n                    clipPointAFound = true;\n                  }\n                }\n                if (-slopeB === slopePrime) {\n                  if (p2x > p1x) {\n                    result[2] = bottomLeftBx;\n                    result[3] = bottomLeftBy;\n                    clipPointBFound = true;\n                  } else {\n                    result[2] = topRightBx;\n                    result[3] = topLeftBy;\n                    clipPointBFound = true;\n                  }\n                } else if (slopeB === slopePrime) {\n                  if (p2x > p1x) {\n                    result[2] = topLeftBx;\n                    result[3] = topLeftBy;\n                    clipPointBFound = true;\n                  } else {\n                    result[2] = bottomRightBx;\n                    result[3] = bottomLeftBy;\n                    clipPointBFound = true;\n                  }\n                }\n                if (clipPointAFound && clipPointBFound) {\n                  return false;\n                }\n                if (p1x > p2x) {\n                  if (p1y > p2y) {\n                    cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n                    cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n                  } else {\n                    cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n                    cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n                  }\n                } else {\n                  if (p1y > p2y) {\n                    cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n                    cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n                  } else {\n                    cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n                    cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n                  }\n                }\n                if (!clipPointAFound) {\n                  switch (cardinalDirectionA) {\n                    case 1:\n                      tempPointAy = topLeftAy;\n                      tempPointAx = p1x + -halfHeightA / slopePrime;\n                      result[0] = tempPointAx;\n                      result[1] = tempPointAy;\n                      break;\n                    case 2:\n                      tempPointAx = bottomRightAx;\n                      tempPointAy = p1y + halfWidthA * slopePrime;\n                      result[0] = tempPointAx;\n                      result[1] = tempPointAy;\n                      break;\n                    case 3:\n                      tempPointAy = bottomLeftAy;\n                      tempPointAx = p1x + halfHeightA / slopePrime;\n                      result[0] = tempPointAx;\n                      result[1] = tempPointAy;\n                      break;\n                    case 4:\n                      tempPointAx = bottomLeftAx;\n                      tempPointAy = p1y + -halfWidthA * slopePrime;\n                      result[0] = tempPointAx;\n                      result[1] = tempPointAy;\n                      break;\n                  }\n                }\n                if (!clipPointBFound) {\n                  switch (cardinalDirectionB) {\n                    case 1:\n                      tempPointBy = topLeftBy;\n                      tempPointBx = p2x + -halfHeightB / slopePrime;\n                      result[2] = tempPointBx;\n                      result[3] = tempPointBy;\n                      break;\n                    case 2:\n                      tempPointBx = bottomRightBx;\n                      tempPointBy = p2y + halfWidthB * slopePrime;\n                      result[2] = tempPointBx;\n                      result[3] = tempPointBy;\n                      break;\n                    case 3:\n                      tempPointBy = bottomLeftBy;\n                      tempPointBx = p2x + halfHeightB / slopePrime;\n                      result[2] = tempPointBx;\n                      result[3] = tempPointBy;\n                      break;\n                    case 4:\n                      tempPointBx = bottomLeftBx;\n                      tempPointBy = p2y + -halfWidthB * slopePrime;\n                      result[2] = tempPointBx;\n                      result[3] = tempPointBy;\n                      break;\n                  }\n                }\n              }\n              return false;\n            };\n            IGeometry.getCardinalDirection = function(slope, slopePrime, line) {\n              if (slope > slopePrime) {\n                return line;\n              } else {\n                return 1 + line % 4;\n              }\n            };\n            IGeometry.getIntersection = function(s1, s2, f1, f2) {\n              if (f2 == null) {\n                return this.getIntersection2(s1, s2, f1);\n              }\n              var x1 = s1.x;\n              var y1 = s1.y;\n              var x2 = s2.x;\n              var y2 = s2.y;\n              var x3 = f1.x;\n              var y3 = f1.y;\n              var x4 = f2.x;\n              var y4 = f2.y;\n              var x = void 0, y = void 0;\n              var a1 = void 0, a2 = void 0, b1 = void 0, b2 = void 0, c1 = void 0, c2 = void 0;\n              var denom = void 0;\n              a1 = y2 - y1;\n              b1 = x1 - x2;\n              c1 = x2 * y1 - x1 * y2;\n              a2 = y4 - y3;\n              b2 = x3 - x4;\n              c2 = x4 * y3 - x3 * y4;\n              denom = a1 * b2 - a2 * b1;\n              if (denom === 0) {\n                return null;\n              }\n              x = (b1 * c2 - b2 * c1) / denom;\n              y = (a2 * c1 - a1 * c2) / denom;\n              return new Point2(x, y);\n            };\n            IGeometry.angleOfVector = function(Cx, Cy, Nx, Ny) {\n              var C_angle = void 0;\n              if (Cx !== Nx) {\n                C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n                if (Nx < Cx) {\n                  C_angle += Math.PI;\n                } else if (Ny < Cy) {\n                  C_angle += this.TWO_PI;\n                }\n              } else if (Ny < Cy) {\n                C_angle = this.ONE_AND_HALF_PI;\n              } else {\n                C_angle = this.HALF_PI;\n              }\n              return C_angle;\n            };\n            IGeometry.doIntersect = function(p1, p2, p3, p4) {\n              var a = p1.x;\n              var b = p1.y;\n              var c = p2.x;\n              var d = p2.y;\n              var p = p3.x;\n              var q = p3.y;\n              var r = p4.x;\n              var s = p4.y;\n              var det = (c - a) * (s - q) - (r - p) * (d - b);\n              if (det === 0) {\n                return false;\n              } else {\n                var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n                var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n                return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n              }\n            };\n            IGeometry.findCircleLineIntersections = function(Ex, Ey, Lx, Ly, Cx, Cy, r) {\n              var a = (Lx - Ex) * (Lx - Ex) + (Ly - Ey) * (Ly - Ey);\n              var b = 2 * ((Ex - Cx) * (Lx - Ex) + (Ey - Cy) * (Ly - Ey));\n              var c = (Ex - Cx) * (Ex - Cx) + (Ey - Cy) * (Ey - Cy) - r * r;\n              var disc = b * b - 4 * a * c;\n              if (disc >= 0) {\n                var t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n                var t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n                var intersections = null;\n                if (t1 >= 0 && t1 <= 1) {\n                  return [t1];\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                  return [t2];\n                }\n                return intersections;\n              } else return null;\n            };\n            IGeometry.HALF_PI = 0.5 * Math.PI;\n            IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\n            IGeometry.TWO_PI = 2 * Math.PI;\n            IGeometry.THREE_PI = 3 * Math.PI;\n            module2.exports = IGeometry;\n          },\n          /* 9 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function IMath() {\n            }\n            __name(IMath, \"IMath\");\n            IMath.sign = function(value) {\n              if (value > 0) {\n                return 1;\n              } else if (value < 0) {\n                return -1;\n              } else {\n                return 0;\n              }\n            };\n            IMath.floor = function(value) {\n              return value < 0 ? Math.ceil(value) : Math.floor(value);\n            };\n            IMath.ceil = function(value) {\n              return value < 0 ? Math.floor(value) : Math.ceil(value);\n            };\n            module2.exports = IMath;\n          },\n          /* 10 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function Integer() {\n            }\n            __name(Integer, \"Integer\");\n            Integer.MAX_VALUE = 2147483647;\n            Integer.MIN_VALUE = -2147483648;\n            module2.exports = Integer;\n          },\n          /* 11 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var _createClass = /* @__PURE__ */ function() {\n              function defineProperties(target, props) {\n                for (var i = 0; i < props.length; i++) {\n                  var descriptor = props[i];\n                  descriptor.enumerable = descriptor.enumerable || false;\n                  descriptor.configurable = true;\n                  if (\"value\" in descriptor) descriptor.writable = true;\n                  Object.defineProperty(target, descriptor.key, descriptor);\n                }\n              }\n              __name(defineProperties, \"defineProperties\");\n              return function(Constructor, protoProps, staticProps) {\n                if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) defineProperties(Constructor, staticProps);\n                return Constructor;\n              };\n            }();\n            function _classCallCheck(instance2, Constructor) {\n              if (!(instance2 instanceof Constructor)) {\n                throw new TypeError(\"Cannot call a class as a function\");\n              }\n            }\n            __name(_classCallCheck, \"_classCallCheck\");\n            var nodeFrom = /* @__PURE__ */ __name(function nodeFrom2(value) {\n              return { value, next: null, prev: null };\n            }, \"nodeFrom\");\n            var add = /* @__PURE__ */ __name(function add2(prev, node, next2, list) {\n              if (prev !== null) {\n                prev.next = node;\n              } else {\n                list.head = node;\n              }\n              if (next2 !== null) {\n                next2.prev = node;\n              } else {\n                list.tail = node;\n              }\n              node.prev = prev;\n              node.next = next2;\n              list.length++;\n              return node;\n            }, \"add\");\n            var _remove = /* @__PURE__ */ __name(function _remove2(node, list) {\n              var prev = node.prev, next2 = node.next;\n              if (prev !== null) {\n                prev.next = next2;\n              } else {\n                list.head = next2;\n              }\n              if (next2 !== null) {\n                next2.prev = prev;\n              } else {\n                list.tail = prev;\n              }\n              node.prev = node.next = null;\n              list.length--;\n              return node;\n            }, \"_remove\");\n            var LinkedList = function() {\n              function LinkedList2(vals) {\n                var _this = this;\n                _classCallCheck(this, LinkedList2);\n                this.length = 0;\n                this.head = null;\n                this.tail = null;\n                if (vals != null) {\n                  vals.forEach(function(v) {\n                    return _this.push(v);\n                  });\n                }\n              }\n              __name(LinkedList2, \"LinkedList\");\n              _createClass(LinkedList2, [{\n                key: \"size\",\n                value: /* @__PURE__ */ __name(function size() {\n                  return this.length;\n                }, \"size\")\n              }, {\n                key: \"insertBefore\",\n                value: /* @__PURE__ */ __name(function insertBefore(val, otherNode) {\n                  return add(otherNode.prev, nodeFrom(val), otherNode, this);\n                }, \"insertBefore\")\n              }, {\n                key: \"insertAfter\",\n                value: /* @__PURE__ */ __name(function insertAfter(val, otherNode) {\n                  return add(otherNode, nodeFrom(val), otherNode.next, this);\n                }, \"insertAfter\")\n              }, {\n                key: \"insertNodeBefore\",\n                value: /* @__PURE__ */ __name(function insertNodeBefore(newNode, otherNode) {\n                  return add(otherNode.prev, newNode, otherNode, this);\n                }, \"insertNodeBefore\")\n              }, {\n                key: \"insertNodeAfter\",\n                value: /* @__PURE__ */ __name(function insertNodeAfter(newNode, otherNode) {\n                  return add(otherNode, newNode, otherNode.next, this);\n                }, \"insertNodeAfter\")\n              }, {\n                key: \"push\",\n                value: /* @__PURE__ */ __name(function push(val) {\n                  return add(this.tail, nodeFrom(val), null, this);\n                }, \"push\")\n              }, {\n                key: \"unshift\",\n                value: /* @__PURE__ */ __name(function unshift(val) {\n                  return add(null, nodeFrom(val), this.head, this);\n                }, \"unshift\")\n              }, {\n                key: \"remove\",\n                value: /* @__PURE__ */ __name(function remove(node) {\n                  return _remove(node, this);\n                }, \"remove\")\n              }, {\n                key: \"pop\",\n                value: /* @__PURE__ */ __name(function pop() {\n                  return _remove(this.tail, this).value;\n                }, \"pop\")\n              }, {\n                key: \"popNode\",\n                value: /* @__PURE__ */ __name(function popNode() {\n                  return _remove(this.tail, this);\n                }, \"popNode\")\n              }, {\n                key: \"shift\",\n                value: /* @__PURE__ */ __name(function shift() {\n                  return _remove(this.head, this).value;\n                }, \"shift\")\n              }, {\n                key: \"shiftNode\",\n                value: /* @__PURE__ */ __name(function shiftNode() {\n                  return _remove(this.head, this);\n                }, \"shiftNode\")\n              }, {\n                key: \"get_object_at\",\n                value: /* @__PURE__ */ __name(function get_object_at(index) {\n                  if (index <= this.length()) {\n                    var i = 1;\n                    var current = this.head;\n                    while (i < index) {\n                      current = current.next;\n                      i++;\n                    }\n                    return current.value;\n                  }\n                }, \"get_object_at\")\n              }, {\n                key: \"set_object_at\",\n                value: /* @__PURE__ */ __name(function set_object_at(index, value) {\n                  if (index <= this.length()) {\n                    var i = 1;\n                    var current = this.head;\n                    while (i < index) {\n                      current = current.next;\n                      i++;\n                    }\n                    current.value = value;\n                  }\n                }, \"set_object_at\")\n              }]);\n              return LinkedList2;\n            }();\n            module2.exports = LinkedList;\n          },\n          /* 12 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function Point2(x, y, p) {\n              this.x = null;\n              this.y = null;\n              if (x == null && y == null && p == null) {\n                this.x = 0;\n                this.y = 0;\n              } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                this.x = x;\n                this.y = y;\n              } else if (x.constructor.name == \"Point\" && y == null && p == null) {\n                p = x;\n                this.x = p.x;\n                this.y = p.y;\n              }\n            }\n            __name(Point2, \"Point\");\n            Point2.prototype.getX = function() {\n              return this.x;\n            };\n            Point2.prototype.getY = function() {\n              return this.y;\n            };\n            Point2.prototype.getLocation = function() {\n              return new Point2(this.x, this.y);\n            };\n            Point2.prototype.setLocation = function(x, y, p) {\n              if (x.constructor.name == \"Point\" && y == null && p == null) {\n                p = x;\n                this.setLocation(p.x, p.y);\n              } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                if (parseInt(x) == x && parseInt(y) == y) {\n                  this.move(x, y);\n                } else {\n                  this.x = Math.floor(x + 0.5);\n                  this.y = Math.floor(y + 0.5);\n                }\n              }\n            };\n            Point2.prototype.move = function(x, y) {\n              this.x = x;\n              this.y = y;\n            };\n            Point2.prototype.translate = function(dx, dy) {\n              this.x += dx;\n              this.y += dy;\n            };\n            Point2.prototype.equals = function(obj) {\n              if (obj.constructor.name == \"Point\") {\n                var pt = obj;\n                return this.x == pt.x && this.y == pt.y;\n              }\n              return this == obj;\n            };\n            Point2.prototype.toString = function() {\n              return new Point2().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n            };\n            module2.exports = Point2;\n          },\n          /* 13 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function RectangleD(x, y, width, height) {\n              this.x = 0;\n              this.y = 0;\n              this.width = 0;\n              this.height = 0;\n              if (x != null && y != null && width != null && height != null) {\n                this.x = x;\n                this.y = y;\n                this.width = width;\n                this.height = height;\n              }\n            }\n            __name(RectangleD, \"RectangleD\");\n            RectangleD.prototype.getX = function() {\n              return this.x;\n            };\n            RectangleD.prototype.setX = function(x) {\n              this.x = x;\n            };\n            RectangleD.prototype.getY = function() {\n              return this.y;\n            };\n            RectangleD.prototype.setY = function(y) {\n              this.y = y;\n            };\n            RectangleD.prototype.getWidth = function() {\n              return this.width;\n            };\n            RectangleD.prototype.setWidth = function(width) {\n              this.width = width;\n            };\n            RectangleD.prototype.getHeight = function() {\n              return this.height;\n            };\n            RectangleD.prototype.setHeight = function(height) {\n              this.height = height;\n            };\n            RectangleD.prototype.getRight = function() {\n              return this.x + this.width;\n            };\n            RectangleD.prototype.getBottom = function() {\n              return this.y + this.height;\n            };\n            RectangleD.prototype.intersects = function(a) {\n              if (this.getRight() < a.x) {\n                return false;\n              }\n              if (this.getBottom() < a.y) {\n                return false;\n              }\n              if (a.getRight() < this.x) {\n                return false;\n              }\n              if (a.getBottom() < this.y) {\n                return false;\n              }\n              return true;\n            };\n            RectangleD.prototype.getCenterX = function() {\n              return this.x + this.width / 2;\n            };\n            RectangleD.prototype.getMinX = function() {\n              return this.getX();\n            };\n            RectangleD.prototype.getMaxX = function() {\n              return this.getX() + this.width;\n            };\n            RectangleD.prototype.getCenterY = function() {\n              return this.y + this.height / 2;\n            };\n            RectangleD.prototype.getMinY = function() {\n              return this.getY();\n            };\n            RectangleD.prototype.getMaxY = function() {\n              return this.getY() + this.height;\n            };\n            RectangleD.prototype.getWidthHalf = function() {\n              return this.width / 2;\n            };\n            RectangleD.prototype.getHeightHalf = function() {\n              return this.height / 2;\n            };\n            module2.exports = RectangleD;\n          },\n          /* 14 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n              return typeof obj;\n            } : function(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            function UniqueIDGeneretor() {\n            }\n            __name(UniqueIDGeneretor, \"UniqueIDGeneretor\");\n            UniqueIDGeneretor.lastID = 0;\n            UniqueIDGeneretor.createID = function(obj) {\n              if (UniqueIDGeneretor.isPrimitive(obj)) {\n                return obj;\n              }\n              if (obj.uniqueID != null) {\n                return obj.uniqueID;\n              }\n              obj.uniqueID = UniqueIDGeneretor.getString();\n              UniqueIDGeneretor.lastID++;\n              return obj.uniqueID;\n            };\n            UniqueIDGeneretor.getString = function(id) {\n              if (id == null) id = UniqueIDGeneretor.lastID;\n              return \"Object#\" + id;\n            };\n            UniqueIDGeneretor.isPrimitive = function(arg) {\n              var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n              return arg == null || type != \"object\" && type != \"function\";\n            };\n            module2.exports = UniqueIDGeneretor;\n          },\n          /* 15 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n              if (Array.isArray(arr)) {\n                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n                  arr2[i] = arr[i];\n                }\n                return arr2;\n              } else {\n                return Array.from(arr);\n              }\n            }\n            __name(_toConsumableArray, \"_toConsumableArray\");\n            var LayoutConstants = __webpack_require__(0);\n            var LGraphManager = __webpack_require__(7);\n            var LNode = __webpack_require__(3);\n            var LEdge = __webpack_require__(1);\n            var LGraph = __webpack_require__(6);\n            var PointD = __webpack_require__(5);\n            var Transform = __webpack_require__(17);\n            var Emitter = __webpack_require__(29);\n            function Layout2(isRemoteUse) {\n              Emitter.call(this);\n              this.layoutQuality = LayoutConstants.QUALITY;\n              this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n              this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n              this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n              this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n              this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n              this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n              this.edgeToDummyNodes = /* @__PURE__ */ new Map();\n              this.graphManager = new LGraphManager(this);\n              this.isLayoutFinished = false;\n              this.isSubLayout = false;\n              this.isRemoteUse = false;\n              if (isRemoteUse != null) {\n                this.isRemoteUse = isRemoteUse;\n              }\n            }\n            __name(Layout2, \"Layout\");\n            Layout2.RANDOM_SEED = 1;\n            Layout2.prototype = Object.create(Emitter.prototype);\n            Layout2.prototype.getGraphManager = function() {\n              return this.graphManager;\n            };\n            Layout2.prototype.getAllNodes = function() {\n              return this.graphManager.getAllNodes();\n            };\n            Layout2.prototype.getAllEdges = function() {\n              return this.graphManager.getAllEdges();\n            };\n            Layout2.prototype.getAllNodesToApplyGravitation = function() {\n              return this.graphManager.getAllNodesToApplyGravitation();\n            };\n            Layout2.prototype.newGraphManager = function() {\n              var gm = new LGraphManager(this);\n              this.graphManager = gm;\n              return gm;\n            };\n            Layout2.prototype.newGraph = function(vGraph) {\n              return new LGraph(null, this.graphManager, vGraph);\n            };\n            Layout2.prototype.newNode = function(vNode) {\n              return new LNode(this.graphManager, vNode);\n            };\n            Layout2.prototype.newEdge = function(vEdge) {\n              return new LEdge(null, null, vEdge);\n            };\n            Layout2.prototype.checkLayoutSuccess = function() {\n              return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n            };\n            Layout2.prototype.runLayout = function() {\n              this.isLayoutFinished = false;\n              if (this.tilingPreLayout) {\n                this.tilingPreLayout();\n              }\n              this.initParameters();\n              var isLayoutSuccessfull;\n              if (this.checkLayoutSuccess()) {\n                isLayoutSuccessfull = false;\n              } else {\n                isLayoutSuccessfull = this.layout();\n              }\n              if (LayoutConstants.ANIMATE === \"during\") {\n                return false;\n              }\n              if (isLayoutSuccessfull) {\n                if (!this.isSubLayout) {\n                  this.doPostLayout();\n                }\n              }\n              if (this.tilingPostLayout) {\n                this.tilingPostLayout();\n              }\n              this.isLayoutFinished = true;\n              return isLayoutSuccessfull;\n            };\n            Layout2.prototype.doPostLayout = function() {\n              if (!this.incremental) {\n                this.transform();\n              }\n              this.update();\n            };\n            Layout2.prototype.update2 = function() {\n              if (this.createBendsAsNeeded) {\n                this.createBendpointsFromDummyNodes();\n                this.graphManager.resetAllEdges();\n              }\n              if (!this.isRemoteUse) {\n                var edge;\n                var allEdges = this.graphManager.getAllEdges();\n                for (var i = 0; i < allEdges.length; i++) {\n                  edge = allEdges[i];\n                }\n                var node;\n                var nodes = this.graphManager.getRoot().getNodes();\n                for (var i = 0; i < nodes.length; i++) {\n                  node = nodes[i];\n                }\n                this.update(this.graphManager.getRoot());\n              }\n            };\n            Layout2.prototype.update = function(obj) {\n              if (obj == null) {\n                this.update2();\n              } else if (obj instanceof LNode) {\n                var node = obj;\n                if (node.getChild() != null) {\n                  var nodes = node.getChild().getNodes();\n                  for (var i = 0; i < nodes.length; i++) {\n                    update(nodes[i]);\n                  }\n                }\n                if (node.vGraphObject != null) {\n                  var vNode = node.vGraphObject;\n                  vNode.update(node);\n                }\n              } else if (obj instanceof LEdge) {\n                var edge = obj;\n                if (edge.vGraphObject != null) {\n                  var vEdge = edge.vGraphObject;\n                  vEdge.update(edge);\n                }\n              } else if (obj instanceof LGraph) {\n                var graph = obj;\n                if (graph.vGraphObject != null) {\n                  var vGraph = graph.vGraphObject;\n                  vGraph.update(graph);\n                }\n              }\n            };\n            Layout2.prototype.initParameters = function() {\n              if (!this.isSubLayout) {\n                this.layoutQuality = LayoutConstants.QUALITY;\n                this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n                this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n                this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n                this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n                this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n              }\n              if (this.animationDuringLayout) {\n                this.animationOnLayout = false;\n              }\n            };\n            Layout2.prototype.transform = function(newLeftTop) {\n              if (newLeftTop == void 0) {\n                this.transform(new PointD(0, 0));\n              } else {\n                var trans = new Transform();\n                var leftTop = this.graphManager.getRoot().updateLeftTop();\n                if (leftTop != null) {\n                  trans.setWorldOrgX(newLeftTop.x);\n                  trans.setWorldOrgY(newLeftTop.y);\n                  trans.setDeviceOrgX(leftTop.x);\n                  trans.setDeviceOrgY(leftTop.y);\n                  var nodes = this.getAllNodes();\n                  var node;\n                  for (var i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    node.transform(trans);\n                  }\n                }\n              }\n            };\n            Layout2.prototype.positionNodesRandomly = function(graph) {\n              if (graph == void 0) {\n                this.positionNodesRandomly(this.getGraphManager().getRoot());\n                this.getGraphManager().getRoot().updateBounds(true);\n              } else {\n                var lNode;\n                var childGraph;\n                var nodes = graph.getNodes();\n                for (var i = 0; i < nodes.length; i++) {\n                  lNode = nodes[i];\n                  childGraph = lNode.getChild();\n                  if (childGraph == null) {\n                    lNode.scatter();\n                  } else if (childGraph.getNodes().length == 0) {\n                    lNode.scatter();\n                  } else {\n                    this.positionNodesRandomly(childGraph);\n                    lNode.updateBounds();\n                  }\n                }\n              }\n            };\n            Layout2.prototype.getFlatForest = function() {\n              var flatForest = [];\n              var isForest = true;\n              var allNodes = this.graphManager.getRoot().getNodes();\n              var isFlat = true;\n              for (var i = 0; i < allNodes.length; i++) {\n                if (allNodes[i].getChild() != null) {\n                  isFlat = false;\n                }\n              }\n              if (!isFlat) {\n                return flatForest;\n              }\n              var visited = /* @__PURE__ */ new Set();\n              var toBeVisited = [];\n              var parents = /* @__PURE__ */ new Map();\n              var unProcessedNodes = [];\n              unProcessedNodes = unProcessedNodes.concat(allNodes);\n              while (unProcessedNodes.length > 0 && isForest) {\n                toBeVisited.push(unProcessedNodes[0]);\n                while (toBeVisited.length > 0 && isForest) {\n                  var currentNode = toBeVisited[0];\n                  toBeVisited.splice(0, 1);\n                  visited.add(currentNode);\n                  var neighborEdges = currentNode.getEdges();\n                  for (var i = 0; i < neighborEdges.length; i++) {\n                    var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n                    if (parents.get(currentNode) != currentNeighbor) {\n                      if (!visited.has(currentNeighbor)) {\n                        toBeVisited.push(currentNeighbor);\n                        parents.set(currentNeighbor, currentNode);\n                      } else {\n                        isForest = false;\n                        break;\n                      }\n                    }\n                  }\n                }\n                if (!isForest) {\n                  flatForest = [];\n                } else {\n                  var temp = [].concat(_toConsumableArray(visited));\n                  flatForest.push(temp);\n                  for (var i = 0; i < temp.length; i++) {\n                    var value = temp[i];\n                    var index = unProcessedNodes.indexOf(value);\n                    if (index > -1) {\n                      unProcessedNodes.splice(index, 1);\n                    }\n                  }\n                  visited = /* @__PURE__ */ new Set();\n                  parents = /* @__PURE__ */ new Map();\n                }\n              }\n              return flatForest;\n            };\n            Layout2.prototype.createDummyNodesForBendpoints = function(edge) {\n              var dummyNodes = [];\n              var prev = edge.source;\n              var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n              for (var i = 0; i < edge.bendpoints.length; i++) {\n                var dummyNode = this.newNode(null);\n                dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n                graph.add(dummyNode);\n                var dummyEdge = this.newEdge(null);\n                this.graphManager.add(dummyEdge, prev, dummyNode);\n                dummyNodes.add(dummyNode);\n                prev = dummyNode;\n              }\n              var dummyEdge = this.newEdge(null);\n              this.graphManager.add(dummyEdge, prev, edge.target);\n              this.edgeToDummyNodes.set(edge, dummyNodes);\n              if (edge.isInterGraph()) {\n                this.graphManager.remove(edge);\n              } else {\n                graph.remove(edge);\n              }\n              return dummyNodes;\n            };\n            Layout2.prototype.createBendpointsFromDummyNodes = function() {\n              var edges = [];\n              edges = edges.concat(this.graphManager.getAllEdges());\n              edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n              for (var k = 0; k < edges.length; k++) {\n                var lEdge = edges[k];\n                if (lEdge.bendpoints.length > 0) {\n                  var path = this.edgeToDummyNodes.get(lEdge);\n                  for (var i = 0; i < path.length; i++) {\n                    var dummyNode = path[i];\n                    var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n                    var ebp = lEdge.bendpoints.get(i);\n                    ebp.x = p.x;\n                    ebp.y = p.y;\n                    dummyNode.getOwner().remove(dummyNode);\n                  }\n                  this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n                }\n              }\n            };\n            Layout2.transform = function(sliderValue, defaultValue, minDiv, maxMul) {\n              if (minDiv != void 0 && maxMul != void 0) {\n                var value = defaultValue;\n                if (sliderValue <= 50) {\n                  var minValue = defaultValue / minDiv;\n                  value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n                } else {\n                  var maxValue = defaultValue * maxMul;\n                  value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n                }\n                return value;\n              } else {\n                var a, b;\n                if (sliderValue <= 50) {\n                  a = 9 * defaultValue / 500;\n                  b = defaultValue / 10;\n                } else {\n                  a = 9 * defaultValue / 50;\n                  b = -8 * defaultValue;\n                }\n                return a * sliderValue + b;\n              }\n            };\n            Layout2.findCenterOfTree = function(nodes) {\n              var list = [];\n              list = list.concat(nodes);\n              var removedNodes = [];\n              var remainingDegrees = /* @__PURE__ */ new Map();\n              var foundCenter = false;\n              var centerNode = null;\n              if (list.length == 1 || list.length == 2) {\n                foundCenter = true;\n                centerNode = list[0];\n              }\n              for (var i = 0; i < list.length; i++) {\n                var node = list[i];\n                var degree = node.getNeighborsList().size;\n                remainingDegrees.set(node, node.getNeighborsList().size);\n                if (degree == 1) {\n                  removedNodes.push(node);\n                }\n              }\n              var tempList = [];\n              tempList = tempList.concat(removedNodes);\n              while (!foundCenter) {\n                var tempList2 = [];\n                tempList2 = tempList2.concat(tempList);\n                tempList = [];\n                for (var i = 0; i < list.length; i++) {\n                  var node = list[i];\n                  var index = list.indexOf(node);\n                  if (index >= 0) {\n                    list.splice(index, 1);\n                  }\n                  var neighbours = node.getNeighborsList();\n                  neighbours.forEach(function(neighbour) {\n                    if (removedNodes.indexOf(neighbour) < 0) {\n                      var otherDegree = remainingDegrees.get(neighbour);\n                      var newDegree = otherDegree - 1;\n                      if (newDegree == 1) {\n                        tempList.push(neighbour);\n                      }\n                      remainingDegrees.set(neighbour, newDegree);\n                    }\n                  });\n                }\n                removedNodes = removedNodes.concat(tempList);\n                if (list.length == 1 || list.length == 2) {\n                  foundCenter = true;\n                  centerNode = list[0];\n                }\n              }\n              return centerNode;\n            };\n            Layout2.prototype.setGraphManager = function(gm) {\n              this.graphManager = gm;\n            };\n            module2.exports = Layout2;\n          },\n          /* 16 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function RandomSeed() {\n            }\n            __name(RandomSeed, \"RandomSeed\");\n            RandomSeed.seed = 1;\n            RandomSeed.x = 0;\n            RandomSeed.nextDouble = function() {\n              RandomSeed.x = Math.sin(RandomSeed.seed++) * 1e4;\n              return RandomSeed.x - Math.floor(RandomSeed.x);\n            };\n            module2.exports = RandomSeed;\n          },\n          /* 17 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var PointD = __webpack_require__(5);\n            function Transform(x, y) {\n              this.lworldOrgX = 0;\n              this.lworldOrgY = 0;\n              this.ldeviceOrgX = 0;\n              this.ldeviceOrgY = 0;\n              this.lworldExtX = 1;\n              this.lworldExtY = 1;\n              this.ldeviceExtX = 1;\n              this.ldeviceExtY = 1;\n            }\n            __name(Transform, \"Transform\");\n            Transform.prototype.getWorldOrgX = function() {\n              return this.lworldOrgX;\n            };\n            Transform.prototype.setWorldOrgX = function(wox) {\n              this.lworldOrgX = wox;\n            };\n            Transform.prototype.getWorldOrgY = function() {\n              return this.lworldOrgY;\n            };\n            Transform.prototype.setWorldOrgY = function(woy) {\n              this.lworldOrgY = woy;\n            };\n            Transform.prototype.getWorldExtX = function() {\n              return this.lworldExtX;\n            };\n            Transform.prototype.setWorldExtX = function(wex) {\n              this.lworldExtX = wex;\n            };\n            Transform.prototype.getWorldExtY = function() {\n              return this.lworldExtY;\n            };\n            Transform.prototype.setWorldExtY = function(wey) {\n              this.lworldExtY = wey;\n            };\n            Transform.prototype.getDeviceOrgX = function() {\n              return this.ldeviceOrgX;\n            };\n            Transform.prototype.setDeviceOrgX = function(dox) {\n              this.ldeviceOrgX = dox;\n            };\n            Transform.prototype.getDeviceOrgY = function() {\n              return this.ldeviceOrgY;\n            };\n            Transform.prototype.setDeviceOrgY = function(doy) {\n              this.ldeviceOrgY = doy;\n            };\n            Transform.prototype.getDeviceExtX = function() {\n              return this.ldeviceExtX;\n            };\n            Transform.prototype.setDeviceExtX = function(dex) {\n              this.ldeviceExtX = dex;\n            };\n            Transform.prototype.getDeviceExtY = function() {\n              return this.ldeviceExtY;\n            };\n            Transform.prototype.setDeviceExtY = function(dey) {\n              this.ldeviceExtY = dey;\n            };\n            Transform.prototype.transformX = function(x) {\n              var xDevice = 0;\n              var worldExtX = this.lworldExtX;\n              if (worldExtX != 0) {\n                xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n              }\n              return xDevice;\n            };\n            Transform.prototype.transformY = function(y) {\n              var yDevice = 0;\n              var worldExtY = this.lworldExtY;\n              if (worldExtY != 0) {\n                yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n              }\n              return yDevice;\n            };\n            Transform.prototype.inverseTransformX = function(x) {\n              var xWorld = 0;\n              var deviceExtX = this.ldeviceExtX;\n              if (deviceExtX != 0) {\n                xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n              }\n              return xWorld;\n            };\n            Transform.prototype.inverseTransformY = function(y) {\n              var yWorld = 0;\n              var deviceExtY = this.ldeviceExtY;\n              if (deviceExtY != 0) {\n                yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n              }\n              return yWorld;\n            };\n            Transform.prototype.inverseTransformPoint = function(inPoint) {\n              var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n              return outPoint;\n            };\n            module2.exports = Transform;\n          },\n          /* 18 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n              if (Array.isArray(arr)) {\n                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n                  arr2[i] = arr[i];\n                }\n                return arr2;\n              } else {\n                return Array.from(arr);\n              }\n            }\n            __name(_toConsumableArray, \"_toConsumableArray\");\n            var Layout2 = __webpack_require__(15);\n            var FDLayoutConstants = __webpack_require__(4);\n            var LayoutConstants = __webpack_require__(0);\n            var IGeometry = __webpack_require__(8);\n            var IMath = __webpack_require__(9);\n            function FDLayout() {\n              Layout2.call(this);\n              this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n              this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n              this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n              this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n              this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n              this.displacementThresholdPerNode = 3 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n              this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n              this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n              this.totalDisplacement = 0;\n              this.oldTotalDisplacement = 0;\n              this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n            }\n            __name(FDLayout, \"FDLayout\");\n            FDLayout.prototype = Object.create(Layout2.prototype);\n            for (var prop in Layout2) {\n              FDLayout[prop] = Layout2[prop];\n            }\n            FDLayout.prototype.initParameters = function() {\n              Layout2.prototype.initParameters.call(this, arguments);\n              this.totalIterations = 0;\n              this.notAnimatedIterations = 0;\n              this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n              this.grid = [];\n            };\n            FDLayout.prototype.calcIdealEdgeLengths = function() {\n              var edge;\n              var originalIdealLength;\n              var lcaDepth;\n              var source;\n              var target;\n              var sizeOfSourceInLca;\n              var sizeOfTargetInLca;\n              var allEdges = this.getGraphManager().getAllEdges();\n              for (var i = 0; i < allEdges.length; i++) {\n                edge = allEdges[i];\n                originalIdealLength = edge.idealLength;\n                if (edge.isInterGraph) {\n                  source = edge.getSource();\n                  target = edge.getTarget();\n                  sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n                  sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n                  if (this.useSmartIdealEdgeLengthCalculation) {\n                    edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n                  }\n                  lcaDepth = edge.getLca().getInclusionTreeDepth();\n                  edge.idealLength += originalIdealLength * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n                }\n              }\n            };\n            FDLayout.prototype.initSpringEmbedder = function() {\n              var s = this.getAllNodes().length;\n              if (this.incremental) {\n                if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                  this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                }\n                this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n              } else {\n                if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                  this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                } else {\n                  this.coolingFactor = 1;\n                }\n                this.initialCoolingFactor = this.coolingFactor;\n                this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n              }\n              this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n              this.displacementThresholdPerNode = 3 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n              this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n              this.repulsionRange = this.calcRepulsionRange();\n            };\n            FDLayout.prototype.calcSpringForces = function() {\n              var lEdges = this.getAllEdges();\n              var edge;\n              for (var i = 0; i < lEdges.length; i++) {\n                edge = lEdges[i];\n                this.calcSpringForce(edge, edge.idealLength);\n              }\n            };\n            FDLayout.prototype.calcRepulsionForces = function() {\n              var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n              var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n              var i, j;\n              var nodeA, nodeB;\n              var lNodes = this.getAllNodes();\n              var processedNodeSet;\n              if (this.useFRGridVariant) {\n                if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n                  this.updateGrid();\n                }\n                processedNodeSet = /* @__PURE__ */ new Set();\n                for (i = 0; i < lNodes.length; i++) {\n                  nodeA = lNodes[i];\n                  this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                  processedNodeSet.add(nodeA);\n                }\n              } else {\n                for (i = 0; i < lNodes.length; i++) {\n                  nodeA = lNodes[i];\n                  for (j = i + 1; j < lNodes.length; j++) {\n                    nodeB = lNodes[j];\n                    if (nodeA.getOwner() != nodeB.getOwner()) {\n                      continue;\n                    }\n                    this.calcRepulsionForce(nodeA, nodeB);\n                  }\n                }\n              }\n            };\n            FDLayout.prototype.calcGravitationalForces = function() {\n              var node;\n              var lNodes = this.getAllNodesToApplyGravitation();\n              for (var i = 0; i < lNodes.length; i++) {\n                node = lNodes[i];\n                this.calcGravitationalForce(node);\n              }\n            };\n            FDLayout.prototype.moveNodes = function() {\n              var lNodes = this.getAllNodes();\n              var node;\n              for (var i = 0; i < lNodes.length; i++) {\n                node = lNodes[i];\n                node.move();\n              }\n            };\n            FDLayout.prototype.calcSpringForce = function(edge, idealLength) {\n              var sourceNode = edge.getSource();\n              var targetNode = edge.getTarget();\n              var length;\n              var springForce;\n              var springForceX;\n              var springForceY;\n              if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n                edge.updateLengthSimple();\n              } else {\n                edge.updateLength();\n                if (edge.isOverlapingSourceAndTarget) {\n                  return;\n                }\n              }\n              length = edge.getLength();\n              if (length == 0) return;\n              springForce = edge.edgeElasticity * (length - idealLength);\n              springForceX = springForce * (edge.lengthX / length);\n              springForceY = springForce * (edge.lengthY / length);\n              sourceNode.springForceX += springForceX;\n              sourceNode.springForceY += springForceY;\n              targetNode.springForceX -= springForceX;\n              targetNode.springForceY -= springForceY;\n            };\n            FDLayout.prototype.calcRepulsionForce = function(nodeA, nodeB) {\n              var rectA = nodeA.getRect();\n              var rectB = nodeB.getRect();\n              var overlapAmount = new Array(2);\n              var clipPoints = new Array(4);\n              var distanceX;\n              var distanceY;\n              var distanceSquared;\n              var distance;\n              var repulsionForce;\n              var repulsionForceX;\n              var repulsionForceY;\n              if (rectA.intersects(rectB)) {\n                IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2);\n                repulsionForceX = 2 * overlapAmount[0];\n                repulsionForceY = 2 * overlapAmount[1];\n                var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n                nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n                nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n                nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n                nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n              } else {\n                if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) {\n                  distanceX = rectB.getCenterX() - rectA.getCenterX();\n                  distanceY = rectB.getCenterY() - rectA.getCenterY();\n                } else {\n                  IGeometry.getIntersection(rectA, rectB, clipPoints);\n                  distanceX = clipPoints[2] - clipPoints[0];\n                  distanceY = clipPoints[3] - clipPoints[1];\n                }\n                if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                  distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n                }\n                if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                  distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n                }\n                distanceSquared = distanceX * distanceX + distanceY * distanceY;\n                distance = Math.sqrt(distanceSquared);\n                repulsionForce = (nodeA.nodeRepulsion / 2 + nodeB.nodeRepulsion / 2) * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n                repulsionForceX = repulsionForce * distanceX / distance;\n                repulsionForceY = repulsionForce * distanceY / distance;\n                nodeA.repulsionForceX -= repulsionForceX;\n                nodeA.repulsionForceY -= repulsionForceY;\n                nodeB.repulsionForceX += repulsionForceX;\n                nodeB.repulsionForceY += repulsionForceY;\n              }\n            };\n            FDLayout.prototype.calcGravitationalForce = function(node) {\n              var ownerGraph;\n              var ownerCenterX;\n              var ownerCenterY;\n              var distanceX;\n              var distanceY;\n              var absDistanceX;\n              var absDistanceY;\n              var estimatedSize;\n              ownerGraph = node.getOwner();\n              ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n              ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n              distanceX = node.getCenterX() - ownerCenterX;\n              distanceY = node.getCenterY() - ownerCenterY;\n              absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n              absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n              if (node.getOwner() == this.graphManager.getRoot()) {\n                estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n                if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                  node.gravitationForceX = -this.gravityConstant * distanceX;\n                  node.gravitationForceY = -this.gravityConstant * distanceY;\n                }\n              } else {\n                estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n                if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                  node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n                  node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n                }\n              }\n            };\n            FDLayout.prototype.isConverged = function() {\n              var converged;\n              var oscilating = false;\n              if (this.totalIterations > this.maxIterations / 3) {\n                oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n              }\n              converged = this.totalDisplacement < this.totalDisplacementThreshold;\n              this.oldTotalDisplacement = this.totalDisplacement;\n              return converged || oscilating;\n            };\n            FDLayout.prototype.animate = function() {\n              if (this.animationDuringLayout && !this.isSubLayout) {\n                if (this.notAnimatedIterations == this.animationPeriod) {\n                  this.update();\n                  this.notAnimatedIterations = 0;\n                } else {\n                  this.notAnimatedIterations++;\n                }\n              }\n            };\n            FDLayout.prototype.calcNoOfChildrenForAllNodes = function() {\n              var node;\n              var allNodes = this.graphManager.getAllNodes();\n              for (var i = 0; i < allNodes.length; i++) {\n                node = allNodes[i];\n                node.noOfChildren = node.getNoOfChildren();\n              }\n            };\n            FDLayout.prototype.calcGrid = function(graph) {\n              var sizeX = 0;\n              var sizeY = 0;\n              sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n              sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n              var grid = new Array(sizeX);\n              for (var i = 0; i < sizeX; i++) {\n                grid[i] = new Array(sizeY);\n              }\n              for (var i = 0; i < sizeX; i++) {\n                for (var j = 0; j < sizeY; j++) {\n                  grid[i][j] = new Array();\n                }\n              }\n              return grid;\n            };\n            FDLayout.prototype.addNodeToGrid = function(v, left, top) {\n              var startX = 0;\n              var finishX = 0;\n              var startY = 0;\n              var finishY = 0;\n              startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n              finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n              startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n              finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n              for (var i = startX; i <= finishX; i++) {\n                for (var j = startY; j <= finishY; j++) {\n                  this.grid[i][j].push(v);\n                  v.setGridCoordinates(startX, finishX, startY, finishY);\n                }\n              }\n            };\n            FDLayout.prototype.updateGrid = function() {\n              var i;\n              var nodeA;\n              var lNodes = this.getAllNodes();\n              this.grid = this.calcGrid(this.graphManager.getRoot());\n              for (i = 0; i < lNodes.length; i++) {\n                nodeA = lNodes[i];\n                this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n              }\n            };\n            FDLayout.prototype.calculateRepulsionForceOfANode = function(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n              if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n                var surrounding = /* @__PURE__ */ new Set();\n                nodeA.surrounding = new Array();\n                var nodeB;\n                var grid = this.grid;\n                for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n                  for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n                    if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n                      for (var k = 0; k < grid[i][j].length; k++) {\n                        nodeB = grid[i][j][k];\n                        if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n                          continue;\n                        }\n                        if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n                          var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n                          var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n                          if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                            surrounding.add(nodeB);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n                nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n              }\n              for (i = 0; i < nodeA.surrounding.length; i++) {\n                this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n              }\n            };\n            FDLayout.prototype.calcRepulsionRange = function() {\n              return 0;\n            };\n            module2.exports = FDLayout;\n          },\n          /* 19 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var LEdge = __webpack_require__(1);\n            var FDLayoutConstants = __webpack_require__(4);\n            function FDLayoutEdge(source, target, vEdge) {\n              LEdge.call(this, source, target, vEdge);\n              this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n              this.edgeElasticity = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n            }\n            __name(FDLayoutEdge, \"FDLayoutEdge\");\n            FDLayoutEdge.prototype = Object.create(LEdge.prototype);\n            for (var prop in LEdge) {\n              FDLayoutEdge[prop] = LEdge[prop];\n            }\n            module2.exports = FDLayoutEdge;\n          },\n          /* 20 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var LNode = __webpack_require__(3);\n            var FDLayoutConstants = __webpack_require__(4);\n            function FDLayoutNode(gm, loc, size, vNode) {\n              LNode.call(this, gm, loc, size, vNode);\n              this.nodeRepulsion = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n              this.springForceX = 0;\n              this.springForceY = 0;\n              this.repulsionForceX = 0;\n              this.repulsionForceY = 0;\n              this.gravitationForceX = 0;\n              this.gravitationForceY = 0;\n              this.displacementX = 0;\n              this.displacementY = 0;\n              this.startX = 0;\n              this.finishX = 0;\n              this.startY = 0;\n              this.finishY = 0;\n              this.surrounding = [];\n            }\n            __name(FDLayoutNode, \"FDLayoutNode\");\n            FDLayoutNode.prototype = Object.create(LNode.prototype);\n            for (var prop in LNode) {\n              FDLayoutNode[prop] = LNode[prop];\n            }\n            FDLayoutNode.prototype.setGridCoordinates = function(_startX, _finishX, _startY, _finishY) {\n              this.startX = _startX;\n              this.finishX = _finishX;\n              this.startY = _startY;\n              this.finishY = _finishY;\n            };\n            module2.exports = FDLayoutNode;\n          },\n          /* 21 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function DimensionD2(width, height) {\n              this.width = 0;\n              this.height = 0;\n              if (width !== null && height !== null) {\n                this.height = height;\n                this.width = width;\n              }\n            }\n            __name(DimensionD2, \"DimensionD\");\n            DimensionD2.prototype.getWidth = function() {\n              return this.width;\n            };\n            DimensionD2.prototype.setWidth = function(width) {\n              this.width = width;\n            };\n            DimensionD2.prototype.getHeight = function() {\n              return this.height;\n            };\n            DimensionD2.prototype.setHeight = function(height) {\n              this.height = height;\n            };\n            module2.exports = DimensionD2;\n          },\n          /* 22 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __webpack_require__(14);\n            function HashMap() {\n              this.map = {};\n              this.keys = [];\n            }\n            __name(HashMap, \"HashMap\");\n            HashMap.prototype.put = function(key, value) {\n              var theId = UniqueIDGeneretor.createID(key);\n              if (!this.contains(theId)) {\n                this.map[theId] = value;\n                this.keys.push(key);\n              }\n            };\n            HashMap.prototype.contains = function(key) {\n              var theId = UniqueIDGeneretor.createID(key);\n              return this.map[key] != null;\n            };\n            HashMap.prototype.get = function(key) {\n              var theId = UniqueIDGeneretor.createID(key);\n              return this.map[theId];\n            };\n            HashMap.prototype.keySet = function() {\n              return this.keys;\n            };\n            module2.exports = HashMap;\n          },\n          /* 23 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __webpack_require__(14);\n            function HashSet() {\n              this.set = {};\n            }\n            __name(HashSet, \"HashSet\");\n            ;\n            HashSet.prototype.add = function(obj) {\n              var theId = UniqueIDGeneretor.createID(obj);\n              if (!this.contains(theId)) this.set[theId] = obj;\n            };\n            HashSet.prototype.remove = function(obj) {\n              delete this.set[UniqueIDGeneretor.createID(obj)];\n            };\n            HashSet.prototype.clear = function() {\n              this.set = {};\n            };\n            HashSet.prototype.contains = function(obj) {\n              return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n            };\n            HashSet.prototype.isEmpty = function() {\n              return this.size() === 0;\n            };\n            HashSet.prototype.size = function() {\n              return Object.keys(this.set).length;\n            };\n            HashSet.prototype.addAllTo = function(list) {\n              var keys = Object.keys(this.set);\n              var length = keys.length;\n              for (var i = 0; i < length; i++) {\n                list.push(this.set[keys[i]]);\n              }\n            };\n            HashSet.prototype.size = function() {\n              return Object.keys(this.set).length;\n            };\n            HashSet.prototype.addAll = function(list) {\n              var s = list.length;\n              for (var i = 0; i < s; i++) {\n                var v = list[i];\n                this.add(v);\n              }\n            };\n            module2.exports = HashSet;\n          },\n          /* 24 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function Matrix() {\n            }\n            __name(Matrix, \"Matrix\");\n            Matrix.multMat = function(array1, array2) {\n              var result = [];\n              for (var i = 0; i < array1.length; i++) {\n                result[i] = [];\n                for (var j = 0; j < array2[0].length; j++) {\n                  result[i][j] = 0;\n                  for (var k = 0; k < array1[0].length; k++) {\n                    result[i][j] += array1[i][k] * array2[k][j];\n                  }\n                }\n              }\n              return result;\n            };\n            Matrix.transpose = function(array) {\n              var result = [];\n              for (var i = 0; i < array[0].length; i++) {\n                result[i] = [];\n                for (var j = 0; j < array.length; j++) {\n                  result[i][j] = array[j][i];\n                }\n              }\n              return result;\n            };\n            Matrix.multCons = function(array, constant) {\n              var result = [];\n              for (var i = 0; i < array.length; i++) {\n                result[i] = array[i] * constant;\n              }\n              return result;\n            };\n            Matrix.minusOp = function(array1, array2) {\n              var result = [];\n              for (var i = 0; i < array1.length; i++) {\n                result[i] = array1[i] - array2[i];\n              }\n              return result;\n            };\n            Matrix.dotProduct = function(array1, array2) {\n              var product = 0;\n              for (var i = 0; i < array1.length; i++) {\n                product += array1[i] * array2[i];\n              }\n              return product;\n            };\n            Matrix.mag = function(array) {\n              return Math.sqrt(this.dotProduct(array, array));\n            };\n            Matrix.normalize = function(array) {\n              var result = [];\n              var magnitude = this.mag(array);\n              for (var i = 0; i < array.length; i++) {\n                result[i] = array[i] / magnitude;\n              }\n              return result;\n            };\n            Matrix.multGamma = function(array) {\n              var result = [];\n              var sum = 0;\n              for (var i = 0; i < array.length; i++) {\n                sum += array[i];\n              }\n              sum *= -1 / array.length;\n              for (var _i = 0; _i < array.length; _i++) {\n                result[_i] = sum + array[_i];\n              }\n              return result;\n            };\n            Matrix.multL = function(array, C, INV) {\n              var result = [];\n              var temp1 = [];\n              var temp2 = [];\n              for (var i = 0; i < C[0].length; i++) {\n                var sum = 0;\n                for (var j = 0; j < C.length; j++) {\n                  sum += -0.5 * C[j][i] * array[j];\n                }\n                temp1[i] = sum;\n              }\n              for (var _i2 = 0; _i2 < INV.length; _i2++) {\n                var _sum = 0;\n                for (var _j = 0; _j < INV.length; _j++) {\n                  _sum += INV[_i2][_j] * temp1[_j];\n                }\n                temp2[_i2] = _sum;\n              }\n              for (var _i3 = 0; _i3 < C.length; _i3++) {\n                var _sum2 = 0;\n                for (var _j2 = 0; _j2 < C[0].length; _j2++) {\n                  _sum2 += C[_i3][_j2] * temp2[_j2];\n                }\n                result[_i3] = _sum2;\n              }\n              return result;\n            };\n            module2.exports = Matrix;\n          },\n          /* 25 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var _createClass = /* @__PURE__ */ function() {\n              function defineProperties(target, props) {\n                for (var i = 0; i < props.length; i++) {\n                  var descriptor = props[i];\n                  descriptor.enumerable = descriptor.enumerable || false;\n                  descriptor.configurable = true;\n                  if (\"value\" in descriptor) descriptor.writable = true;\n                  Object.defineProperty(target, descriptor.key, descriptor);\n                }\n              }\n              __name(defineProperties, \"defineProperties\");\n              return function(Constructor, protoProps, staticProps) {\n                if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) defineProperties(Constructor, staticProps);\n                return Constructor;\n              };\n            }();\n            function _classCallCheck(instance2, Constructor) {\n              if (!(instance2 instanceof Constructor)) {\n                throw new TypeError(\"Cannot call a class as a function\");\n              }\n            }\n            __name(_classCallCheck, \"_classCallCheck\");\n            var LinkedList = __webpack_require__(11);\n            var Quicksort = function() {\n              function Quicksort2(A, compareFunction) {\n                _classCallCheck(this, Quicksort2);\n                if (compareFunction !== null || compareFunction !== void 0) this.compareFunction = this._defaultCompareFunction;\n                var length = void 0;\n                if (A instanceof LinkedList) length = A.size();\n                else length = A.length;\n                this._quicksort(A, 0, length - 1);\n              }\n              __name(Quicksort2, \"Quicksort\");\n              _createClass(Quicksort2, [{\n                key: \"_quicksort\",\n                value: /* @__PURE__ */ __name(function _quicksort(A, p, r) {\n                  if (p < r) {\n                    var q = this._partition(A, p, r);\n                    this._quicksort(A, p, q);\n                    this._quicksort(A, q + 1, r);\n                  }\n                }, \"_quicksort\")\n              }, {\n                key: \"_partition\",\n                value: /* @__PURE__ */ __name(function _partition(A, p, r) {\n                  var x = this._get(A, p);\n                  var i = p;\n                  var j = r;\n                  while (true) {\n                    while (this.compareFunction(x, this._get(A, j))) {\n                      j--;\n                    }\n                    while (this.compareFunction(this._get(A, i), x)) {\n                      i++;\n                    }\n                    if (i < j) {\n                      this._swap(A, i, j);\n                      i++;\n                      j--;\n                    } else return j;\n                  }\n                }, \"_partition\")\n              }, {\n                key: \"_get\",\n                value: /* @__PURE__ */ __name(function _get(object, index) {\n                  if (object instanceof LinkedList) return object.get_object_at(index);\n                  else return object[index];\n                }, \"_get\")\n              }, {\n                key: \"_set\",\n                value: /* @__PURE__ */ __name(function _set(object, index, value) {\n                  if (object instanceof LinkedList) object.set_object_at(index, value);\n                  else object[index] = value;\n                }, \"_set\")\n              }, {\n                key: \"_swap\",\n                value: /* @__PURE__ */ __name(function _swap(A, i, j) {\n                  var temp = this._get(A, i);\n                  this._set(A, i, this._get(A, j));\n                  this._set(A, j, temp);\n                }, \"_swap\")\n              }, {\n                key: \"_defaultCompareFunction\",\n                value: /* @__PURE__ */ __name(function _defaultCompareFunction(a, b) {\n                  return b > a;\n                }, \"_defaultCompareFunction\")\n              }]);\n              return Quicksort2;\n            }();\n            module2.exports = Quicksort;\n          },\n          /* 26 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function SVD() {\n            }\n            __name(SVD, \"SVD\");\n            ;\n            SVD.svd = function(A) {\n              this.U = null;\n              this.V = null;\n              this.s = null;\n              this.m = 0;\n              this.n = 0;\n              this.m = A.length;\n              this.n = A[0].length;\n              var nu = Math.min(this.m, this.n);\n              this.s = function(s) {\n                var a = [];\n                while (s-- > 0) {\n                  a.push(0);\n                }\n                return a;\n              }(Math.min(this.m + 1, this.n));\n              this.U = function(dims) {\n                var allocate = /* @__PURE__ */ __name(function allocate2(dims2) {\n                  if (dims2.length == 0) {\n                    return 0;\n                  } else {\n                    var array = [];\n                    for (var i2 = 0; i2 < dims2[0]; i2++) {\n                      array.push(allocate2(dims2.slice(1)));\n                    }\n                    return array;\n                  }\n                }, \"allocate\");\n                return allocate(dims);\n              }([this.m, nu]);\n              this.V = function(dims) {\n                var allocate = /* @__PURE__ */ __name(function allocate2(dims2) {\n                  if (dims2.length == 0) {\n                    return 0;\n                  } else {\n                    var array = [];\n                    for (var i2 = 0; i2 < dims2[0]; i2++) {\n                      array.push(allocate2(dims2.slice(1)));\n                    }\n                    return array;\n                  }\n                }, \"allocate\");\n                return allocate(dims);\n              }([this.n, this.n]);\n              var e = function(s) {\n                var a = [];\n                while (s-- > 0) {\n                  a.push(0);\n                }\n                return a;\n              }(this.n);\n              var work = function(s) {\n                var a = [];\n                while (s-- > 0) {\n                  a.push(0);\n                }\n                return a;\n              }(this.m);\n              var wantu = true;\n              var wantv = true;\n              var nct = Math.min(this.m - 1, this.n);\n              var nrt = Math.max(0, Math.min(this.n - 2, this.m));\n              for (var k = 0; k < Math.max(nct, nrt); k++) {\n                if (k < nct) {\n                  this.s[k] = 0;\n                  for (var i = k; i < this.m; i++) {\n                    this.s[k] = SVD.hypot(this.s[k], A[i][k]);\n                  }\n                  ;\n                  if (this.s[k] !== 0) {\n                    if (A[k][k] < 0) {\n                      this.s[k] = -this.s[k];\n                    }\n                    for (var _i = k; _i < this.m; _i++) {\n                      A[_i][k] /= this.s[k];\n                    }\n                    ;\n                    A[k][k] += 1;\n                  }\n                  this.s[k] = -this.s[k];\n                }\n                for (var j = k + 1; j < this.n; j++) {\n                  if (/* @__PURE__ */ function(lhs, rhs) {\n                    return lhs && rhs;\n                  }(k < nct, this.s[k] !== 0)) {\n                    var t = 0;\n                    for (var _i2 = k; _i2 < this.m; _i2++) {\n                      t += A[_i2][k] * A[_i2][j];\n                    }\n                    ;\n                    t = -t / A[k][k];\n                    for (var _i3 = k; _i3 < this.m; _i3++) {\n                      A[_i3][j] += t * A[_i3][k];\n                    }\n                    ;\n                  }\n                  e[j] = A[k][j];\n                }\n                ;\n                if (/* @__PURE__ */ function(lhs, rhs) {\n                  return lhs && rhs;\n                }(wantu, k < nct)) {\n                  for (var _i4 = k; _i4 < this.m; _i4++) {\n                    this.U[_i4][k] = A[_i4][k];\n                  }\n                  ;\n                }\n                if (k < nrt) {\n                  e[k] = 0;\n                  for (var _i5 = k + 1; _i5 < this.n; _i5++) {\n                    e[k] = SVD.hypot(e[k], e[_i5]);\n                  }\n                  ;\n                  if (e[k] !== 0) {\n                    if (e[k + 1] < 0) {\n                      e[k] = -e[k];\n                    }\n                    for (var _i6 = k + 1; _i6 < this.n; _i6++) {\n                      e[_i6] /= e[k];\n                    }\n                    ;\n                    e[k + 1] += 1;\n                  }\n                  e[k] = -e[k];\n                  if (/* @__PURE__ */ function(lhs, rhs) {\n                    return lhs && rhs;\n                  }(k + 1 < this.m, e[k] !== 0)) {\n                    for (var _i7 = k + 1; _i7 < this.m; _i7++) {\n                      work[_i7] = 0;\n                    }\n                    ;\n                    for (var _j = k + 1; _j < this.n; _j++) {\n                      for (var _i8 = k + 1; _i8 < this.m; _i8++) {\n                        work[_i8] += e[_j] * A[_i8][_j];\n                      }\n                      ;\n                    }\n                    ;\n                    for (var _j2 = k + 1; _j2 < this.n; _j2++) {\n                      var _t = -e[_j2] / e[k + 1];\n                      for (var _i9 = k + 1; _i9 < this.m; _i9++) {\n                        A[_i9][_j2] += _t * work[_i9];\n                      }\n                      ;\n                    }\n                    ;\n                  }\n                  if (wantv) {\n                    for (var _i10 = k + 1; _i10 < this.n; _i10++) {\n                      this.V[_i10][k] = e[_i10];\n                    }\n                    ;\n                  }\n                }\n              }\n              ;\n              var p = Math.min(this.n, this.m + 1);\n              if (nct < this.n) {\n                this.s[nct] = A[nct][nct];\n              }\n              if (this.m < p) {\n                this.s[p - 1] = 0;\n              }\n              if (nrt + 1 < p) {\n                e[nrt] = A[nrt][p - 1];\n              }\n              e[p - 1] = 0;\n              if (wantu) {\n                for (var _j3 = nct; _j3 < nu; _j3++) {\n                  for (var _i11 = 0; _i11 < this.m; _i11++) {\n                    this.U[_i11][_j3] = 0;\n                  }\n                  ;\n                  this.U[_j3][_j3] = 1;\n                }\n                ;\n                for (var _k = nct - 1; _k >= 0; _k--) {\n                  if (this.s[_k] !== 0) {\n                    for (var _j4 = _k + 1; _j4 < nu; _j4++) {\n                      var _t2 = 0;\n                      for (var _i12 = _k; _i12 < this.m; _i12++) {\n                        _t2 += this.U[_i12][_k] * this.U[_i12][_j4];\n                      }\n                      ;\n                      _t2 = -_t2 / this.U[_k][_k];\n                      for (var _i13 = _k; _i13 < this.m; _i13++) {\n                        this.U[_i13][_j4] += _t2 * this.U[_i13][_k];\n                      }\n                      ;\n                    }\n                    ;\n                    for (var _i14 = _k; _i14 < this.m; _i14++) {\n                      this.U[_i14][_k] = -this.U[_i14][_k];\n                    }\n                    ;\n                    this.U[_k][_k] = 1 + this.U[_k][_k];\n                    for (var _i15 = 0; _i15 < _k - 1; _i15++) {\n                      this.U[_i15][_k] = 0;\n                    }\n                    ;\n                  } else {\n                    for (var _i16 = 0; _i16 < this.m; _i16++) {\n                      this.U[_i16][_k] = 0;\n                    }\n                    ;\n                    this.U[_k][_k] = 1;\n                  }\n                }\n                ;\n              }\n              if (wantv) {\n                for (var _k2 = this.n - 1; _k2 >= 0; _k2--) {\n                  if (/* @__PURE__ */ function(lhs, rhs) {\n                    return lhs && rhs;\n                  }(_k2 < nrt, e[_k2] !== 0)) {\n                    for (var _j5 = _k2 + 1; _j5 < nu; _j5++) {\n                      var _t3 = 0;\n                      for (var _i17 = _k2 + 1; _i17 < this.n; _i17++) {\n                        _t3 += this.V[_i17][_k2] * this.V[_i17][_j5];\n                      }\n                      ;\n                      _t3 = -_t3 / this.V[_k2 + 1][_k2];\n                      for (var _i18 = _k2 + 1; _i18 < this.n; _i18++) {\n                        this.V[_i18][_j5] += _t3 * this.V[_i18][_k2];\n                      }\n                      ;\n                    }\n                    ;\n                  }\n                  for (var _i19 = 0; _i19 < this.n; _i19++) {\n                    this.V[_i19][_k2] = 0;\n                  }\n                  ;\n                  this.V[_k2][_k2] = 1;\n                }\n                ;\n              }\n              var pp = p - 1;\n              var iter = 0;\n              var eps = Math.pow(2, -52);\n              var tiny = Math.pow(2, -966);\n              while (p > 0) {\n                var _k3 = void 0;\n                var kase = void 0;\n                for (_k3 = p - 2; _k3 >= -1; _k3--) {\n                  if (_k3 === -1) {\n                    break;\n                  }\n                  if (Math.abs(e[_k3]) <= tiny + eps * (Math.abs(this.s[_k3]) + Math.abs(this.s[_k3 + 1]))) {\n                    e[_k3] = 0;\n                    break;\n                  }\n                }\n                ;\n                if (_k3 === p - 2) {\n                  kase = 4;\n                } else {\n                  var ks = void 0;\n                  for (ks = p - 1; ks >= _k3; ks--) {\n                    if (ks === _k3) {\n                      break;\n                    }\n                    var _t4 = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== _k3 + 1 ? Math.abs(e[ks - 1]) : 0);\n                    if (Math.abs(this.s[ks]) <= tiny + eps * _t4) {\n                      this.s[ks] = 0;\n                      break;\n                    }\n                  }\n                  ;\n                  if (ks === _k3) {\n                    kase = 3;\n                  } else if (ks === p - 1) {\n                    kase = 1;\n                  } else {\n                    kase = 2;\n                    _k3 = ks;\n                  }\n                }\n                _k3++;\n                switch (kase) {\n                  case 1:\n                    {\n                      var f = e[p - 2];\n                      e[p - 2] = 0;\n                      for (var _j6 = p - 2; _j6 >= _k3; _j6--) {\n                        var _t5 = SVD.hypot(this.s[_j6], f);\n                        var cs = this.s[_j6] / _t5;\n                        var sn = f / _t5;\n                        this.s[_j6] = _t5;\n                        if (_j6 !== _k3) {\n                          f = -sn * e[_j6 - 1];\n                          e[_j6 - 1] = cs * e[_j6 - 1];\n                        }\n                        if (wantv) {\n                          for (var _i20 = 0; _i20 < this.n; _i20++) {\n                            _t5 = cs * this.V[_i20][_j6] + sn * this.V[_i20][p - 1];\n                            this.V[_i20][p - 1] = -sn * this.V[_i20][_j6] + cs * this.V[_i20][p - 1];\n                            this.V[_i20][_j6] = _t5;\n                          }\n                          ;\n                        }\n                      }\n                      ;\n                    }\n                    ;\n                    break;\n                  case 2:\n                    {\n                      var _f = e[_k3 - 1];\n                      e[_k3 - 1] = 0;\n                      for (var _j7 = _k3; _j7 < p; _j7++) {\n                        var _t6 = SVD.hypot(this.s[_j7], _f);\n                        var _cs = this.s[_j7] / _t6;\n                        var _sn = _f / _t6;\n                        this.s[_j7] = _t6;\n                        _f = -_sn * e[_j7];\n                        e[_j7] = _cs * e[_j7];\n                        if (wantu) {\n                          for (var _i21 = 0; _i21 < this.m; _i21++) {\n                            _t6 = _cs * this.U[_i21][_j7] + _sn * this.U[_i21][_k3 - 1];\n                            this.U[_i21][_k3 - 1] = -_sn * this.U[_i21][_j7] + _cs * this.U[_i21][_k3 - 1];\n                            this.U[_i21][_j7] = _t6;\n                          }\n                          ;\n                        }\n                      }\n                      ;\n                    }\n                    ;\n                    break;\n                  case 3:\n                    {\n                      var scale = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[p - 1]), Math.abs(this.s[p - 2])), Math.abs(e[p - 2])), Math.abs(this.s[_k3])), Math.abs(e[_k3]));\n                      var sp = this.s[p - 1] / scale;\n                      var spm1 = this.s[p - 2] / scale;\n                      var epm1 = e[p - 2] / scale;\n                      var sk = this.s[_k3] / scale;\n                      var ek = e[_k3] / scale;\n                      var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                      var c = sp * epm1 * (sp * epm1);\n                      var shift = 0;\n                      if (/* @__PURE__ */ function(lhs, rhs) {\n                        return lhs || rhs;\n                      }(b !== 0, c !== 0)) {\n                        shift = Math.sqrt(b * b + c);\n                        if (b < 0) {\n                          shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                      }\n                      var _f2 = (sk + sp) * (sk - sp) + shift;\n                      var g = sk * ek;\n                      for (var _j8 = _k3; _j8 < p - 1; _j8++) {\n                        var _t7 = SVD.hypot(_f2, g);\n                        var _cs2 = _f2 / _t7;\n                        var _sn2 = g / _t7;\n                        if (_j8 !== _k3) {\n                          e[_j8 - 1] = _t7;\n                        }\n                        _f2 = _cs2 * this.s[_j8] + _sn2 * e[_j8];\n                        e[_j8] = _cs2 * e[_j8] - _sn2 * this.s[_j8];\n                        g = _sn2 * this.s[_j8 + 1];\n                        this.s[_j8 + 1] = _cs2 * this.s[_j8 + 1];\n                        if (wantv) {\n                          for (var _i22 = 0; _i22 < this.n; _i22++) {\n                            _t7 = _cs2 * this.V[_i22][_j8] + _sn2 * this.V[_i22][_j8 + 1];\n                            this.V[_i22][_j8 + 1] = -_sn2 * this.V[_i22][_j8] + _cs2 * this.V[_i22][_j8 + 1];\n                            this.V[_i22][_j8] = _t7;\n                          }\n                          ;\n                        }\n                        _t7 = SVD.hypot(_f2, g);\n                        _cs2 = _f2 / _t7;\n                        _sn2 = g / _t7;\n                        this.s[_j8] = _t7;\n                        _f2 = _cs2 * e[_j8] + _sn2 * this.s[_j8 + 1];\n                        this.s[_j8 + 1] = -_sn2 * e[_j8] + _cs2 * this.s[_j8 + 1];\n                        g = _sn2 * e[_j8 + 1];\n                        e[_j8 + 1] = _cs2 * e[_j8 + 1];\n                        if (wantu && _j8 < this.m - 1) {\n                          for (var _i23 = 0; _i23 < this.m; _i23++) {\n                            _t7 = _cs2 * this.U[_i23][_j8] + _sn2 * this.U[_i23][_j8 + 1];\n                            this.U[_i23][_j8 + 1] = -_sn2 * this.U[_i23][_j8] + _cs2 * this.U[_i23][_j8 + 1];\n                            this.U[_i23][_j8] = _t7;\n                          }\n                          ;\n                        }\n                      }\n                      ;\n                      e[p - 2] = _f2;\n                      iter = iter + 1;\n                    }\n                    ;\n                    break;\n                  case 4:\n                    {\n                      if (this.s[_k3] <= 0) {\n                        this.s[_k3] = this.s[_k3] < 0 ? -this.s[_k3] : 0;\n                        if (wantv) {\n                          for (var _i24 = 0; _i24 <= pp; _i24++) {\n                            this.V[_i24][_k3] = -this.V[_i24][_k3];\n                          }\n                          ;\n                        }\n                      }\n                      while (_k3 < pp) {\n                        if (this.s[_k3] >= this.s[_k3 + 1]) {\n                          break;\n                        }\n                        var _t8 = this.s[_k3];\n                        this.s[_k3] = this.s[_k3 + 1];\n                        this.s[_k3 + 1] = _t8;\n                        if (wantv && _k3 < this.n - 1) {\n                          for (var _i25 = 0; _i25 < this.n; _i25++) {\n                            _t8 = this.V[_i25][_k3 + 1];\n                            this.V[_i25][_k3 + 1] = this.V[_i25][_k3];\n                            this.V[_i25][_k3] = _t8;\n                          }\n                          ;\n                        }\n                        if (wantu && _k3 < this.m - 1) {\n                          for (var _i26 = 0; _i26 < this.m; _i26++) {\n                            _t8 = this.U[_i26][_k3 + 1];\n                            this.U[_i26][_k3 + 1] = this.U[_i26][_k3];\n                            this.U[_i26][_k3] = _t8;\n                          }\n                          ;\n                        }\n                        _k3++;\n                      }\n                      ;\n                      iter = 0;\n                      p--;\n                    }\n                    ;\n                    break;\n                }\n              }\n              ;\n              var result = { U: this.U, V: this.V, S: this.s };\n              return result;\n            };\n            SVD.hypot = function(a, b) {\n              var r = void 0;\n              if (Math.abs(a) > Math.abs(b)) {\n                r = b / a;\n                r = Math.abs(a) * Math.sqrt(1 + r * r);\n              } else if (b != 0) {\n                r = a / b;\n                r = Math.abs(b) * Math.sqrt(1 + r * r);\n              } else {\n                r = 0;\n              }\n              return r;\n            };\n            module2.exports = SVD;\n          },\n          /* 27 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var _createClass = /* @__PURE__ */ function() {\n              function defineProperties(target, props) {\n                for (var i = 0; i < props.length; i++) {\n                  var descriptor = props[i];\n                  descriptor.enumerable = descriptor.enumerable || false;\n                  descriptor.configurable = true;\n                  if (\"value\" in descriptor) descriptor.writable = true;\n                  Object.defineProperty(target, descriptor.key, descriptor);\n                }\n              }\n              __name(defineProperties, \"defineProperties\");\n              return function(Constructor, protoProps, staticProps) {\n                if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) defineProperties(Constructor, staticProps);\n                return Constructor;\n              };\n            }();\n            function _classCallCheck(instance2, Constructor) {\n              if (!(instance2 instanceof Constructor)) {\n                throw new TypeError(\"Cannot call a class as a function\");\n              }\n            }\n            __name(_classCallCheck, \"_classCallCheck\");\n            var NeedlemanWunsch = function() {\n              function NeedlemanWunsch2(sequence1, sequence2) {\n                var match_score = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n                var mismatch_penalty = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;\n                var gap_penalty = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;\n                _classCallCheck(this, NeedlemanWunsch2);\n                this.sequence1 = sequence1;\n                this.sequence2 = sequence2;\n                this.match_score = match_score;\n                this.mismatch_penalty = mismatch_penalty;\n                this.gap_penalty = gap_penalty;\n                this.iMax = sequence1.length + 1;\n                this.jMax = sequence2.length + 1;\n                this.grid = new Array(this.iMax);\n                for (var i = 0; i < this.iMax; i++) {\n                  this.grid[i] = new Array(this.jMax);\n                  for (var j = 0; j < this.jMax; j++) {\n                    this.grid[i][j] = 0;\n                  }\n                }\n                this.tracebackGrid = new Array(this.iMax);\n                for (var _i = 0; _i < this.iMax; _i++) {\n                  this.tracebackGrid[_i] = new Array(this.jMax);\n                  for (var _j = 0; _j < this.jMax; _j++) {\n                    this.tracebackGrid[_i][_j] = [null, null, null];\n                  }\n                }\n                this.alignments = [];\n                this.score = -1;\n                this.computeGrids();\n              }\n              __name(NeedlemanWunsch2, \"NeedlemanWunsch\");\n              _createClass(NeedlemanWunsch2, [{\n                key: \"getScore\",\n                value: /* @__PURE__ */ __name(function getScore() {\n                  return this.score;\n                }, \"getScore\")\n              }, {\n                key: \"getAlignments\",\n                value: /* @__PURE__ */ __name(function getAlignments2() {\n                  return this.alignments;\n                }, \"getAlignments\")\n                // Main dynamic programming procedure\n              }, {\n                key: \"computeGrids\",\n                value: /* @__PURE__ */ __name(function computeGrids() {\n                  for (var j = 1; j < this.jMax; j++) {\n                    this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                    this.tracebackGrid[0][j] = [false, false, true];\n                  }\n                  for (var i = 1; i < this.iMax; i++) {\n                    this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                    this.tracebackGrid[i][0] = [false, true, false];\n                  }\n                  for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                    for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                      var diag = void 0;\n                      if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;\n                      else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n                      var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                      var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n                      var maxOf = [diag, up, left];\n                      var indices = this.arrayAllMaxIndexes(maxOf);\n                      this.grid[_i2][_j2] = maxOf[indices[0]];\n                      this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                    }\n                  }\n                  this.score = this.grid[this.iMax - 1][this.jMax - 1];\n                }, \"computeGrids\")\n                // Gets all possible valid sequence combinations\n              }, {\n                key: \"alignmentTraceback\",\n                value: /* @__PURE__ */ __name(function alignmentTraceback() {\n                  var inProcessAlignments = [];\n                  inProcessAlignments.push({\n                    pos: [this.sequence1.length, this.sequence2.length],\n                    seq1: \"\",\n                    seq2: \"\"\n                  });\n                  while (inProcessAlignments[0]) {\n                    var current = inProcessAlignments[0];\n                    var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n                    if (directions[0]) {\n                      inProcessAlignments.push({\n                        pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                      });\n                    }\n                    if (directions[1]) {\n                      inProcessAlignments.push({\n                        pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: \"-\" + current.seq2\n                      });\n                    }\n                    if (directions[2]) {\n                      inProcessAlignments.push({\n                        pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: \"-\" + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                      });\n                    }\n                    if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({\n                      sequence1: current.seq1,\n                      sequence2: current.seq2\n                    });\n                    inProcessAlignments.shift();\n                  }\n                  return this.alignments;\n                }, \"alignmentTraceback\")\n                // Helper Functions\n              }, {\n                key: \"getAllIndexes\",\n                value: /* @__PURE__ */ __name(function getAllIndexes(arr, val) {\n                  var indexes = [], i = -1;\n                  while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                    indexes.push(i);\n                  }\n                  return indexes;\n                }, \"getAllIndexes\")\n              }, {\n                key: \"arrayAllMaxIndexes\",\n                value: /* @__PURE__ */ __name(function arrayAllMaxIndexes(array) {\n                  return this.getAllIndexes(array, Math.max.apply(null, array));\n                }, \"arrayAllMaxIndexes\")\n              }]);\n              return NeedlemanWunsch2;\n            }();\n            module2.exports = NeedlemanWunsch;\n          },\n          /* 28 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            var layoutBase = /* @__PURE__ */ __name(function layoutBase2() {\n              return;\n            }, \"layoutBase\");\n            layoutBase.FDLayout = __webpack_require__(18);\n            layoutBase.FDLayoutConstants = __webpack_require__(4);\n            layoutBase.FDLayoutEdge = __webpack_require__(19);\n            layoutBase.FDLayoutNode = __webpack_require__(20);\n            layoutBase.DimensionD = __webpack_require__(21);\n            layoutBase.HashMap = __webpack_require__(22);\n            layoutBase.HashSet = __webpack_require__(23);\n            layoutBase.IGeometry = __webpack_require__(8);\n            layoutBase.IMath = __webpack_require__(9);\n            layoutBase.Integer = __webpack_require__(10);\n            layoutBase.Point = __webpack_require__(12);\n            layoutBase.PointD = __webpack_require__(5);\n            layoutBase.RandomSeed = __webpack_require__(16);\n            layoutBase.RectangleD = __webpack_require__(13);\n            layoutBase.Transform = __webpack_require__(17);\n            layoutBase.UniqueIDGeneretor = __webpack_require__(14);\n            layoutBase.Quicksort = __webpack_require__(25);\n            layoutBase.LinkedList = __webpack_require__(11);\n            layoutBase.LGraphObject = __webpack_require__(2);\n            layoutBase.LGraph = __webpack_require__(6);\n            layoutBase.LEdge = __webpack_require__(1);\n            layoutBase.LGraphManager = __webpack_require__(7);\n            layoutBase.LNode = __webpack_require__(3);\n            layoutBase.Layout = __webpack_require__(15);\n            layoutBase.LayoutConstants = __webpack_require__(0);\n            layoutBase.NeedlemanWunsch = __webpack_require__(27);\n            layoutBase.Matrix = __webpack_require__(24);\n            layoutBase.SVD = __webpack_require__(26);\n            module2.exports = layoutBase;\n          },\n          /* 29 */\n          /***/\n          function(module2, exports2, __webpack_require__) {\n            \"use strict\";\n            function Emitter() {\n              this.listeners = [];\n            }\n            __name(Emitter, \"Emitter\");\n            var p = Emitter.prototype;\n            p.addListener = function(event, callback) {\n              this.listeners.push({\n                event,\n                callback\n              });\n            };\n            p.removeListener = function(event, callback) {\n              for (var i = this.listeners.length; i >= 0; i--) {\n                var l = this.listeners[i];\n                if (l.event === event && l.callback === callback) {\n                  this.listeners.splice(i, 1);\n                }\n              }\n            };\n            p.emit = function(event, data) {\n              for (var i = 0; i < this.listeners.length; i++) {\n                var l = this.listeners[i];\n                if (event === l.event) {\n                  l.callback(data);\n                }\n              }\n            };\n            module2.exports = Emitter;\n          }\n          /******/\n        ])\n      );\n    });\n  }\n});\n\n// ../../node_modules/.pnpm/cose-base@2.2.0/node_modules/cose-base/cose-base.js\nvar require_cose_base = __commonJS({\n  \"../../node_modules/.pnpm/cose-base@2.2.0/node_modules/cose-base/cose-base.js\"(exports, module) {\n    \"use strict\";\n    (/* @__PURE__ */ __name(function webpackUniversalModuleDefinition(root, factory) {\n      if (typeof exports === \"object\" && typeof module === \"object\")\n        module.exports = factory(require_layout_base());\n      else if (typeof define === \"function\" && define.amd)\n        define([\"layout-base\"], factory);\n      else if (typeof exports === \"object\")\n        exports[\"coseBase\"] = factory(require_layout_base());\n      else\n        root[\"coseBase\"] = factory(root[\"layoutBase\"]);\n    }, \"webpackUniversalModuleDefinition\"))(exports, function(__WEBPACK_EXTERNAL_MODULE__551__) {\n      return (\n        /******/\n        (() => {\n          \"use strict\";\n          var __webpack_modules__ = {\n            /***/\n            45: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var coseBase = {};\n                coseBase.layoutBase = __webpack_require__2(551);\n                coseBase.CoSEConstants = __webpack_require__2(806);\n                coseBase.CoSEEdge = __webpack_require__2(767);\n                coseBase.CoSEGraph = __webpack_require__2(880);\n                coseBase.CoSEGraphManager = __webpack_require__2(578);\n                coseBase.CoSELayout = __webpack_require__2(765);\n                coseBase.CoSENode = __webpack_require__2(991);\n                coseBase.ConstraintHandler = __webpack_require__2(902);\n                module2.exports = coseBase;\n              }\n            ),\n            /***/\n            806: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var FDLayoutConstants = __webpack_require__2(551).FDLayoutConstants;\n                function CoSEConstants() {\n                }\n                __name(CoSEConstants, \"CoSEConstants\");\n                for (var prop in FDLayoutConstants) {\n                  CoSEConstants[prop] = FDLayoutConstants[prop];\n                }\n                CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n                CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n                CoSEConstants.TILE = true;\n                CoSEConstants.TILING_PADDING_VERTICAL = 10;\n                CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n                CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n                CoSEConstants.ENFORCE_CONSTRAINTS = true;\n                CoSEConstants.APPLY_LAYOUT = true;\n                CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\n                CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n                CoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n                module2.exports = CoSEConstants;\n              }\n            ),\n            /***/\n            767: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var FDLayoutEdge = __webpack_require__2(551).FDLayoutEdge;\n                function CoSEEdge(source, target, vEdge) {\n                  FDLayoutEdge.call(this, source, target, vEdge);\n                }\n                __name(CoSEEdge, \"CoSEEdge\");\n                CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n                for (var prop in FDLayoutEdge) {\n                  CoSEEdge[prop] = FDLayoutEdge[prop];\n                }\n                module2.exports = CoSEEdge;\n              }\n            ),\n            /***/\n            880: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var LGraph = __webpack_require__2(551).LGraph;\n                function CoSEGraph(parent, graphMgr, vGraph) {\n                  LGraph.call(this, parent, graphMgr, vGraph);\n                }\n                __name(CoSEGraph, \"CoSEGraph\");\n                CoSEGraph.prototype = Object.create(LGraph.prototype);\n                for (var prop in LGraph) {\n                  CoSEGraph[prop] = LGraph[prop];\n                }\n                module2.exports = CoSEGraph;\n              }\n            ),\n            /***/\n            578: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var LGraphManager = __webpack_require__2(551).LGraphManager;\n                function CoSEGraphManager(layout) {\n                  LGraphManager.call(this, layout);\n                }\n                __name(CoSEGraphManager, \"CoSEGraphManager\");\n                CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n                for (var prop in LGraphManager) {\n                  CoSEGraphManager[prop] = LGraphManager[prop];\n                }\n                module2.exports = CoSEGraphManager;\n              }\n            ),\n            /***/\n            765: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var FDLayout = __webpack_require__2(551).FDLayout;\n                var CoSEGraphManager = __webpack_require__2(578);\n                var CoSEGraph = __webpack_require__2(880);\n                var CoSENode = __webpack_require__2(991);\n                var CoSEEdge = __webpack_require__2(767);\n                var CoSEConstants = __webpack_require__2(806);\n                var ConstraintHandler = __webpack_require__2(902);\n                var FDLayoutConstants = __webpack_require__2(551).FDLayoutConstants;\n                var LayoutConstants = __webpack_require__2(551).LayoutConstants;\n                var Point2 = __webpack_require__2(551).Point;\n                var PointD = __webpack_require__2(551).PointD;\n                var DimensionD2 = __webpack_require__2(551).DimensionD;\n                var Layout2 = __webpack_require__2(551).Layout;\n                var Integer = __webpack_require__2(551).Integer;\n                var IGeometry = __webpack_require__2(551).IGeometry;\n                var LGraph = __webpack_require__2(551).LGraph;\n                var Transform = __webpack_require__2(551).Transform;\n                var LinkedList = __webpack_require__2(551).LinkedList;\n                function CoSELayout() {\n                  FDLayout.call(this);\n                  this.toBeTiled = {};\n                  this.constraints = {};\n                }\n                __name(CoSELayout, \"CoSELayout\");\n                CoSELayout.prototype = Object.create(FDLayout.prototype);\n                for (var prop in FDLayout) {\n                  CoSELayout[prop] = FDLayout[prop];\n                }\n                CoSELayout.prototype.newGraphManager = function() {\n                  var gm = new CoSEGraphManager(this);\n                  this.graphManager = gm;\n                  return gm;\n                };\n                CoSELayout.prototype.newGraph = function(vGraph) {\n                  return new CoSEGraph(null, this.graphManager, vGraph);\n                };\n                CoSELayout.prototype.newNode = function(vNode) {\n                  return new CoSENode(this.graphManager, vNode);\n                };\n                CoSELayout.prototype.newEdge = function(vEdge) {\n                  return new CoSEEdge(null, null, vEdge);\n                };\n                CoSELayout.prototype.initParameters = function() {\n                  FDLayout.prototype.initParameters.call(this, arguments);\n                  if (!this.isSubLayout) {\n                    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n                      this.idealEdgeLength = 10;\n                    } else {\n                      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n                    }\n                    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n                    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n                    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n                    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n                    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n                    this.prunedNodesAll = [];\n                    this.growTreeIterations = 0;\n                    this.afterGrowthIterations = 0;\n                    this.isTreeGrowing = false;\n                    this.isGrowthFinished = false;\n                  }\n                };\n                CoSELayout.prototype.initSpringEmbedder = function() {\n                  FDLayout.prototype.initSpringEmbedder.call(this);\n                  this.coolingCycle = 0;\n                  this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n                  this.finalTemperature = 0.04;\n                  this.coolingAdjuster = 1;\n                };\n                CoSELayout.prototype.layout = function() {\n                  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                  if (createBendsAsNeeded) {\n                    this.createBendpoints();\n                    this.graphManager.resetAllEdges();\n                  }\n                  this.level = 0;\n                  return this.classicLayout();\n                };\n                CoSELayout.prototype.classicLayout = function() {\n                  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n                  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n                  this.calcNoOfChildrenForAllNodes();\n                  this.graphManager.calcLowestCommonAncestors();\n                  this.graphManager.calcInclusionTreeDepths();\n                  this.graphManager.getRoot().calcEstimatedSize();\n                  this.calcIdealEdgeLengths();\n                  if (!this.incremental) {\n                    var forest = this.getFlatForest();\n                    if (forest.length > 0) {\n                      this.positionNodesRadially(forest);\n                    } else {\n                      this.reduceTrees();\n                      this.graphManager.resetAllNodesToApplyGravitation();\n                      var allNodes = new Set(this.getAllNodes());\n                      var intersection = this.nodesWithGravity.filter(function(x) {\n                        return allNodes.has(x);\n                      });\n                      this.graphManager.setAllNodesToApplyGravitation(intersection);\n                      this.positionNodesRandomly();\n                    }\n                  } else {\n                    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n                      this.reduceTrees();\n                      this.graphManager.resetAllNodesToApplyGravitation();\n                      var allNodes = new Set(this.getAllNodes());\n                      var intersection = this.nodesWithGravity.filter(function(x) {\n                        return allNodes.has(x);\n                      });\n                      this.graphManager.setAllNodesToApplyGravitation(intersection);\n                    }\n                  }\n                  if (Object.keys(this.constraints).length > 0) {\n                    ConstraintHandler.handleConstraints(this);\n                    this.initConstraintVariables();\n                  }\n                  this.initSpringEmbedder();\n                  if (CoSEConstants.APPLY_LAYOUT) {\n                    this.runSpringEmbedder();\n                  }\n                  return true;\n                };\n                CoSELayout.prototype.tick = function() {\n                  this.totalIterations++;\n                  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n                    if (this.prunedNodesAll.length > 0) {\n                      this.isTreeGrowing = true;\n                    } else {\n                      return true;\n                    }\n                  }\n                  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n                    if (this.isConverged()) {\n                      if (this.prunedNodesAll.length > 0) {\n                        this.isTreeGrowing = true;\n                      } else {\n                        return true;\n                      }\n                    }\n                    this.coolingCycle++;\n                    if (this.layoutQuality == 0) {\n                      this.coolingAdjuster = this.coolingCycle;\n                    } else if (this.layoutQuality == 1) {\n                      this.coolingAdjuster = this.coolingCycle / 3;\n                    }\n                    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n                    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n                  }\n                  if (this.isTreeGrowing) {\n                    if (this.growTreeIterations % 10 == 0) {\n                      if (this.prunedNodesAll.length > 0) {\n                        this.graphManager.updateBounds();\n                        this.updateGrid();\n                        this.growTree(this.prunedNodesAll);\n                        this.graphManager.resetAllNodesToApplyGravitation();\n                        var allNodes = new Set(this.getAllNodes());\n                        var intersection = this.nodesWithGravity.filter(function(x) {\n                          return allNodes.has(x);\n                        });\n                        this.graphManager.setAllNodesToApplyGravitation(intersection);\n                        this.graphManager.updateBounds();\n                        this.updateGrid();\n                        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;\n                        else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                      } else {\n                        this.isTreeGrowing = false;\n                        this.isGrowthFinished = true;\n                      }\n                    }\n                    this.growTreeIterations++;\n                  }\n                  if (this.isGrowthFinished) {\n                    if (this.isConverged()) {\n                      return true;\n                    }\n                    if (this.afterGrowthIterations % 10 == 0) {\n                      this.graphManager.updateBounds();\n                      this.updateGrid();\n                    }\n                    if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);\n                    else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n                    this.afterGrowthIterations++;\n                  }\n                  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n                  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n                  this.totalDisplacement = 0;\n                  this.graphManager.updateBounds();\n                  this.calcSpringForces();\n                  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                  this.calcGravitationalForces();\n                  this.moveNodes();\n                  this.animate();\n                  return false;\n                };\n                CoSELayout.prototype.getPositionsData = function() {\n                  var allNodes = this.graphManager.getAllNodes();\n                  var pData = {};\n                  for (var i = 0; i < allNodes.length; i++) {\n                    var rect = allNodes[i].rect;\n                    var id = allNodes[i].id;\n                    pData[id] = {\n                      id,\n                      x: rect.getCenterX(),\n                      y: rect.getCenterY(),\n                      w: rect.width,\n                      h: rect.height\n                    };\n                  }\n                  return pData;\n                };\n                CoSELayout.prototype.runSpringEmbedder = function() {\n                  this.initialAnimationPeriod = 25;\n                  this.animationPeriod = this.initialAnimationPeriod;\n                  var layoutEnded = false;\n                  if (FDLayoutConstants.ANIMATE === \"during\") {\n                    this.emit(\"layoutstarted\");\n                  } else {\n                    while (!layoutEnded) {\n                      layoutEnded = this.tick();\n                    }\n                    this.graphManager.updateBounds();\n                  }\n                };\n                CoSELayout.prototype.moveNodes = function() {\n                  var lNodes = this.getAllNodes();\n                  var node;\n                  for (var i = 0; i < lNodes.length; i++) {\n                    node = lNodes[i];\n                    node.calculateDisplacement();\n                  }\n                  if (Object.keys(this.constraints).length > 0) {\n                    this.updateDisplacements();\n                  }\n                  for (var i = 0; i < lNodes.length; i++) {\n                    node = lNodes[i];\n                    node.move();\n                  }\n                };\n                CoSELayout.prototype.initConstraintVariables = function() {\n                  var self = this;\n                  this.idToNodeMap = /* @__PURE__ */ new Map();\n                  this.fixedNodeSet = /* @__PURE__ */ new Set();\n                  var allNodes = this.graphManager.getAllNodes();\n                  for (var i = 0; i < allNodes.length; i++) {\n                    var node = allNodes[i];\n                    this.idToNodeMap.set(node.id, node);\n                  }\n                  var calculateCompoundWeight = /* @__PURE__ */ __name(function calculateCompoundWeight2(compoundNode) {\n                    var nodes = compoundNode.getChild().getNodes();\n                    var node2;\n                    var fixedNodeWeight2 = 0;\n                    for (var i2 = 0; i2 < nodes.length; i2++) {\n                      node2 = nodes[i2];\n                      if (node2.getChild() == null) {\n                        if (self.fixedNodeSet.has(node2.id)) {\n                          fixedNodeWeight2 += 100;\n                        }\n                      } else {\n                        fixedNodeWeight2 += calculateCompoundWeight2(node2);\n                      }\n                    }\n                    return fixedNodeWeight2;\n                  }, \"calculateCompoundWeight\");\n                  if (this.constraints.fixedNodeConstraint) {\n                    this.constraints.fixedNodeConstraint.forEach(function(nodeData2) {\n                      self.fixedNodeSet.add(nodeData2.nodeId);\n                    });\n                    var allNodes = this.graphManager.getAllNodes();\n                    var node;\n                    for (var i = 0; i < allNodes.length; i++) {\n                      node = allNodes[i];\n                      if (node.getChild() != null) {\n                        var fixedNodeWeight = calculateCompoundWeight(node);\n                        if (fixedNodeWeight > 0) {\n                          node.fixedNodeWeight = fixedNodeWeight;\n                        }\n                      }\n                    }\n                  }\n                  if (this.constraints.relativePlacementConstraint) {\n                    var nodeToDummyForVerticalAlignment = /* @__PURE__ */ new Map();\n                    var nodeToDummyForHorizontalAlignment = /* @__PURE__ */ new Map();\n                    this.dummyToNodeForVerticalAlignment = /* @__PURE__ */ new Map();\n                    this.dummyToNodeForHorizontalAlignment = /* @__PURE__ */ new Map();\n                    this.fixedNodesOnHorizontal = /* @__PURE__ */ new Set();\n                    this.fixedNodesOnVertical = /* @__PURE__ */ new Set();\n                    this.fixedNodeSet.forEach(function(nodeId) {\n                      self.fixedNodesOnHorizontal.add(nodeId);\n                      self.fixedNodesOnVertical.add(nodeId);\n                    });\n                    if (this.constraints.alignmentConstraint) {\n                      if (this.constraints.alignmentConstraint.vertical) {\n                        var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n                        for (var i = 0; i < verticalAlignment.length; i++) {\n                          this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n                          verticalAlignment[i].forEach(function(nodeId) {\n                            nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n                            self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n                            if (self.fixedNodeSet.has(nodeId)) {\n                              self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n                            }\n                          });\n                        }\n                      }\n                      if (this.constraints.alignmentConstraint.horizontal) {\n                        var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n                        for (var i = 0; i < horizontalAlignment.length; i++) {\n                          this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n                          horizontalAlignment[i].forEach(function(nodeId) {\n                            nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n                            self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n                            if (self.fixedNodeSet.has(nodeId)) {\n                              self.fixedNodesOnVertical.add(\"dummy\" + i);\n                            }\n                          });\n                        }\n                      }\n                    }\n                    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n                      this.shuffle = function(array) {\n                        var j, x, i2;\n                        for (i2 = array.length - 1; i2 >= 2 * array.length / 3; i2--) {\n                          j = Math.floor(Math.random() * (i2 + 1));\n                          x = array[i2];\n                          array[i2] = array[j];\n                          array[j] = x;\n                        }\n                        return array;\n                      };\n                      this.nodesInRelativeHorizontal = [];\n                      this.nodesInRelativeVertical = [];\n                      this.nodeToRelativeConstraintMapHorizontal = /* @__PURE__ */ new Map();\n                      this.nodeToRelativeConstraintMapVertical = /* @__PURE__ */ new Map();\n                      this.nodeToTempPositionMapHorizontal = /* @__PURE__ */ new Map();\n                      this.nodeToTempPositionMapVertical = /* @__PURE__ */ new Map();\n                      this.constraints.relativePlacementConstraint.forEach(function(constraint) {\n                        if (constraint.left) {\n                          var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                          var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                          if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n                            self.nodesInRelativeHorizontal.push(nodeIdLeft);\n                            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n                            if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n                              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n                            } else {\n                              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n                            }\n                          }\n                          if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n                            self.nodesInRelativeHorizontal.push(nodeIdRight);\n                            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n                            if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n                              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n                            } else {\n                              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n                            }\n                          }\n                          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({ right: nodeIdRight, gap: constraint.gap });\n                          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({ left: nodeIdLeft, gap: constraint.gap });\n                        } else {\n                          var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                          var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                          if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n                            self.nodesInRelativeVertical.push(nodeIdTop);\n                            self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n                            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n                              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n                            } else {\n                              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n                            }\n                          }\n                          if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n                            self.nodesInRelativeVertical.push(nodeIdBottom);\n                            self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n                            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n                              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n                            } else {\n                              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n                            }\n                          }\n                          self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({ bottom: nodeIdBottom, gap: constraint.gap });\n                          self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({ top: nodeIdTop, gap: constraint.gap });\n                        }\n                      });\n                    } else {\n                      var subGraphOnHorizontal = /* @__PURE__ */ new Map();\n                      var subGraphOnVertical = /* @__PURE__ */ new Map();\n                      this.constraints.relativePlacementConstraint.forEach(function(constraint) {\n                        if (constraint.left) {\n                          var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                          var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                          if (subGraphOnHorizontal.has(left)) {\n                            subGraphOnHorizontal.get(left).push(right);\n                          } else {\n                            subGraphOnHorizontal.set(left, [right]);\n                          }\n                          if (subGraphOnHorizontal.has(right)) {\n                            subGraphOnHorizontal.get(right).push(left);\n                          } else {\n                            subGraphOnHorizontal.set(right, [left]);\n                          }\n                        } else {\n                          var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                          var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                          if (subGraphOnVertical.has(top)) {\n                            subGraphOnVertical.get(top).push(bottom);\n                          } else {\n                            subGraphOnVertical.set(top, [bottom]);\n                          }\n                          if (subGraphOnVertical.has(bottom)) {\n                            subGraphOnVertical.get(bottom).push(top);\n                          } else {\n                            subGraphOnVertical.set(bottom, [top]);\n                          }\n                        }\n                      });\n                      var constructComponents = /* @__PURE__ */ __name(function constructComponents2(graph, fixedNodes) {\n                        var components = [];\n                        var isFixed = [];\n                        var queue = new LinkedList();\n                        var visited = /* @__PURE__ */ new Set();\n                        var count = 0;\n                        graph.forEach(function(value, key) {\n                          if (!visited.has(key)) {\n                            components[count] = [];\n                            isFixed[count] = false;\n                            var currentNode = key;\n                            queue.push(currentNode);\n                            visited.add(currentNode);\n                            components[count].push(currentNode);\n                            while (queue.length != 0) {\n                              currentNode = queue.shift();\n                              if (fixedNodes.has(currentNode)) {\n                                isFixed[count] = true;\n                              }\n                              var neighbors = graph.get(currentNode);\n                              neighbors.forEach(function(neighbor) {\n                                if (!visited.has(neighbor)) {\n                                  queue.push(neighbor);\n                                  visited.add(neighbor);\n                                  components[count].push(neighbor);\n                                }\n                              });\n                            }\n                            count++;\n                          }\n                        });\n                        return { components, isFixed };\n                      }, \"constructComponents\");\n                      var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n                      this.componentsOnHorizontal = resultOnHorizontal.components;\n                      this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n                      var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n                      this.componentsOnVertical = resultOnVertical.components;\n                      this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n                    }\n                  }\n                };\n                CoSELayout.prototype.updateDisplacements = function() {\n                  var self = this;\n                  if (this.constraints.fixedNodeConstraint) {\n                    this.constraints.fixedNodeConstraint.forEach(function(nodeData2) {\n                      var fixedNode = self.idToNodeMap.get(nodeData2.nodeId);\n                      fixedNode.displacementX = 0;\n                      fixedNode.displacementY = 0;\n                    });\n                  }\n                  if (this.constraints.alignmentConstraint) {\n                    if (this.constraints.alignmentConstraint.vertical) {\n                      var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n                      for (var i = 0; i < allVerticalAlignments.length; i++) {\n                        var totalDisplacementX = 0;\n                        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n                          if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n                            totalDisplacementX = 0;\n                            break;\n                          }\n                          totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n                        }\n                        var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n                        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n                          this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n                        }\n                      }\n                    }\n                    if (this.constraints.alignmentConstraint.horizontal) {\n                      var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n                      for (var i = 0; i < allHorizontalAlignments.length; i++) {\n                        var totalDisplacementY = 0;\n                        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n                          if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n                            totalDisplacementY = 0;\n                            break;\n                          }\n                          totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n                        }\n                        var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n                        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n                          this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n                        }\n                      }\n                    }\n                  }\n                  if (this.constraints.relativePlacementConstraint) {\n                    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n                      if (this.totalIterations % 10 == 0) {\n                        this.shuffle(this.nodesInRelativeHorizontal);\n                        this.shuffle(this.nodesInRelativeVertical);\n                      }\n                      this.nodesInRelativeHorizontal.forEach(function(nodeId) {\n                        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                          var displacement = 0;\n                          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                            displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n                          } else {\n                            displacement = self.idToNodeMap.get(nodeId).displacementX;\n                          }\n                          self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function(constraint) {\n                            if (constraint.right) {\n                              var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n                              if (diff < constraint.gap) {\n                                displacement -= constraint.gap - diff;\n                              }\n                            } else {\n                              var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n                              if (diff < constraint.gap) {\n                                displacement += constraint.gap - diff;\n                              }\n                            }\n                          });\n                          self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n                          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                            self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function(nodeId2) {\n                              self.idToNodeMap.get(nodeId2).displacementX = displacement;\n                            });\n                          } else {\n                            self.idToNodeMap.get(nodeId).displacementX = displacement;\n                          }\n                        }\n                      });\n                      this.nodesInRelativeVertical.forEach(function(nodeId) {\n                        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                          var displacement = 0;\n                          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                            displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n                          } else {\n                            displacement = self.idToNodeMap.get(nodeId).displacementY;\n                          }\n                          self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function(constraint) {\n                            if (constraint.bottom) {\n                              var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n                              if (diff < constraint.gap) {\n                                displacement -= constraint.gap - diff;\n                              }\n                            } else {\n                              var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n                              if (diff < constraint.gap) {\n                                displacement += constraint.gap - diff;\n                              }\n                            }\n                          });\n                          self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n                          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                            self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function(nodeId2) {\n                              self.idToNodeMap.get(nodeId2).displacementY = displacement;\n                            });\n                          } else {\n                            self.idToNodeMap.get(nodeId).displacementY = displacement;\n                          }\n                        }\n                      });\n                    } else {\n                      for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n                        var component = this.componentsOnHorizontal[i];\n                        if (this.fixedComponentsOnHorizontal[i]) {\n                          for (var j = 0; j < component.length; j++) {\n                            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function(nodeId) {\n                                self.idToNodeMap.get(nodeId).displacementX = 0;\n                              });\n                            } else {\n                              this.idToNodeMap.get(component[j]).displacementX = 0;\n                            }\n                          }\n                        } else {\n                          var sum = 0;\n                          var count = 0;\n                          for (var j = 0; j < component.length; j++) {\n                            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                              var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n                              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n                              count += actualNodes.length;\n                            } else {\n                              sum += this.idToNodeMap.get(component[j]).displacementX;\n                              count++;\n                            }\n                          }\n                          var averageDisplacement = sum / count;\n                          for (var j = 0; j < component.length; j++) {\n                            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function(nodeId) {\n                                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n                              });\n                            } else {\n                              this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n                            }\n                          }\n                        }\n                      }\n                      for (var i = 0; i < this.componentsOnVertical.length; i++) {\n                        var component = this.componentsOnVertical[i];\n                        if (this.fixedComponentsOnVertical[i]) {\n                          for (var j = 0; j < component.length; j++) {\n                            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function(nodeId) {\n                                self.idToNodeMap.get(nodeId).displacementY = 0;\n                              });\n                            } else {\n                              this.idToNodeMap.get(component[j]).displacementY = 0;\n                            }\n                          }\n                        } else {\n                          var sum = 0;\n                          var count = 0;\n                          for (var j = 0; j < component.length; j++) {\n                            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                              var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n                              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n                              count += actualNodes.length;\n                            } else {\n                              sum += this.idToNodeMap.get(component[j]).displacementY;\n                              count++;\n                            }\n                          }\n                          var averageDisplacement = sum / count;\n                          for (var j = 0; j < component.length; j++) {\n                            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function(nodeId) {\n                                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n                              });\n                            } else {\n                              this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                };\n                CoSELayout.prototype.calculateNodesToApplyGravitationTo = function() {\n                  var nodeList = [];\n                  var graph;\n                  var graphs = this.graphManager.getGraphs();\n                  var size = graphs.length;\n                  var i;\n                  for (i = 0; i < size; i++) {\n                    graph = graphs[i];\n                    graph.updateConnected();\n                    if (!graph.isConnected) {\n                      nodeList = nodeList.concat(graph.getNodes());\n                    }\n                  }\n                  return nodeList;\n                };\n                CoSELayout.prototype.createBendpoints = function() {\n                  var edges = [];\n                  edges = edges.concat(this.graphManager.getAllEdges());\n                  var visited = /* @__PURE__ */ new Set();\n                  var i;\n                  for (i = 0; i < edges.length; i++) {\n                    var edge = edges[i];\n                    if (!visited.has(edge)) {\n                      var source = edge.getSource();\n                      var target = edge.getTarget();\n                      if (source == target) {\n                        edge.getBendpoints().push(new PointD());\n                        edge.getBendpoints().push(new PointD());\n                        this.createDummyNodesForBendpoints(edge);\n                        visited.add(edge);\n                      } else {\n                        var edgeList = [];\n                        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n                        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n                        if (!visited.has(edgeList[0])) {\n                          if (edgeList.length > 1) {\n                            var k;\n                            for (k = 0; k < edgeList.length; k++) {\n                              var multiEdge = edgeList[k];\n                              multiEdge.getBendpoints().push(new PointD());\n                              this.createDummyNodesForBendpoints(multiEdge);\n                            }\n                          }\n                          edgeList.forEach(function(edge2) {\n                            visited.add(edge2);\n                          });\n                        }\n                      }\n                    }\n                    if (visited.size == edges.length) {\n                      break;\n                    }\n                  }\n                };\n                CoSELayout.prototype.positionNodesRadially = function(forest) {\n                  var currentStartingPoint = new Point2(0, 0);\n                  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n                  var height = 0;\n                  var currentY = 0;\n                  var currentX = 0;\n                  var point = new PointD(0, 0);\n                  for (var i = 0; i < forest.length; i++) {\n                    if (i % numberOfColumns == 0) {\n                      currentX = 0;\n                      currentY = height;\n                      if (i != 0) {\n                        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n                      }\n                      height = 0;\n                    }\n                    var tree = forest[i];\n                    var centerNode = Layout2.findCenterOfTree(tree);\n                    currentStartingPoint.x = currentX;\n                    currentStartingPoint.y = currentY;\n                    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n                    if (point.y > height) {\n                      height = Math.floor(point.y);\n                    }\n                    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n                  }\n                  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n                };\n                CoSELayout.radialLayout = function(tree, centerNode, startingPoint) {\n                  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n                  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n                  var bounds = LGraph.calculateBounds(tree);\n                  var transform = new Transform();\n                  transform.setDeviceOrgX(bounds.getMinX());\n                  transform.setDeviceOrgY(bounds.getMinY());\n                  transform.setWorldOrgX(startingPoint.x);\n                  transform.setWorldOrgY(startingPoint.y);\n                  for (var i = 0; i < tree.length; i++) {\n                    var node = tree[i];\n                    node.transform(transform);\n                  }\n                  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n                  return transform.inverseTransformPoint(bottomRight);\n                };\n                CoSELayout.branchRadialLayout = function(node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n                  var halfInterval = (endAngle - startAngle + 1) / 2;\n                  if (halfInterval < 0) {\n                    halfInterval += 180;\n                  }\n                  var nodeAngle = (halfInterval + startAngle) % 360;\n                  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n                  var cos_teta = Math.cos(teta);\n                  var x_ = distance * Math.cos(teta);\n                  var y_ = distance * Math.sin(teta);\n                  node.setCenter(x_, y_);\n                  var neighborEdges = [];\n                  neighborEdges = neighborEdges.concat(node.getEdges());\n                  var childCount = neighborEdges.length;\n                  if (parentOfNode != null) {\n                    childCount--;\n                  }\n                  var branchCount = 0;\n                  var incEdgesCount = neighborEdges.length;\n                  var startIndex;\n                  var edges = node.getEdgesBetween(parentOfNode);\n                  while (edges.length > 1) {\n                    var temp = edges[0];\n                    edges.splice(0, 1);\n                    var index = neighborEdges.indexOf(temp);\n                    if (index >= 0) {\n                      neighborEdges.splice(index, 1);\n                    }\n                    incEdgesCount--;\n                    childCount--;\n                  }\n                  if (parentOfNode != null) {\n                    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n                  } else {\n                    startIndex = 0;\n                  }\n                  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n                  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n                    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n                    if (currentNeighbor == parentOfNode) {\n                      continue;\n                    }\n                    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n                    var childEndAngle = (childStartAngle + stepAngle) % 360;\n                    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n                    branchCount++;\n                  }\n                };\n                CoSELayout.maxDiagonalInTree = function(tree) {\n                  var maxDiagonal = Integer.MIN_VALUE;\n                  for (var i = 0; i < tree.length; i++) {\n                    var node = tree[i];\n                    var diagonal = node.getDiagonal();\n                    if (diagonal > maxDiagonal) {\n                      maxDiagonal = diagonal;\n                    }\n                  }\n                  return maxDiagonal;\n                };\n                CoSELayout.prototype.calcRepulsionRange = function() {\n                  return 2 * (this.level + 1) * this.idealEdgeLength;\n                };\n                CoSELayout.prototype.groupZeroDegreeMembers = function() {\n                  var self = this;\n                  var tempMemberGroups = {};\n                  this.memberGroups = {};\n                  this.idToDummyNode = {};\n                  var zeroDegree = [];\n                  var allNodes = this.graphManager.getAllNodes();\n                  for (var i = 0; i < allNodes.length; i++) {\n                    var node = allNodes[i];\n                    var parent = node.getParent();\n                    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == void 0 || !this.getToBeTiled(parent))) {\n                      zeroDegree.push(node);\n                    }\n                  }\n                  for (var i = 0; i < zeroDegree.length; i++) {\n                    var node = zeroDegree[i];\n                    var p_id = node.getParent().id;\n                    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n                    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node);\n                  }\n                  Object.keys(tempMemberGroups).forEach(function(p_id2) {\n                    if (tempMemberGroups[p_id2].length > 1) {\n                      var dummyCompoundId = \"DummyCompound_\" + p_id2;\n                      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id2];\n                      var parent2 = tempMemberGroups[p_id2][0].getParent();\n                      var dummyCompound = new CoSENode(self.graphManager);\n                      dummyCompound.id = dummyCompoundId;\n                      dummyCompound.paddingLeft = parent2.paddingLeft || 0;\n                      dummyCompound.paddingRight = parent2.paddingRight || 0;\n                      dummyCompound.paddingBottom = parent2.paddingBottom || 0;\n                      dummyCompound.paddingTop = parent2.paddingTop || 0;\n                      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n                      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n                      var parentGraph = parent2.getChild();\n                      parentGraph.add(dummyCompound);\n                      for (var i2 = 0; i2 < tempMemberGroups[p_id2].length; i2++) {\n                        var node2 = tempMemberGroups[p_id2][i2];\n                        parentGraph.remove(node2);\n                        dummyParentGraph.add(node2);\n                      }\n                    }\n                  });\n                };\n                CoSELayout.prototype.clearCompounds = function() {\n                  var childGraphMap = {};\n                  var idToNode = {};\n                  this.performDFSOnCompounds();\n                  for (var i = 0; i < this.compoundOrder.length; i++) {\n                    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n                    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n                    this.graphManager.remove(this.compoundOrder[i].getChild());\n                    this.compoundOrder[i].child = null;\n                  }\n                  this.graphManager.resetAllNodes();\n                  this.tileCompoundMembers(childGraphMap, idToNode);\n                };\n                CoSELayout.prototype.clearZeroDegreeMembers = function() {\n                  var self = this;\n                  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n                  Object.keys(this.memberGroups).forEach(function(id) {\n                    var compoundNode = self.idToDummyNode[id];\n                    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n                    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n                    compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n                    compoundNode.labelMarginLeft = 0;\n                    compoundNode.labelMarginTop = 0;\n                    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                      var width = compoundNode.rect.width;\n                      var height = compoundNode.rect.height;\n                      if (compoundNode.labelWidth) {\n                        if (compoundNode.labelPosHorizontal == \"left\") {\n                          compoundNode.rect.x -= compoundNode.labelWidth;\n                          compoundNode.setWidth(width + compoundNode.labelWidth);\n                          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                          compoundNode.setWidth(compoundNode.labelWidth);\n                          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                        } else if (compoundNode.labelPosHorizontal == \"right\") {\n                          compoundNode.setWidth(width + compoundNode.labelWidth);\n                        }\n                      }\n                      if (compoundNode.labelHeight) {\n                        if (compoundNode.labelPosVertical == \"top\") {\n                          compoundNode.rect.y -= compoundNode.labelHeight;\n                          compoundNode.setHeight(height + compoundNode.labelHeight);\n                          compoundNode.labelMarginTop = compoundNode.labelHeight;\n                        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                          compoundNode.setHeight(compoundNode.labelHeight);\n                          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                        } else if (compoundNode.labelPosVertical == \"bottom\") {\n                          compoundNode.setHeight(height + compoundNode.labelHeight);\n                        }\n                      }\n                    }\n                  });\n                };\n                CoSELayout.prototype.repopulateCompounds = function() {\n                  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n                    var lCompoundNode = this.compoundOrder[i];\n                    var id = lCompoundNode.id;\n                    var horizontalMargin = lCompoundNode.paddingLeft;\n                    var verticalMargin = lCompoundNode.paddingTop;\n                    var labelMarginLeft = lCompoundNode.labelMarginLeft;\n                    var labelMarginTop = lCompoundNode.labelMarginTop;\n                    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n                  }\n                };\n                CoSELayout.prototype.repopulateZeroDegreeMembers = function() {\n                  var self = this;\n                  var tiledPack = this.tiledZeroDegreePack;\n                  Object.keys(tiledPack).forEach(function(id) {\n                    var compoundNode = self.idToDummyNode[id];\n                    var horizontalMargin = compoundNode.paddingLeft;\n                    var verticalMargin = compoundNode.paddingTop;\n                    var labelMarginLeft = compoundNode.labelMarginLeft;\n                    var labelMarginTop = compoundNode.labelMarginTop;\n                    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n                  });\n                };\n                CoSELayout.prototype.getToBeTiled = function(node) {\n                  var id = node.id;\n                  if (this.toBeTiled[id] != null) {\n                    return this.toBeTiled[id];\n                  }\n                  var childGraph = node.getChild();\n                  if (childGraph == null) {\n                    this.toBeTiled[id] = false;\n                    return false;\n                  }\n                  var children = childGraph.getNodes();\n                  for (var i = 0; i < children.length; i++) {\n                    var theChild = children[i];\n                    if (this.getNodeDegree(theChild) > 0) {\n                      this.toBeTiled[id] = false;\n                      return false;\n                    }\n                    if (theChild.getChild() == null) {\n                      this.toBeTiled[theChild.id] = false;\n                      continue;\n                    }\n                    if (!this.getToBeTiled(theChild)) {\n                      this.toBeTiled[id] = false;\n                      return false;\n                    }\n                  }\n                  this.toBeTiled[id] = true;\n                  return true;\n                };\n                CoSELayout.prototype.getNodeDegree = function(node) {\n                  var id = node.id;\n                  var edges = node.getEdges();\n                  var degree = 0;\n                  for (var i = 0; i < edges.length; i++) {\n                    var edge = edges[i];\n                    if (edge.getSource().id !== edge.getTarget().id) {\n                      degree = degree + 1;\n                    }\n                  }\n                  return degree;\n                };\n                CoSELayout.prototype.getNodeDegreeWithChildren = function(node) {\n                  var degree = this.getNodeDegree(node);\n                  if (node.getChild() == null) {\n                    return degree;\n                  }\n                  var children = node.getChild().getNodes();\n                  for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    degree += this.getNodeDegreeWithChildren(child);\n                  }\n                  return degree;\n                };\n                CoSELayout.prototype.performDFSOnCompounds = function() {\n                  this.compoundOrder = [];\n                  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n                };\n                CoSELayout.prototype.fillCompexOrderByDFS = function(children) {\n                  for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    if (child.getChild() != null) {\n                      this.fillCompexOrderByDFS(child.getChild().getNodes());\n                    }\n                    if (this.getToBeTiled(child)) {\n                      this.compoundOrder.push(child);\n                    }\n                  }\n                };\n                CoSELayout.prototype.adjustLocations = function(organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n                  x += compoundHorizontalMargin + compoundLabelMarginLeft;\n                  y += compoundVerticalMargin + compoundLabelMarginTop;\n                  var left = x;\n                  for (var i = 0; i < organization.rows.length; i++) {\n                    var row = organization.rows[i];\n                    x = left;\n                    var maxHeight = 0;\n                    for (var j = 0; j < row.length; j++) {\n                      var lnode = row[j];\n                      lnode.rect.x = x;\n                      lnode.rect.y = y;\n                      x += lnode.rect.width + organization.horizontalPadding;\n                      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n                    }\n                    y += maxHeight + organization.verticalPadding;\n                  }\n                };\n                CoSELayout.prototype.tileCompoundMembers = function(childGraphMap, idToNode) {\n                  var self = this;\n                  this.tiledMemberPack = [];\n                  Object.keys(childGraphMap).forEach(function(id) {\n                    var compoundNode = idToNode[id];\n                    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                    compoundNode.rect.width = self.tiledMemberPack[id].width;\n                    compoundNode.rect.height = self.tiledMemberPack[id].height;\n                    compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n                    compoundNode.labelMarginLeft = 0;\n                    compoundNode.labelMarginTop = 0;\n                    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                      var width = compoundNode.rect.width;\n                      var height = compoundNode.rect.height;\n                      if (compoundNode.labelWidth) {\n                        if (compoundNode.labelPosHorizontal == \"left\") {\n                          compoundNode.rect.x -= compoundNode.labelWidth;\n                          compoundNode.setWidth(width + compoundNode.labelWidth);\n                          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                          compoundNode.setWidth(compoundNode.labelWidth);\n                          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                        } else if (compoundNode.labelPosHorizontal == \"right\") {\n                          compoundNode.setWidth(width + compoundNode.labelWidth);\n                        }\n                      }\n                      if (compoundNode.labelHeight) {\n                        if (compoundNode.labelPosVertical == \"top\") {\n                          compoundNode.rect.y -= compoundNode.labelHeight;\n                          compoundNode.setHeight(height + compoundNode.labelHeight);\n                          compoundNode.labelMarginTop = compoundNode.labelHeight;\n                        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                          compoundNode.setHeight(compoundNode.labelHeight);\n                          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                        } else if (compoundNode.labelPosVertical == \"bottom\") {\n                          compoundNode.setHeight(height + compoundNode.labelHeight);\n                        }\n                      }\n                    }\n                  });\n                };\n                CoSELayout.prototype.tileNodes = function(nodes, minWidth) {\n                  var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n                  var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n                  var horizontalRatio = this.getOrgRatio(horizontalOrg);\n                  var verticalRatio = this.getOrgRatio(verticalOrg);\n                  var bestOrg;\n                  if (verticalRatio < horizontalRatio) {\n                    bestOrg = verticalOrg;\n                  } else {\n                    bestOrg = horizontalOrg;\n                  }\n                  return bestOrg;\n                };\n                CoSELayout.prototype.getOrgRatio = function(organization) {\n                  var width = organization.width;\n                  var height = organization.height;\n                  var ratio = width / height;\n                  if (ratio < 1) {\n                    ratio = 1 / ratio;\n                  }\n                  return ratio;\n                };\n                CoSELayout.prototype.calcIdealRowWidth = function(members, favorHorizontalDim) {\n                  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n                  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n                  var membersSize = members.length;\n                  var totalWidth = 0;\n                  var totalHeight = 0;\n                  var maxWidth = 0;\n                  members.forEach(function(node) {\n                    totalWidth += node.getWidth();\n                    totalHeight += node.getHeight();\n                    if (node.getWidth() > maxWidth) {\n                      maxWidth = node.getWidth();\n                    }\n                  });\n                  var averageWidth = totalWidth / membersSize;\n                  var averageHeight = totalHeight / membersSize;\n                  var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n                  var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n                  var horizontalCount;\n                  if (favorHorizontalDim) {\n                    horizontalCount = Math.ceil(horizontalCountDouble);\n                    if (horizontalCount == horizontalCountDouble) {\n                      horizontalCount++;\n                    }\n                  } else {\n                    horizontalCount = Math.floor(horizontalCountDouble);\n                  }\n                  var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n                  if (maxWidth > idealWidth) {\n                    idealWidth = maxWidth;\n                  }\n                  idealWidth += horizontalPadding * 2;\n                  return idealWidth;\n                };\n                CoSELayout.prototype.tileNodesByFavoringDim = function(nodes, minWidth, favorHorizontalDim) {\n                  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n                  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n                  var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n                  var organization = {\n                    rows: [],\n                    rowWidth: [],\n                    rowHeight: [],\n                    width: 0,\n                    height: minWidth,\n                    // assume minHeight equals to minWidth\n                    verticalPadding,\n                    horizontalPadding,\n                    centerX: 0,\n                    centerY: 0\n                  };\n                  if (tilingCompareBy) {\n                    organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n                  }\n                  var getNodeArea = /* @__PURE__ */ __name(function getNodeArea2(n) {\n                    return n.rect.width * n.rect.height;\n                  }, \"getNodeArea\");\n                  var areaCompareFcn = /* @__PURE__ */ __name(function areaCompareFcn2(n1, n2) {\n                    return getNodeArea(n2) - getNodeArea(n1);\n                  }, \"areaCompareFcn\");\n                  nodes.sort(function(n1, n2) {\n                    var cmpBy = areaCompareFcn;\n                    if (organization.idealRowWidth) {\n                      cmpBy = tilingCompareBy;\n                      return cmpBy(n1.id, n2.id);\n                    }\n                    return cmpBy(n1, n2);\n                  });\n                  var sumCenterX = 0;\n                  var sumCenterY = 0;\n                  for (var i = 0; i < nodes.length; i++) {\n                    var lNode = nodes[i];\n                    sumCenterX += lNode.getCenterX();\n                    sumCenterY += lNode.getCenterY();\n                  }\n                  organization.centerX = sumCenterX / nodes.length;\n                  organization.centerY = sumCenterY / nodes.length;\n                  for (var i = 0; i < nodes.length; i++) {\n                    var lNode = nodes[i];\n                    if (organization.rows.length == 0) {\n                      this.insertNodeToRow(organization, lNode, 0, minWidth);\n                    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n                      var rowIndex = organization.rows.length - 1;\n                      if (!organization.idealRowWidth) {\n                        rowIndex = this.getShortestRowIndex(organization);\n                      }\n                      this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n                    } else {\n                      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n                    }\n                    this.shiftToLastRow(organization);\n                  }\n                  return organization;\n                };\n                CoSELayout.prototype.insertNodeToRow = function(organization, node, rowIndex, minWidth) {\n                  var minCompoundSize = minWidth;\n                  if (rowIndex == organization.rows.length) {\n                    var secondDimension = [];\n                    organization.rows.push(secondDimension);\n                    organization.rowWidth.push(minCompoundSize);\n                    organization.rowHeight.push(0);\n                  }\n                  var w = organization.rowWidth[rowIndex] + node.rect.width;\n                  if (organization.rows[rowIndex].length > 0) {\n                    w += organization.horizontalPadding;\n                  }\n                  organization.rowWidth[rowIndex] = w;\n                  if (organization.width < w) {\n                    organization.width = w;\n                  }\n                  var h = node.rect.height;\n                  if (rowIndex > 0) h += organization.verticalPadding;\n                  var extraHeight = 0;\n                  if (h > organization.rowHeight[rowIndex]) {\n                    extraHeight = organization.rowHeight[rowIndex];\n                    organization.rowHeight[rowIndex] = h;\n                    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n                  }\n                  organization.height += extraHeight;\n                  organization.rows[rowIndex].push(node);\n                };\n                CoSELayout.prototype.getShortestRowIndex = function(organization) {\n                  var r = -1;\n                  var min = Number.MAX_VALUE;\n                  for (var i = 0; i < organization.rows.length; i++) {\n                    if (organization.rowWidth[i] < min) {\n                      r = i;\n                      min = organization.rowWidth[i];\n                    }\n                  }\n                  return r;\n                };\n                CoSELayout.prototype.getLongestRowIndex = function(organization) {\n                  var r = -1;\n                  var max = Number.MIN_VALUE;\n                  for (var i = 0; i < organization.rows.length; i++) {\n                    if (organization.rowWidth[i] > max) {\n                      r = i;\n                      max = organization.rowWidth[i];\n                    }\n                  }\n                  return r;\n                };\n                CoSELayout.prototype.canAddHorizontal = function(organization, extraWidth, extraHeight) {\n                  if (organization.idealRowWidth) {\n                    var lastRowIndex = organization.rows.length - 1;\n                    var lastRowWidth = organization.rowWidth[lastRowIndex];\n                    return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n                  }\n                  var sri = this.getShortestRowIndex(organization);\n                  if (sri < 0) {\n                    return true;\n                  }\n                  var min = organization.rowWidth[sri];\n                  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n                  var hDiff = 0;\n                  if (organization.rowHeight[sri] < extraHeight) {\n                    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n                  }\n                  var add_to_row_ratio;\n                  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n                    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n                  } else {\n                    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n                  }\n                  hDiff = extraHeight + organization.verticalPadding;\n                  var add_new_row_ratio;\n                  if (organization.width < extraWidth) {\n                    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n                  } else {\n                    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n                  }\n                  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n                  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n                  return add_to_row_ratio < add_new_row_ratio;\n                };\n                CoSELayout.prototype.shiftToLastRow = function(organization) {\n                  var longest = this.getLongestRowIndex(organization);\n                  var last = organization.rowWidth.length - 1;\n                  var row = organization.rows[longest];\n                  var node = row[row.length - 1];\n                  var diff = node.width + organization.horizontalPadding;\n                  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n                    row.splice(-1, 1);\n                    organization.rows[last].push(node);\n                    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n                    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n                    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n                    var maxHeight = Number.MIN_VALUE;\n                    for (var i = 0; i < row.length; i++) {\n                      if (row[i].height > maxHeight) maxHeight = row[i].height;\n                    }\n                    if (longest > 0) maxHeight += organization.verticalPadding;\n                    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                    organization.rowHeight[longest] = maxHeight;\n                    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n                    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                    organization.height += finalTotal - prevTotal;\n                    this.shiftToLastRow(organization);\n                  }\n                };\n                CoSELayout.prototype.tilingPreLayout = function() {\n                  if (CoSEConstants.TILE) {\n                    this.groupZeroDegreeMembers();\n                    this.clearCompounds();\n                    this.clearZeroDegreeMembers();\n                  }\n                };\n                CoSELayout.prototype.tilingPostLayout = function() {\n                  if (CoSEConstants.TILE) {\n                    this.repopulateZeroDegreeMembers();\n                    this.repopulateCompounds();\n                  }\n                };\n                CoSELayout.prototype.reduceTrees = function() {\n                  var prunedNodesAll = [];\n                  var containsLeaf = true;\n                  var node;\n                  while (containsLeaf) {\n                    var allNodes = this.graphManager.getAllNodes();\n                    var prunedNodesInStepTemp = [];\n                    containsLeaf = false;\n                    for (var i = 0; i < allNodes.length; i++) {\n                      node = allNodes[i];\n                      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n                        if (CoSEConstants.PURE_INCREMENTAL) {\n                          var otherEnd = node.getEdges()[0].getOtherEnd(node);\n                          var relativePosition = new DimensionD2(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n                          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n                        } else {\n                          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n                        }\n                        containsLeaf = true;\n                      }\n                    }\n                    if (containsLeaf == true) {\n                      var prunedNodesInStep = [];\n                      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n                        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n                        }\n                      }\n                      prunedNodesAll.push(prunedNodesInStep);\n                      this.graphManager.resetAllNodes();\n                      this.graphManager.resetAllEdges();\n                    }\n                  }\n                  this.prunedNodesAll = prunedNodesAll;\n                };\n                CoSELayout.prototype.growTree = function(prunedNodesAll) {\n                  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n                  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n                  var nodeData2;\n                  for (var i = 0; i < prunedNodesInStep.length; i++) {\n                    nodeData2 = prunedNodesInStep[i];\n                    this.findPlaceforPrunedNode(nodeData2);\n                    nodeData2[2].add(nodeData2[0]);\n                    nodeData2[2].add(nodeData2[1], nodeData2[1].source, nodeData2[1].target);\n                  }\n                  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n                  this.graphManager.resetAllNodes();\n                  this.graphManager.resetAllEdges();\n                };\n                CoSELayout.prototype.findPlaceforPrunedNode = function(nodeData2) {\n                  var gridForPrunedNode;\n                  var nodeToConnect;\n                  var prunedNode = nodeData2[0];\n                  if (prunedNode == nodeData2[1].source) {\n                    nodeToConnect = nodeData2[1].target;\n                  } else {\n                    nodeToConnect = nodeData2[1].source;\n                  }\n                  if (CoSEConstants.PURE_INCREMENTAL) {\n                    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData2[3].getWidth(), nodeToConnect.getCenterY() + nodeData2[3].getHeight());\n                  } else {\n                    var startGridX = nodeToConnect.startX;\n                    var finishGridX = nodeToConnect.finishX;\n                    var startGridY = nodeToConnect.startY;\n                    var finishGridY = nodeToConnect.finishY;\n                    var upNodeCount = 0;\n                    var downNodeCount = 0;\n                    var rightNodeCount = 0;\n                    var leftNodeCount = 0;\n                    var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n                    if (startGridY > 0) {\n                      for (var i = startGridX; i <= finishGridX; i++) {\n                        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n                      }\n                    }\n                    if (finishGridX < this.grid.length - 1) {\n                      for (var i = startGridY; i <= finishGridY; i++) {\n                        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n                      }\n                    }\n                    if (finishGridY < this.grid[0].length - 1) {\n                      for (var i = startGridX; i <= finishGridX; i++) {\n                        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n                      }\n                    }\n                    if (startGridX > 0) {\n                      for (var i = startGridY; i <= finishGridY; i++) {\n                        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n                      }\n                    }\n                    var min = Integer.MAX_VALUE;\n                    var minCount;\n                    var minIndex;\n                    for (var j = 0; j < controlRegions.length; j++) {\n                      if (controlRegions[j] < min) {\n                        min = controlRegions[j];\n                        minCount = 1;\n                        minIndex = j;\n                      } else if (controlRegions[j] == min) {\n                        minCount++;\n                      }\n                    }\n                    if (minCount == 3 && min == 0) {\n                      if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n                        gridForPrunedNode = 1;\n                      } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n                        gridForPrunedNode = 0;\n                      } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                        gridForPrunedNode = 3;\n                      } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                        gridForPrunedNode = 2;\n                      }\n                    } else if (minCount == 2 && min == 0) {\n                      var random = Math.floor(Math.random() * 2);\n                      if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n                        ;\n                        if (random == 0) {\n                          gridForPrunedNode = 0;\n                        } else {\n                          gridForPrunedNode = 1;\n                        }\n                      } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n                        if (random == 0) {\n                          gridForPrunedNode = 0;\n                        } else {\n                          gridForPrunedNode = 2;\n                        }\n                      } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n                        if (random == 0) {\n                          gridForPrunedNode = 0;\n                        } else {\n                          gridForPrunedNode = 3;\n                        }\n                      } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n                        if (random == 0) {\n                          gridForPrunedNode = 1;\n                        } else {\n                          gridForPrunedNode = 2;\n                        }\n                      } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n                        if (random == 0) {\n                          gridForPrunedNode = 1;\n                        } else {\n                          gridForPrunedNode = 3;\n                        }\n                      } else {\n                        if (random == 0) {\n                          gridForPrunedNode = 2;\n                        } else {\n                          gridForPrunedNode = 3;\n                        }\n                      }\n                    } else if (minCount == 4 && min == 0) {\n                      var random = Math.floor(Math.random() * 4);\n                      gridForPrunedNode = random;\n                    } else {\n                      gridForPrunedNode = minIndex;\n                    }\n                    if (gridForPrunedNode == 0) {\n                      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n                    } else if (gridForPrunedNode == 1) {\n                      prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                    } else if (gridForPrunedNode == 2) {\n                      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n                    } else {\n                      prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                    }\n                  }\n                };\n                module2.exports = CoSELayout;\n              }\n            ),\n            /***/\n            991: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var FDLayoutNode = __webpack_require__2(551).FDLayoutNode;\n                var IMath = __webpack_require__2(551).IMath;\n                function CoSENode(gm, loc, size, vNode) {\n                  FDLayoutNode.call(this, gm, loc, size, vNode);\n                }\n                __name(CoSENode, \"CoSENode\");\n                CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n                for (var prop in FDLayoutNode) {\n                  CoSENode[prop] = FDLayoutNode[prop];\n                }\n                CoSENode.prototype.calculateDisplacement = function() {\n                  var layout = this.graphManager.getLayout();\n                  if (this.getChild() != null && this.fixedNodeWeight) {\n                    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n                    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n                  } else {\n                    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n                    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n                  }\n                  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n                  }\n                  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n                  }\n                  if (this.child && this.child.getNodes().length > 0) {\n                    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n                  }\n                };\n                CoSENode.prototype.propogateDisplacementToChildren = function(dX, dY) {\n                  var nodes = this.getChild().getNodes();\n                  var node;\n                  for (var i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    if (node.getChild() == null) {\n                      node.displacementX += dX;\n                      node.displacementY += dY;\n                    } else {\n                      node.propogateDisplacementToChildren(dX, dY);\n                    }\n                  }\n                };\n                CoSENode.prototype.move = function() {\n                  var layout = this.graphManager.getLayout();\n                  if (this.child == null || this.child.getNodes().length == 0) {\n                    this.moveBy(this.displacementX, this.displacementY);\n                    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n                  }\n                  this.springForceX = 0;\n                  this.springForceY = 0;\n                  this.repulsionForceX = 0;\n                  this.repulsionForceY = 0;\n                  this.gravitationForceX = 0;\n                  this.gravitationForceY = 0;\n                  this.displacementX = 0;\n                  this.displacementY = 0;\n                };\n                CoSENode.prototype.setPred1 = function(pred12) {\n                  this.pred1 = pred12;\n                };\n                CoSENode.prototype.getPred1 = function() {\n                  return pred1;\n                };\n                CoSENode.prototype.getPred2 = function() {\n                  return pred2;\n                };\n                CoSENode.prototype.setNext = function(next2) {\n                  this.next = next2;\n                };\n                CoSENode.prototype.getNext = function() {\n                  return next;\n                };\n                CoSENode.prototype.setProcessed = function(processed2) {\n                  this.processed = processed2;\n                };\n                CoSENode.prototype.isProcessed = function() {\n                  return processed;\n                };\n                module2.exports = CoSENode;\n              }\n            ),\n            /***/\n            902: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                function _toConsumableArray(arr) {\n                  if (Array.isArray(arr)) {\n                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n                      arr2[i] = arr[i];\n                    }\n                    return arr2;\n                  } else {\n                    return Array.from(arr);\n                  }\n                }\n                __name(_toConsumableArray, \"_toConsumableArray\");\n                var CoSEConstants = __webpack_require__2(806);\n                var LinkedList = __webpack_require__2(551).LinkedList;\n                var Matrix = __webpack_require__2(551).Matrix;\n                var SVD = __webpack_require__2(551).SVD;\n                function ConstraintHandler() {\n                }\n                __name(ConstraintHandler, \"ConstraintHandler\");\n                ConstraintHandler.handleConstraints = function(layout) {\n                  var constraints = {};\n                  constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n                  constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n                  constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n                  var idToNodeMap = /* @__PURE__ */ new Map();\n                  var nodeIndexes = /* @__PURE__ */ new Map();\n                  var xCoords = [];\n                  var yCoords = [];\n                  var allNodes = layout.getAllNodes();\n                  var index = 0;\n                  for (var i = 0; i < allNodes.length; i++) {\n                    var node = allNodes[i];\n                    if (node.getChild() == null) {\n                      nodeIndexes.set(node.id, index++);\n                      xCoords.push(node.getCenterX());\n                      yCoords.push(node.getCenterY());\n                      idToNodeMap.set(node.id, node);\n                    }\n                  }\n                  if (constraints.relativePlacementConstraint) {\n                    constraints.relativePlacementConstraint.forEach(function(constraint) {\n                      if (!constraint.gap && constraint.gap != 0) {\n                        if (constraint.left) {\n                          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n                        } else {\n                          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n                        }\n                      }\n                    });\n                  }\n                  var calculatePositionDiff = /* @__PURE__ */ __name(function calculatePositionDiff2(pos1, pos2) {\n                    return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };\n                  }, \"calculatePositionDiff\");\n                  var calculateAvgPosition = /* @__PURE__ */ __name(function calculateAvgPosition2(nodeIdSet) {\n                    var xPosSum = 0;\n                    var yPosSum = 0;\n                    nodeIdSet.forEach(function(nodeId) {\n                      xPosSum += xCoords[nodeIndexes.get(nodeId)];\n                      yPosSum += yCoords[nodeIndexes.get(nodeId)];\n                    });\n                    return { x: xPosSum / nodeIdSet.size, y: yPosSum / nodeIdSet.size };\n                  }, \"calculateAvgPosition\");\n                  var findAppropriatePositionForRelativePlacement = /* @__PURE__ */ __name(function findAppropriatePositionForRelativePlacement2(graph, direction, fixedNodes2, dummyPositions, componentSources) {\n                    function setUnion(setA, setB) {\n                      var union = new Set(setA);\n                      var _iteratorNormalCompletion = true;\n                      var _didIteratorError = false;\n                      var _iteratorError = void 0;\n                      try {\n                        for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                          var elem = _step.value;\n                          union.add(elem);\n                        }\n                      } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                      } finally {\n                        try {\n                          if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                          }\n                        } finally {\n                          if (_didIteratorError) {\n                            throw _iteratorError;\n                          }\n                        }\n                      }\n                      return union;\n                    }\n                    __name(setUnion, \"setUnion\");\n                    var inDegrees = /* @__PURE__ */ new Map();\n                    graph.forEach(function(value, key) {\n                      inDegrees.set(key, 0);\n                    });\n                    graph.forEach(function(value, key) {\n                      value.forEach(function(adjacent) {\n                        inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n                      });\n                    });\n                    var positionMap = /* @__PURE__ */ new Map();\n                    var pastMap = /* @__PURE__ */ new Map();\n                    var queue = new LinkedList();\n                    inDegrees.forEach(function(value, key) {\n                      if (value == 0) {\n                        queue.push(key);\n                        if (!fixedNodes2) {\n                          if (direction == \"horizontal\") {\n                            positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                          } else {\n                            positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                          }\n                        }\n                      } else {\n                        positionMap.set(key, Number.NEGATIVE_INFINITY);\n                      }\n                      if (fixedNodes2) {\n                        pastMap.set(key, /* @__PURE__ */ new Set([key]));\n                      }\n                    });\n                    if (fixedNodes2) {\n                      componentSources.forEach(function(component) {\n                        var fixedIds = [];\n                        component.forEach(function(nodeId) {\n                          if (fixedNodes2.has(nodeId)) {\n                            fixedIds.push(nodeId);\n                          }\n                        });\n                        if (fixedIds.length > 0) {\n                          var position = 0;\n                          fixedIds.forEach(function(fixedId) {\n                            if (direction == \"horizontal\") {\n                              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                              position += positionMap.get(fixedId);\n                            } else {\n                              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                              position += positionMap.get(fixedId);\n                            }\n                          });\n                          position = position / fixedIds.length;\n                          component.forEach(function(nodeId) {\n                            if (!fixedNodes2.has(nodeId)) {\n                              positionMap.set(nodeId, position);\n                            }\n                          });\n                        } else {\n                          var _position = 0;\n                          component.forEach(function(nodeId) {\n                            if (direction == \"horizontal\") {\n                              _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                            } else {\n                              _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                            }\n                          });\n                          _position = _position / component.length;\n                          component.forEach(function(nodeId) {\n                            positionMap.set(nodeId, _position);\n                          });\n                        }\n                      });\n                    }\n                    var _loop = /* @__PURE__ */ __name(function _loop2() {\n                      var currentNode = queue.shift();\n                      var neighbors = graph.get(currentNode);\n                      neighbors.forEach(function(neighbor) {\n                        if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n                          if (fixedNodes2 && fixedNodes2.has(neighbor.id)) {\n                            var fixedPosition = void 0;\n                            if (direction == \"horizontal\") {\n                              fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                            } else {\n                              fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                            }\n                            positionMap.set(neighbor.id, fixedPosition);\n                            if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n                              var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n                              pastMap.get(currentNode).forEach(function(nodeId) {\n                                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n                              });\n                            }\n                          } else {\n                            positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n                          }\n                        }\n                        inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n                        if (inDegrees.get(neighbor.id) == 0) {\n                          queue.push(neighbor.id);\n                        }\n                        if (fixedNodes2) {\n                          pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n                        }\n                      });\n                    }, \"_loop\");\n                    while (queue.length != 0) {\n                      _loop();\n                    }\n                    if (fixedNodes2) {\n                      var sinkNodes = /* @__PURE__ */ new Set();\n                      graph.forEach(function(value, key) {\n                        if (value.length == 0) {\n                          sinkNodes.add(key);\n                        }\n                      });\n                      var _components = [];\n                      pastMap.forEach(function(value, key) {\n                        if (sinkNodes.has(key)) {\n                          var isFixedComponent = false;\n                          var _iteratorNormalCompletion2 = true;\n                          var _didIteratorError2 = false;\n                          var _iteratorError2 = void 0;\n                          try {\n                            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                              var nodeId = _step2.value;\n                              if (fixedNodes2.has(nodeId)) {\n                                isFixedComponent = true;\n                              }\n                            }\n                          } catch (err) {\n                            _didIteratorError2 = true;\n                            _iteratorError2 = err;\n                          } finally {\n                            try {\n                              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                              }\n                            } finally {\n                              if (_didIteratorError2) {\n                                throw _iteratorError2;\n                              }\n                            }\n                          }\n                          if (!isFixedComponent) {\n                            var isExist = false;\n                            var existAt = void 0;\n                            _components.forEach(function(component, index2) {\n                              if (component.has([].concat(_toConsumableArray(value))[0])) {\n                                isExist = true;\n                                existAt = index2;\n                              }\n                            });\n                            if (!isExist) {\n                              _components.push(new Set(value));\n                            } else {\n                              value.forEach(function(ele) {\n                                _components[existAt].add(ele);\n                              });\n                            }\n                          }\n                        }\n                      });\n                      _components.forEach(function(component, index2) {\n                        var minBefore = Number.POSITIVE_INFINITY;\n                        var minAfter = Number.POSITIVE_INFINITY;\n                        var maxBefore = Number.NEGATIVE_INFINITY;\n                        var maxAfter = Number.NEGATIVE_INFINITY;\n                        var _iteratorNormalCompletion3 = true;\n                        var _didIteratorError3 = false;\n                        var _iteratorError3 = void 0;\n                        try {\n                          for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                            var nodeId = _step3.value;\n                            var posBefore = void 0;\n                            if (direction == \"horizontal\") {\n                              posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                            } else {\n                              posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                            }\n                            var posAfter = positionMap.get(nodeId);\n                            if (posBefore < minBefore) {\n                              minBefore = posBefore;\n                            }\n                            if (posBefore > maxBefore) {\n                              maxBefore = posBefore;\n                            }\n                            if (posAfter < minAfter) {\n                              minAfter = posAfter;\n                            }\n                            if (posAfter > maxAfter) {\n                              maxAfter = posAfter;\n                            }\n                          }\n                        } catch (err) {\n                          _didIteratorError3 = true;\n                          _iteratorError3 = err;\n                        } finally {\n                          try {\n                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                              _iterator3.return();\n                            }\n                          } finally {\n                            if (_didIteratorError3) {\n                              throw _iteratorError3;\n                            }\n                          }\n                        }\n                        var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n                        var _iteratorNormalCompletion4 = true;\n                        var _didIteratorError4 = false;\n                        var _iteratorError4 = void 0;\n                        try {\n                          for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                            var _nodeId = _step4.value;\n                            positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n                          }\n                        } catch (err) {\n                          _didIteratorError4 = true;\n                          _iteratorError4 = err;\n                        } finally {\n                          try {\n                            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                              _iterator4.return();\n                            }\n                          } finally {\n                            if (_didIteratorError4) {\n                              throw _iteratorError4;\n                            }\n                          }\n                        }\n                      });\n                    }\n                    return positionMap;\n                  }, \"findAppropriatePositionForRelativePlacement\");\n                  var applyReflectionForRelativePlacement = /* @__PURE__ */ __name(function applyReflectionForRelativePlacement2(relativePlacementConstraints) {\n                    var reflectOnY = 0, notReflectOnY = 0;\n                    var reflectOnX = 0, notReflectOnX = 0;\n                    relativePlacementConstraints.forEach(function(constraint) {\n                      if (constraint.left) {\n                        xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n                      } else {\n                        yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n                      }\n                    });\n                    if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n                      for (var _i = 0; _i < nodeIndexes.size; _i++) {\n                        xCoords[_i] = -1 * xCoords[_i];\n                        yCoords[_i] = -1 * yCoords[_i];\n                      }\n                    } else if (reflectOnY > notReflectOnY) {\n                      for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n                        xCoords[_i2] = -1 * xCoords[_i2];\n                      }\n                    } else if (reflectOnX > notReflectOnX) {\n                      for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n                        yCoords[_i3] = -1 * yCoords[_i3];\n                      }\n                    }\n                  }, \"applyReflectionForRelativePlacement\");\n                  var findComponents = /* @__PURE__ */ __name(function findComponents2(graph) {\n                    var components2 = [];\n                    var queue = new LinkedList();\n                    var visited = /* @__PURE__ */ new Set();\n                    var count = 0;\n                    graph.forEach(function(value, key) {\n                      if (!visited.has(key)) {\n                        components2[count] = [];\n                        var _currentNode = key;\n                        queue.push(_currentNode);\n                        visited.add(_currentNode);\n                        components2[count].push(_currentNode);\n                        while (queue.length != 0) {\n                          _currentNode = queue.shift();\n                          var neighbors = graph.get(_currentNode);\n                          neighbors.forEach(function(neighbor) {\n                            if (!visited.has(neighbor.id)) {\n                              queue.push(neighbor.id);\n                              visited.add(neighbor.id);\n                              components2[count].push(neighbor.id);\n                            }\n                          });\n                        }\n                        count++;\n                      }\n                    });\n                    return components2;\n                  }, \"findComponents\");\n                  var dagToUndirected = /* @__PURE__ */ __name(function dagToUndirected2(dag2) {\n                    var undirected = /* @__PURE__ */ new Map();\n                    dag2.forEach(function(value, key) {\n                      undirected.set(key, []);\n                    });\n                    dag2.forEach(function(value, key) {\n                      value.forEach(function(adjacent) {\n                        undirected.get(key).push(adjacent);\n                        undirected.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n                      });\n                    });\n                    return undirected;\n                  }, \"dagToUndirected\");\n                  var dagToReversed = /* @__PURE__ */ __name(function dagToReversed2(dag2) {\n                    var reversed = /* @__PURE__ */ new Map();\n                    dag2.forEach(function(value, key) {\n                      reversed.set(key, []);\n                    });\n                    dag2.forEach(function(value, key) {\n                      value.forEach(function(adjacent) {\n                        reversed.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n                      });\n                    });\n                    return reversed;\n                  }, \"dagToReversed\");\n                  var targetMatrix = [];\n                  var sourceMatrix = [];\n                  var standardTransformation = false;\n                  var reflectionType = false;\n                  var fixedNodes = /* @__PURE__ */ new Set();\n                  var dag = /* @__PURE__ */ new Map();\n                  var dagUndirected = /* @__PURE__ */ new Map();\n                  var components = [];\n                  if (constraints.fixedNodeConstraint) {\n                    constraints.fixedNodeConstraint.forEach(function(nodeData2) {\n                      fixedNodes.add(nodeData2.nodeId);\n                    });\n                  }\n                  if (constraints.relativePlacementConstraint) {\n                    constraints.relativePlacementConstraint.forEach(function(constraint) {\n                      if (constraint.left) {\n                        if (dag.has(constraint.left)) {\n                          dag.get(constraint.left).push({ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" });\n                        } else {\n                          dag.set(constraint.left, [{ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" }]);\n                        }\n                        if (!dag.has(constraint.right)) {\n                          dag.set(constraint.right, []);\n                        }\n                      } else {\n                        if (dag.has(constraint.top)) {\n                          dag.get(constraint.top).push({ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" });\n                        } else {\n                          dag.set(constraint.top, [{ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" }]);\n                        }\n                        if (!dag.has(constraint.bottom)) {\n                          dag.set(constraint.bottom, []);\n                        }\n                      }\n                    });\n                    dagUndirected = dagToUndirected(dag);\n                    components = findComponents(dagUndirected);\n                  }\n                  if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n                    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n                      constraints.fixedNodeConstraint.forEach(function(nodeData2, i2) {\n                        targetMatrix[i2] = [nodeData2.position.x, nodeData2.position.y];\n                        sourceMatrix[i2] = [xCoords[nodeIndexes.get(nodeData2.nodeId)], yCoords[nodeIndexes.get(nodeData2.nodeId)]];\n                      });\n                      standardTransformation = true;\n                    } else if (constraints.alignmentConstraint) {\n                      (function() {\n                        var count = 0;\n                        if (constraints.alignmentConstraint.vertical) {\n                          var verticalAlign = constraints.alignmentConstraint.vertical;\n                          var _loop2 = /* @__PURE__ */ __name(function _loop22(_i42) {\n                            var alignmentSet = /* @__PURE__ */ new Set();\n                            verticalAlign[_i42].forEach(function(nodeId) {\n                              alignmentSet.add(nodeId);\n                            });\n                            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                              return fixedNodes.has(x);\n                            }));\n                            var xPos = void 0;\n                            if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];\n                            else xPos = calculateAvgPosition(alignmentSet).x;\n                            verticalAlign[_i42].forEach(function(nodeId) {\n                              targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n                              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                              count++;\n                            });\n                          }, \"_loop2\");\n                          for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n                            _loop2(_i4);\n                          }\n                          standardTransformation = true;\n                        }\n                        if (constraints.alignmentConstraint.horizontal) {\n                          var horizontalAlign = constraints.alignmentConstraint.horizontal;\n                          var _loop3 = /* @__PURE__ */ __name(function _loop32(_i52) {\n                            var alignmentSet = /* @__PURE__ */ new Set();\n                            horizontalAlign[_i52].forEach(function(nodeId) {\n                              alignmentSet.add(nodeId);\n                            });\n                            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                              return fixedNodes.has(x);\n                            }));\n                            var yPos = void 0;\n                            if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];\n                            else yPos = calculateAvgPosition(alignmentSet).y;\n                            horizontalAlign[_i52].forEach(function(nodeId) {\n                              targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n                              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                              count++;\n                            });\n                          }, \"_loop3\");\n                          for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n                            _loop3(_i5);\n                          }\n                          standardTransformation = true;\n                        }\n                        if (constraints.relativePlacementConstraint) {\n                          reflectionType = true;\n                        }\n                      })();\n                    } else if (constraints.relativePlacementConstraint) {\n                      var largestComponentSize = 0;\n                      var largestComponentIndex = 0;\n                      for (var _i6 = 0; _i6 < components.length; _i6++) {\n                        if (components[_i6].length > largestComponentSize) {\n                          largestComponentSize = components[_i6].length;\n                          largestComponentIndex = _i6;\n                        }\n                      }\n                      if (largestComponentSize < dagUndirected.size / 2) {\n                        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n                        standardTransformation = false;\n                        reflectionType = false;\n                      } else {\n                        var subGraphOnHorizontal = /* @__PURE__ */ new Map();\n                        var subGraphOnVertical = /* @__PURE__ */ new Map();\n                        var constraintsInlargestComponent = [];\n                        components[largestComponentIndex].forEach(function(nodeId) {\n                          dag.get(nodeId).forEach(function(adjacent) {\n                            if (adjacent.direction == \"horizontal\") {\n                              if (subGraphOnHorizontal.has(nodeId)) {\n                                subGraphOnHorizontal.get(nodeId).push(adjacent);\n                              } else {\n                                subGraphOnHorizontal.set(nodeId, [adjacent]);\n                              }\n                              if (!subGraphOnHorizontal.has(adjacent.id)) {\n                                subGraphOnHorizontal.set(adjacent.id, []);\n                              }\n                              constraintsInlargestComponent.push({ left: nodeId, right: adjacent.id });\n                            } else {\n                              if (subGraphOnVertical.has(nodeId)) {\n                                subGraphOnVertical.get(nodeId).push(adjacent);\n                              } else {\n                                subGraphOnVertical.set(nodeId, [adjacent]);\n                              }\n                              if (!subGraphOnVertical.has(adjacent.id)) {\n                                subGraphOnVertical.set(adjacent.id, []);\n                              }\n                              constraintsInlargestComponent.push({ top: nodeId, bottom: adjacent.id });\n                            }\n                          });\n                        });\n                        applyReflectionForRelativePlacement(constraintsInlargestComponent);\n                        reflectionType = false;\n                        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n                        var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n                        components[largestComponentIndex].forEach(function(nodeId, i2) {\n                          sourceMatrix[i2] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                          targetMatrix[i2] = [];\n                          if (positionMapHorizontal.has(nodeId)) {\n                            targetMatrix[i2][0] = positionMapHorizontal.get(nodeId);\n                          } else {\n                            targetMatrix[i2][0] = xCoords[nodeIndexes.get(nodeId)];\n                          }\n                          if (positionMapVertical.has(nodeId)) {\n                            targetMatrix[i2][1] = positionMapVertical.get(nodeId);\n                          } else {\n                            targetMatrix[i2][1] = yCoords[nodeIndexes.get(nodeId)];\n                          }\n                        });\n                        standardTransformation = true;\n                      }\n                    }\n                    if (standardTransformation) {\n                      var transformationMatrix = void 0;\n                      var targetMatrixTranspose = Matrix.transpose(targetMatrix);\n                      var sourceMatrixTranspose = Matrix.transpose(sourceMatrix);\n                      for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n                        targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n                        sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n                      }\n                      var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose));\n                      var SVDResult = SVD.svd(tempMatrix);\n                      transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U));\n                      for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n                        var temp1 = [xCoords[_i8], yCoords[_i8]];\n                        var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n                        var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n                        xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n                        yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n                      }\n                      if (reflectionType) {\n                        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n                      }\n                    }\n                  }\n                  if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n                    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n                      var translationAmount = { x: 0, y: 0 };\n                      constraints.fixedNodeConstraint.forEach(function(nodeData2, i2) {\n                        var posInTheory = { x: xCoords[nodeIndexes.get(nodeData2.nodeId)], y: yCoords[nodeIndexes.get(nodeData2.nodeId)] };\n                        var posDesired = nodeData2.position;\n                        var posDiff = calculatePositionDiff(posDesired, posInTheory);\n                        translationAmount.x += posDiff.x;\n                        translationAmount.y += posDiff.y;\n                      });\n                      translationAmount.x /= constraints.fixedNodeConstraint.length;\n                      translationAmount.y /= constraints.fixedNodeConstraint.length;\n                      xCoords.forEach(function(value, i2) {\n                        xCoords[i2] += translationAmount.x;\n                      });\n                      yCoords.forEach(function(value, i2) {\n                        yCoords[i2] += translationAmount.y;\n                      });\n                      constraints.fixedNodeConstraint.forEach(function(nodeData2) {\n                        xCoords[nodeIndexes.get(nodeData2.nodeId)] = nodeData2.position.x;\n                        yCoords[nodeIndexes.get(nodeData2.nodeId)] = nodeData2.position.y;\n                      });\n                    }\n                    if (constraints.alignmentConstraint) {\n                      if (constraints.alignmentConstraint.vertical) {\n                        var xAlign = constraints.alignmentConstraint.vertical;\n                        var _loop4 = /* @__PURE__ */ __name(function _loop42(_i92) {\n                          var alignmentSet = /* @__PURE__ */ new Set();\n                          xAlign[_i92].forEach(function(nodeId) {\n                            alignmentSet.add(nodeId);\n                          });\n                          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                            return fixedNodes.has(x);\n                          }));\n                          var xPos = void 0;\n                          if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];\n                          else xPos = calculateAvgPosition(alignmentSet).x;\n                          alignmentSet.forEach(function(nodeId) {\n                            if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n                          });\n                        }, \"_loop4\");\n                        for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n                          _loop4(_i9);\n                        }\n                      }\n                      if (constraints.alignmentConstraint.horizontal) {\n                        var yAlign = constraints.alignmentConstraint.horizontal;\n                        var _loop5 = /* @__PURE__ */ __name(function _loop52(_i102) {\n                          var alignmentSet = /* @__PURE__ */ new Set();\n                          yAlign[_i102].forEach(function(nodeId) {\n                            alignmentSet.add(nodeId);\n                          });\n                          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                            return fixedNodes.has(x);\n                          }));\n                          var yPos = void 0;\n                          if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];\n                          else yPos = calculateAvgPosition(alignmentSet).y;\n                          alignmentSet.forEach(function(nodeId) {\n                            if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n                          });\n                        }, \"_loop5\");\n                        for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n                          _loop5(_i10);\n                        }\n                      }\n                    }\n                    if (constraints.relativePlacementConstraint) {\n                      (function() {\n                        var nodeToDummyForVerticalAlignment = /* @__PURE__ */ new Map();\n                        var nodeToDummyForHorizontalAlignment = /* @__PURE__ */ new Map();\n                        var dummyToNodeForVerticalAlignment = /* @__PURE__ */ new Map();\n                        var dummyToNodeForHorizontalAlignment = /* @__PURE__ */ new Map();\n                        var dummyPositionsForVerticalAlignment = /* @__PURE__ */ new Map();\n                        var dummyPositionsForHorizontalAlignment = /* @__PURE__ */ new Map();\n                        var fixedNodesOnHorizontal = /* @__PURE__ */ new Set();\n                        var fixedNodesOnVertical = /* @__PURE__ */ new Set();\n                        fixedNodes.forEach(function(nodeId2) {\n                          fixedNodesOnHorizontal.add(nodeId2);\n                          fixedNodesOnVertical.add(nodeId2);\n                        });\n                        if (constraints.alignmentConstraint) {\n                          if (constraints.alignmentConstraint.vertical) {\n                            var verticalAlignment = constraints.alignmentConstraint.vertical;\n                            var _loop6 = /* @__PURE__ */ __name(function _loop62(_i112) {\n                              dummyToNodeForVerticalAlignment.set(\"dummy\" + _i112, []);\n                              verticalAlignment[_i112].forEach(function(nodeId2) {\n                                nodeToDummyForVerticalAlignment.set(nodeId2, \"dummy\" + _i112);\n                                dummyToNodeForVerticalAlignment.get(\"dummy\" + _i112).push(nodeId2);\n                                if (fixedNodes.has(nodeId2)) {\n                                  fixedNodesOnHorizontal.add(\"dummy\" + _i112);\n                                }\n                              });\n                              dummyPositionsForVerticalAlignment.set(\"dummy\" + _i112, xCoords[nodeIndexes.get(verticalAlignment[_i112][0])]);\n                            }, \"_loop6\");\n                            for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n                              _loop6(_i11);\n                            }\n                          }\n                          if (constraints.alignmentConstraint.horizontal) {\n                            var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n                            var _loop7 = /* @__PURE__ */ __name(function _loop72(_i122) {\n                              dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i122, []);\n                              horizontalAlignment[_i122].forEach(function(nodeId2) {\n                                nodeToDummyForHorizontalAlignment.set(nodeId2, \"dummy\" + _i122);\n                                dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i122).push(nodeId2);\n                                if (fixedNodes.has(nodeId2)) {\n                                  fixedNodesOnVertical.add(\"dummy\" + _i122);\n                                }\n                              });\n                              dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i122, yCoords[nodeIndexes.get(horizontalAlignment[_i122][0])]);\n                            }, \"_loop7\");\n                            for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n                              _loop7(_i12);\n                            }\n                          }\n                        }\n                        var dagOnHorizontal = /* @__PURE__ */ new Map();\n                        var dagOnVertical = /* @__PURE__ */ new Map();\n                        var _loop8 = /* @__PURE__ */ __name(function _loop82(nodeId2) {\n                          dag.get(nodeId2).forEach(function(adjacent) {\n                            var sourceId = void 0;\n                            var targetNode = void 0;\n                            if (adjacent[\"direction\"] == \"horizontal\") {\n                              sourceId = nodeToDummyForVerticalAlignment.get(nodeId2) ? nodeToDummyForVerticalAlignment.get(nodeId2) : nodeId2;\n                              if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                                targetNode = { id: nodeToDummyForVerticalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n                              } else {\n                                targetNode = adjacent;\n                              }\n                              if (dagOnHorizontal.has(sourceId)) {\n                                dagOnHorizontal.get(sourceId).push(targetNode);\n                              } else {\n                                dagOnHorizontal.set(sourceId, [targetNode]);\n                              }\n                              if (!dagOnHorizontal.has(targetNode.id)) {\n                                dagOnHorizontal.set(targetNode.id, []);\n                              }\n                            } else {\n                              sourceId = nodeToDummyForHorizontalAlignment.get(nodeId2) ? nodeToDummyForHorizontalAlignment.get(nodeId2) : nodeId2;\n                              if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                                targetNode = { id: nodeToDummyForHorizontalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n                              } else {\n                                targetNode = adjacent;\n                              }\n                              if (dagOnVertical.has(sourceId)) {\n                                dagOnVertical.get(sourceId).push(targetNode);\n                              } else {\n                                dagOnVertical.set(sourceId, [targetNode]);\n                              }\n                              if (!dagOnVertical.has(targetNode.id)) {\n                                dagOnVertical.set(targetNode.id, []);\n                              }\n                            }\n                          });\n                        }, \"_loop8\");\n                        var _iteratorNormalCompletion5 = true;\n                        var _didIteratorError5 = false;\n                        var _iteratorError5 = void 0;\n                        try {\n                          for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                            var nodeId = _step5.value;\n                            _loop8(nodeId);\n                          }\n                        } catch (err) {\n                          _didIteratorError5 = true;\n                          _iteratorError5 = err;\n                        } finally {\n                          try {\n                            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                              _iterator5.return();\n                            }\n                          } finally {\n                            if (_didIteratorError5) {\n                              throw _iteratorError5;\n                            }\n                          }\n                        }\n                        var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n                        var undirectedOnVertical = dagToUndirected(dagOnVertical);\n                        var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n                        var componentsOnVertical = findComponents(undirectedOnVertical);\n                        var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n                        var reversedDagOnVertical = dagToReversed(dagOnVertical);\n                        var componentSourcesOnHorizontal = [];\n                        var componentSourcesOnVertical = [];\n                        componentsOnHorizontal.forEach(function(component, index2) {\n                          componentSourcesOnHorizontal[index2] = [];\n                          component.forEach(function(nodeId2) {\n                            if (reversedDagOnHorizontal.get(nodeId2).length == 0) {\n                              componentSourcesOnHorizontal[index2].push(nodeId2);\n                            }\n                          });\n                        });\n                        componentsOnVertical.forEach(function(component, index2) {\n                          componentSourcesOnVertical[index2] = [];\n                          component.forEach(function(nodeId2) {\n                            if (reversedDagOnVertical.get(nodeId2).length == 0) {\n                              componentSourcesOnVertical[index2].push(nodeId2);\n                            }\n                          });\n                        });\n                        var positionMapHorizontal2 = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n                        var positionMapVertical2 = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n                        var _loop9 = /* @__PURE__ */ __name(function _loop92(key2) {\n                          if (dummyToNodeForVerticalAlignment.get(key2)) {\n                            dummyToNodeForVerticalAlignment.get(key2).forEach(function(nodeId2) {\n                              xCoords[nodeIndexes.get(nodeId2)] = positionMapHorizontal2.get(key2);\n                            });\n                          } else {\n                            xCoords[nodeIndexes.get(key2)] = positionMapHorizontal2.get(key2);\n                          }\n                        }, \"_loop9\");\n                        var _iteratorNormalCompletion6 = true;\n                        var _didIteratorError6 = false;\n                        var _iteratorError6 = void 0;\n                        try {\n                          for (var _iterator6 = positionMapHorizontal2.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                            var key = _step6.value;\n                            _loop9(key);\n                          }\n                        } catch (err) {\n                          _didIteratorError6 = true;\n                          _iteratorError6 = err;\n                        } finally {\n                          try {\n                            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                              _iterator6.return();\n                            }\n                          } finally {\n                            if (_didIteratorError6) {\n                              throw _iteratorError6;\n                            }\n                          }\n                        }\n                        var _loop10 = /* @__PURE__ */ __name(function _loop102(key2) {\n                          if (dummyToNodeForHorizontalAlignment.get(key2)) {\n                            dummyToNodeForHorizontalAlignment.get(key2).forEach(function(nodeId2) {\n                              yCoords[nodeIndexes.get(nodeId2)] = positionMapVertical2.get(key2);\n                            });\n                          } else {\n                            yCoords[nodeIndexes.get(key2)] = positionMapVertical2.get(key2);\n                          }\n                        }, \"_loop10\");\n                        var _iteratorNormalCompletion7 = true;\n                        var _didIteratorError7 = false;\n                        var _iteratorError7 = void 0;\n                        try {\n                          for (var _iterator7 = positionMapVertical2.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                            var key = _step7.value;\n                            _loop10(key);\n                          }\n                        } catch (err) {\n                          _didIteratorError7 = true;\n                          _iteratorError7 = err;\n                        } finally {\n                          try {\n                            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                              _iterator7.return();\n                            }\n                          } finally {\n                            if (_didIteratorError7) {\n                              throw _iteratorError7;\n                            }\n                          }\n                        }\n                      })();\n                    }\n                  }\n                  for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n                    var _node = allNodes[_i13];\n                    if (_node.getChild() == null) {\n                      _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n                    }\n                  }\n                };\n                module2.exports = ConstraintHandler;\n              }\n            ),\n            /***/\n            551: (\n              /***/\n              (module2) => {\n                module2.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n              }\n            )\n            /******/\n          };\n          var __webpack_module_cache__ = {};\n          function __webpack_require__(moduleId) {\n            var cachedModule = __webpack_module_cache__[moduleId];\n            if (cachedModule !== void 0) {\n              return cachedModule.exports;\n            }\n            var module2 = __webpack_module_cache__[moduleId] = {\n              /******/\n              // no module.id needed\n              /******/\n              // no module.loaded needed\n              /******/\n              exports: {}\n              /******/\n            };\n            __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);\n            return module2.exports;\n          }\n          __name(__webpack_require__, \"__webpack_require__\");\n          var __webpack_exports__ = __webpack_require__(45);\n          return __webpack_exports__;\n        })()\n      );\n    });\n  }\n});\n\n// ../../node_modules/.pnpm/cytoscape-fcose@2.2.0_cytoscape@3.31.0/node_modules/cytoscape-fcose/cytoscape-fcose.js\nvar require_cytoscape_fcose = __commonJS({\n  \"../../node_modules/.pnpm/cytoscape-fcose@2.2.0_cytoscape@3.31.0/node_modules/cytoscape-fcose/cytoscape-fcose.js\"(exports, module) {\n    \"use strict\";\n    (/* @__PURE__ */ __name(function webpackUniversalModuleDefinition(root, factory) {\n      if (typeof exports === \"object\" && typeof module === \"object\")\n        module.exports = factory(require_cose_base());\n      else if (typeof define === \"function\" && define.amd)\n        define([\"cose-base\"], factory);\n      else if (typeof exports === \"object\")\n        exports[\"cytoscapeFcose\"] = factory(require_cose_base());\n      else\n        root[\"cytoscapeFcose\"] = factory(root[\"coseBase\"]);\n    }, \"webpackUniversalModuleDefinition\"))(exports, function(__WEBPACK_EXTERNAL_MODULE__140__) {\n      return (\n        /******/\n        (() => {\n          \"use strict\";\n          var __webpack_modules__ = {\n            /***/\n            658: (\n              /***/\n              (module2) => {\n                module2.exports = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {\n                  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                    srcs[_key - 1] = arguments[_key];\n                  }\n                  srcs.forEach(function(src) {\n                    Object.keys(src).forEach(function(k) {\n                      return tgt[k] = src[k];\n                    });\n                  });\n                  return tgt;\n                };\n              }\n            ),\n            /***/\n            548: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var _slicedToArray = /* @__PURE__ */ function() {\n                  function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = void 0;\n                    try {\n                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                      }\n                    } catch (err) {\n                      _d = true;\n                      _e = err;\n                    } finally {\n                      try {\n                        if (!_n && _i[\"return\"]) _i[\"return\"]();\n                      } finally {\n                        if (_d) throw _e;\n                      }\n                    }\n                    return _arr;\n                  }\n                  __name(sliceIterator, \"sliceIterator\");\n                  return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                      return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                      return sliceIterator(arr, i);\n                    } else {\n                      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                  };\n                }();\n                var LinkedList = __webpack_require__2(140).layoutBase.LinkedList;\n                var auxiliary = {};\n                auxiliary.getTopMostNodes = function(nodes) {\n                  var nodesMap = {};\n                  for (var i = 0; i < nodes.length; i++) {\n                    nodesMap[nodes[i].id()] = true;\n                  }\n                  var roots = nodes.filter(function(ele, i2) {\n                    if (typeof ele === \"number\") {\n                      ele = i2;\n                    }\n                    var parent = ele.parent()[0];\n                    while (parent != null) {\n                      if (nodesMap[parent.id()]) {\n                        return false;\n                      }\n                      parent = parent.parent()[0];\n                    }\n                    return true;\n                  });\n                  return roots;\n                };\n                auxiliary.connectComponents = function(cy, eles, topMostNodes, dummyNodes) {\n                  var queue = new LinkedList();\n                  var visited = /* @__PURE__ */ new Set();\n                  var visitedTopMostNodes = [];\n                  var currentNeighbor = void 0;\n                  var minDegreeNode = void 0;\n                  var minDegree = void 0;\n                  var isConnected = false;\n                  var count = 1;\n                  var nodesConnectedToDummy = [];\n                  var components = [];\n                  var _loop = /* @__PURE__ */ __name(function _loop2() {\n                    var cmpt = cy.collection();\n                    components.push(cmpt);\n                    var currentNode = topMostNodes[0];\n                    var childrenOfCurrentNode = cy.collection();\n                    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n                    visitedTopMostNodes.push(currentNode);\n                    childrenOfCurrentNode.forEach(function(node) {\n                      queue.push(node);\n                      visited.add(node);\n                      cmpt.merge(node);\n                    });\n                    var _loop22 = /* @__PURE__ */ __name(function _loop23() {\n                      currentNode = queue.shift();\n                      var neighborNodes = cy.collection();\n                      currentNode.neighborhood().nodes().forEach(function(node) {\n                        if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n                          neighborNodes.merge(node);\n                        }\n                      });\n                      for (var i = 0; i < neighborNodes.length; i++) {\n                        var neighborNode = neighborNodes[i];\n                        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n                        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n                          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n                          childrenOfNeighbor.forEach(function(node) {\n                            queue.push(node);\n                            visited.add(node);\n                            cmpt.merge(node);\n                            if (topMostNodes.has(node)) {\n                              visitedTopMostNodes.push(node);\n                            }\n                          });\n                        }\n                      }\n                    }, \"_loop2\");\n                    while (queue.length != 0) {\n                      _loop22();\n                    }\n                    cmpt.forEach(function(node) {\n                      eles.intersection(node.connectedEdges()).forEach(function(e) {\n                        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n                          cmpt.merge(e);\n                        }\n                      });\n                    });\n                    if (visitedTopMostNodes.length == topMostNodes.length) {\n                      isConnected = true;\n                    }\n                    if (!isConnected || isConnected && count > 1) {\n                      minDegreeNode = visitedTopMostNodes[0];\n                      minDegree = minDegreeNode.connectedEdges().length;\n                      visitedTopMostNodes.forEach(function(node) {\n                        if (node.connectedEdges().length < minDegree) {\n                          minDegree = node.connectedEdges().length;\n                          minDegreeNode = node;\n                        }\n                      });\n                      nodesConnectedToDummy.push(minDegreeNode.id());\n                      var temp = cy.collection();\n                      temp.merge(visitedTopMostNodes[0]);\n                      visitedTopMostNodes.forEach(function(node) {\n                        temp.merge(node);\n                      });\n                      visitedTopMostNodes = [];\n                      topMostNodes = topMostNodes.difference(temp);\n                      count++;\n                    }\n                  }, \"_loop\");\n                  do {\n                    _loop();\n                  } while (!isConnected);\n                  if (dummyNodes) {\n                    if (nodesConnectedToDummy.length > 0) {\n                      dummyNodes.set(\"dummy\" + (dummyNodes.size + 1), nodesConnectedToDummy);\n                    }\n                  }\n                  return components;\n                };\n                auxiliary.relocateComponent = function(originalCenter, componentResult, options) {\n                  if (!options.fixedNodeConstraint) {\n                    var minXCoord = Number.POSITIVE_INFINITY;\n                    var maxXCoord = Number.NEGATIVE_INFINITY;\n                    var minYCoord = Number.POSITIVE_INFINITY;\n                    var maxYCoord = Number.NEGATIVE_INFINITY;\n                    if (options.quality == \"draft\") {\n                      var _iteratorNormalCompletion = true;\n                      var _didIteratorError = false;\n                      var _iteratorError = void 0;\n                      try {\n                        for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                          var _ref = _step.value;\n                          var _ref2 = _slicedToArray(_ref, 2);\n                          var key = _ref2[0];\n                          var value = _ref2[1];\n                          var cyNode = options.cy.getElementById(key);\n                          if (cyNode) {\n                            var nodeBB = cyNode.boundingBox();\n                            var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n                            var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n                            var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n                            var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n                            if (leftX < minXCoord) minXCoord = leftX;\n                            if (rightX > maxXCoord) maxXCoord = rightX;\n                            if (topY < minYCoord) minYCoord = topY;\n                            if (bottomY > maxYCoord) maxYCoord = bottomY;\n                          }\n                        }\n                      } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                      } finally {\n                        try {\n                          if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                          }\n                        } finally {\n                          if (_didIteratorError) {\n                            throw _iteratorError;\n                          }\n                        }\n                      }\n                      var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n                      var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n                      componentResult.xCoords = componentResult.xCoords.map(function(x) {\n                        return x + diffOnX;\n                      });\n                      componentResult.yCoords = componentResult.yCoords.map(function(y) {\n                        return y + diffOnY;\n                      });\n                    } else {\n                      Object.keys(componentResult).forEach(function(item) {\n                        var node = componentResult[item];\n                        var leftX2 = node.getRect().x;\n                        var rightX2 = node.getRect().x + node.getRect().width;\n                        var topY2 = node.getRect().y;\n                        var bottomY2 = node.getRect().y + node.getRect().height;\n                        if (leftX2 < minXCoord) minXCoord = leftX2;\n                        if (rightX2 > maxXCoord) maxXCoord = rightX2;\n                        if (topY2 < minYCoord) minYCoord = topY2;\n                        if (bottomY2 > maxYCoord) maxYCoord = bottomY2;\n                      });\n                      var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n                      var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n                      Object.keys(componentResult).forEach(function(item) {\n                        var node = componentResult[item];\n                        node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n                      });\n                    }\n                  }\n                };\n                auxiliary.calcBoundingBox = function(parentNode, xCoords, yCoords, nodeIndexes) {\n                  var left = Number.MAX_SAFE_INTEGER;\n                  var right = Number.MIN_SAFE_INTEGER;\n                  var top = Number.MAX_SAFE_INTEGER;\n                  var bottom = Number.MIN_SAFE_INTEGER;\n                  var nodeLeft = void 0;\n                  var nodeRight = void 0;\n                  var nodeTop = void 0;\n                  var nodeBottom = void 0;\n                  var nodes = parentNode.descendants().not(\":parent\");\n                  var s = nodes.length;\n                  for (var i = 0; i < s; i++) {\n                    var node = nodes[i];\n                    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n                    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n                    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n                    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n                    if (left > nodeLeft) {\n                      left = nodeLeft;\n                    }\n                    if (right < nodeRight) {\n                      right = nodeRight;\n                    }\n                    if (top > nodeTop) {\n                      top = nodeTop;\n                    }\n                    if (bottom < nodeBottom) {\n                      bottom = nodeBottom;\n                    }\n                  }\n                  var boundingBox = {};\n                  boundingBox.topLeftX = left;\n                  boundingBox.topLeftY = top;\n                  boundingBox.width = right - left;\n                  boundingBox.height = bottom - top;\n                  return boundingBox;\n                };\n                auxiliary.calcParentsWithoutChildren = function(cy, eles) {\n                  var parentsWithoutChildren = cy.collection();\n                  eles.nodes(\":parent\").forEach(function(parent) {\n                    var check = false;\n                    parent.children().forEach(function(child) {\n                      if (child.css(\"display\") != \"none\") {\n                        check = true;\n                      }\n                    });\n                    if (!check) {\n                      parentsWithoutChildren.merge(parent);\n                    }\n                  });\n                  return parentsWithoutChildren;\n                };\n                module2.exports = auxiliary;\n              }\n            ),\n            /***/\n            816: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var aux = __webpack_require__2(548);\n                var CoSELayout = __webpack_require__2(140).CoSELayout;\n                var CoSENode = __webpack_require__2(140).CoSENode;\n                var PointD = __webpack_require__2(140).layoutBase.PointD;\n                var DimensionD2 = __webpack_require__2(140).layoutBase.DimensionD;\n                var LayoutConstants = __webpack_require__2(140).layoutBase.LayoutConstants;\n                var FDLayoutConstants = __webpack_require__2(140).layoutBase.FDLayoutConstants;\n                var CoSEConstants = __webpack_require__2(140).CoSEConstants;\n                var coseLayout = /* @__PURE__ */ __name(function coseLayout2(options, spectralResult) {\n                  var cy = options.cy;\n                  var eles = options.eles;\n                  var nodes = eles.nodes();\n                  var edges = eles.edges();\n                  var nodeIndexes = void 0;\n                  var xCoords = void 0;\n                  var yCoords = void 0;\n                  var idToLNode = {};\n                  if (options.randomize) {\n                    nodeIndexes = spectralResult[\"nodeIndexes\"];\n                    xCoords = spectralResult[\"xCoords\"];\n                    yCoords = spectralResult[\"yCoords\"];\n                  }\n                  var isFn = /* @__PURE__ */ __name(function isFn2(fn) {\n                    return typeof fn === \"function\";\n                  }, \"isFn\");\n                  var optFn = /* @__PURE__ */ __name(function optFn2(opt, ele) {\n                    if (isFn(opt)) {\n                      return opt(ele);\n                    } else {\n                      return opt;\n                    }\n                  }, \"optFn\");\n                  var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n                  var processChildrenList = /* @__PURE__ */ __name(function processChildrenList2(parent, children, layout, options2) {\n                    var size = children.length;\n                    for (var i = 0; i < size; i++) {\n                      var theChild = children[i];\n                      var children_of_children = null;\n                      if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                        children_of_children = theChild.children();\n                      }\n                      var theNode = void 0;\n                      var dimensions = theChild.layoutDimensions({\n                        nodeDimensionsIncludeLabels: options2.nodeDimensionsIncludeLabels\n                      });\n                      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n                        if (options2.randomize) {\n                          if (!theChild.isParent()) {\n                            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD2(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                          } else {\n                            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n                            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD2(parentInfo.width, parentInfo.height)));\n                            } else {\n                              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD2(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                            }\n                          }\n                        } else {\n                          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position(\"x\") - dimensions.w / 2, theChild.position(\"y\") - dimensions.h / 2), new DimensionD2(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                        }\n                      } else {\n                        theNode = parent.add(new CoSENode(this.graphManager));\n                      }\n                      theNode.id = theChild.data(\"id\");\n                      theNode.nodeRepulsion = optFn(options2.nodeRepulsion, theChild);\n                      theNode.paddingLeft = parseInt(theChild.css(\"padding\"));\n                      theNode.paddingTop = parseInt(theChild.css(\"padding\"));\n                      theNode.paddingRight = parseInt(theChild.css(\"padding\"));\n                      theNode.paddingBottom = parseInt(theChild.css(\"padding\"));\n                      if (options2.nodeDimensionsIncludeLabels) {\n                        theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;\n                        theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;\n                        theNode.labelPosVertical = theChild.css(\"text-valign\");\n                        theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n                      }\n                      idToLNode[theChild.data(\"id\")] = theNode;\n                      if (isNaN(theNode.rect.x)) {\n                        theNode.rect.x = 0;\n                      }\n                      if (isNaN(theNode.rect.y)) {\n                        theNode.rect.y = 0;\n                      }\n                      if (children_of_children != null && children_of_children.length > 0) {\n                        var theNewGraph = void 0;\n                        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n                        processChildrenList2(theNewGraph, children_of_children, layout, options2);\n                      }\n                    }\n                  }, \"processChildrenList\");\n                  var processEdges = /* @__PURE__ */ __name(function processEdges2(layout, gm2, edges2) {\n                    var idealLengthTotal = 0;\n                    var edgeCount = 0;\n                    for (var i = 0; i < edges2.length; i++) {\n                      var edge = edges2[i];\n                      var sourceNode = idToLNode[edge.data(\"source\")];\n                      var targetNode = idToLNode[edge.data(\"target\")];\n                      if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n                        var e1 = gm2.add(layout.newEdge(), sourceNode, targetNode);\n                        e1.id = edge.id();\n                        e1.idealLength = optFn(options.idealEdgeLength, edge);\n                        e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n                        idealLengthTotal += e1.idealLength;\n                        edgeCount++;\n                      }\n                    }\n                    if (options.idealEdgeLength != null) {\n                      if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;\n                      else if (!isFn(options.idealEdgeLength))\n                        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n                      else\n                        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n                      CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10;\n                      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                    }\n                  }, \"processEdges\");\n                  var processConstraints = /* @__PURE__ */ __name(function processConstraints2(layout, options2) {\n                    if (options2.fixedNodeConstraint) {\n                      layout.constraints[\"fixedNodeConstraint\"] = options2.fixedNodeConstraint;\n                    }\n                    if (options2.alignmentConstraint) {\n                      layout.constraints[\"alignmentConstraint\"] = options2.alignmentConstraint;\n                    }\n                    if (options2.relativePlacementConstraint) {\n                      layout.constraints[\"relativePlacementConstraint\"] = options2.relativePlacementConstraint;\n                    }\n                  }, \"processConstraints\");\n                  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n                  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n                  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n                  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n                  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n                  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n                  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n                  if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n                  if (options.quality == \"proof\") LayoutConstants.QUALITY = 2;\n                  else LayoutConstants.QUALITY = 0;\n                  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n                  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n                  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n                  CoSEConstants.TILE = options.tile;\n                  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === \"function\" ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n                  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === \"function\" ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n                  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n                  CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n                  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n                  if (options.step == \"transformed\") {\n                    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n                    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n                    CoSEConstants.APPLY_LAYOUT = false;\n                  }\n                  if (options.step == \"enforced\") {\n                    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n                    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n                    CoSEConstants.APPLY_LAYOUT = false;\n                  }\n                  if (options.step == \"cose\") {\n                    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n                    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n                    CoSEConstants.APPLY_LAYOUT = true;\n                  }\n                  if (options.step == \"all\") {\n                    if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n                    else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n                    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n                    CoSEConstants.APPLY_LAYOUT = true;\n                  }\n                  if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n                    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n                  } else {\n                    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n                  }\n                  var coseLayout3 = new CoSELayout();\n                  var gm = coseLayout3.newGraphManager();\n                  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout3, options);\n                  processEdges(coseLayout3, gm, edges);\n                  processConstraints(coseLayout3, options);\n                  coseLayout3.runLayout();\n                  return idToLNode;\n                }, \"coseLayout\");\n                module2.exports = { coseLayout };\n              }\n            ),\n            /***/\n            212: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var _createClass = /* @__PURE__ */ function() {\n                  function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                      var descriptor = props[i];\n                      descriptor.enumerable = descriptor.enumerable || false;\n                      descriptor.configurable = true;\n                      if (\"value\" in descriptor) descriptor.writable = true;\n                      Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                  }\n                  __name(defineProperties, \"defineProperties\");\n                  return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                  };\n                }();\n                function _classCallCheck(instance2, Constructor) {\n                  if (!(instance2 instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                  }\n                }\n                __name(_classCallCheck, \"_classCallCheck\");\n                var assign = __webpack_require__2(658);\n                var aux = __webpack_require__2(548);\n                var _require = __webpack_require__2(657), spectralLayout = _require.spectralLayout;\n                var _require2 = __webpack_require__2(816), coseLayout = _require2.coseLayout;\n                var defaults = Object.freeze({\n                  // 'draft', 'default' or 'proof' \n                  // - 'draft' only applies spectral layout \n                  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n                  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n                  quality: \"default\",\n                  // Use random node positions at beginning of layout\n                  // if this is set to false, then quality option must be \"proof\"\n                  randomize: true,\n                  // Whether or not to animate the layout\n                  animate: true,\n                  // Duration of animation in ms, if enabled\n                  animationDuration: 1e3,\n                  // Easing of animation, if enabled\n                  animationEasing: void 0,\n                  // Fit the viewport to the repositioned nodes\n                  fit: true,\n                  // Padding around layout\n                  padding: 30,\n                  // Whether to include labels in node dimensions. Valid in \"proof\" quality\n                  nodeDimensionsIncludeLabels: false,\n                  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n                  uniformNodeDimensions: false,\n                  // Whether to pack disconnected components - valid only if randomize: true\n                  packComponents: true,\n                  // Layout step - all, transformed, enforced, cose - for debug purpose only\n                  step: \"all\",\n                  /* spectral layout options */\n                  // False for random, true for greedy\n                  samplingType: true,\n                  // Sample size to construct distance matrix\n                  sampleSize: 25,\n                  // Separation amount between nodes\n                  nodeSeparation: 75,\n                  // Power iteration tolerance\n                  piTol: 1e-7,\n                  /* CoSE layout options */\n                  // Node repulsion (non overlapping) multiplier\n                  nodeRepulsion: /* @__PURE__ */ __name(function nodeRepulsion(node) {\n                    return 4500;\n                  }, \"nodeRepulsion\"),\n                  // Ideal edge (non nested) length\n                  idealEdgeLength: /* @__PURE__ */ __name(function idealEdgeLength(edge) {\n                    return 50;\n                  }, \"idealEdgeLength\"),\n                  // Divisor to compute edge forces\n                  edgeElasticity: /* @__PURE__ */ __name(function edgeElasticity(edge) {\n                    return 0.45;\n                  }, \"edgeElasticity\"),\n                  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n                  nestingFactor: 0.1,\n                  // Gravity force (constant)\n                  gravity: 0.25,\n                  // Maximum number of iterations to perform\n                  numIter: 2500,\n                  // For enabling tiling\n                  tile: true,\n                  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n                  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n                  tilingCompareBy: void 0,\n                  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n                  tilingPaddingVertical: 10,\n                  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n                  tilingPaddingHorizontal: 10,\n                  // Gravity range (constant) for compounds\n                  gravityRangeCompound: 1.5,\n                  // Gravity force (constant) for compounds\n                  gravityCompound: 1,\n                  // Gravity range (constant)\n                  gravityRange: 3.8,\n                  // Initial cooling factor for incremental layout  \n                  initialEnergyOnIncremental: 0.3,\n                  /* constraint options */\n                  // Fix required nodes to predefined positions\n                  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n                  fixedNodeConstraint: void 0,\n                  // Align required nodes in vertical/horizontal direction\n                  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n                  alignmentConstraint: void 0,\n                  // Place two nodes relatively in vertical/horizontal direction \n                  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n                  relativePlacementConstraint: void 0,\n                  /* layout event callbacks */\n                  ready: /* @__PURE__ */ __name(function ready() {\n                  }, \"ready\"),\n                  // on layoutready\n                  stop: /* @__PURE__ */ __name(function stop() {\n                  }, \"stop\")\n                  // on layoutstop\n                });\n                var Layout2 = function() {\n                  function Layout3(options) {\n                    _classCallCheck(this, Layout3);\n                    this.options = assign({}, defaults, options);\n                  }\n                  __name(Layout3, \"Layout\");\n                  _createClass(Layout3, [{\n                    key: \"run\",\n                    value: /* @__PURE__ */ __name(function run() {\n                      var layout = this;\n                      var options = this.options;\n                      var cy = options.cy;\n                      var eles = options.eles;\n                      var spectralResult = [];\n                      var xCoords = void 0;\n                      var yCoords = void 0;\n                      var coseResult = [];\n                      var components = void 0;\n                      var componentCenters = [];\n                      if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n                        options.fixedNodeConstraint = void 0;\n                      }\n                      if (options.alignmentConstraint) {\n                        if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n                          options.alignmentConstraint.vertical = void 0;\n                        }\n                        if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n                          options.alignmentConstraint.horizontal = void 0;\n                        }\n                      }\n                      if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n                        options.relativePlacementConstraint = void 0;\n                      }\n                      var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n                      if (constraintExist) {\n                        options.tile = false;\n                        options.packComponents = false;\n                      }\n                      var layUtil = void 0;\n                      var packingEnabled = false;\n                      if (cy.layoutUtilities && options.packComponents) {\n                        layUtil = cy.layoutUtilities(\"get\");\n                        if (!layUtil) layUtil = cy.layoutUtilities();\n                        packingEnabled = true;\n                      }\n                      if (eles.nodes().length > 0) {\n                        if (!packingEnabled) {\n                          var boundingBox = options.eles.boundingBox();\n                          componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n                          if (options.randomize) {\n                            var result = spectralLayout(options);\n                            spectralResult.push(result);\n                          }\n                          if (options.quality == \"default\" || options.quality == \"proof\") {\n                            coseResult.push(coseLayout(options, spectralResult[0]));\n                            aux.relocateComponent(componentCenters[0], coseResult[0], options);\n                          } else {\n                            aux.relocateComponent(componentCenters[0], spectralResult[0], options);\n                          }\n                        } else {\n                          var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n                          components = aux.connectComponents(cy, options.eles, topMostNodes);\n                          components.forEach(function(component) {\n                            var boundingBox2 = component.boundingBox();\n                            componentCenters.push({ x: boundingBox2.x1 + boundingBox2.w / 2, y: boundingBox2.y1 + boundingBox2.h / 2 });\n                          });\n                          if (options.randomize) {\n                            components.forEach(function(component) {\n                              options.eles = component;\n                              spectralResult.push(spectralLayout(options));\n                            });\n                          }\n                          if (options.quality == \"default\" || options.quality == \"proof\") {\n                            var toBeTiledNodes = cy.collection();\n                            if (options.tile) {\n                              var nodeIndexes = /* @__PURE__ */ new Map();\n                              var _xCoords = [];\n                              var _yCoords = [];\n                              var count = 0;\n                              var tempSpectralResult = { nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n                              var indexesToBeDeleted = [];\n                              components.forEach(function(component, index) {\n                                if (component.edges().length == 0) {\n                                  component.nodes().forEach(function(node, i2) {\n                                    toBeTiledNodes.merge(component.nodes()[i2]);\n                                    if (!node.isParent()) {\n                                      tempSpectralResult.nodeIndexes.set(component.nodes()[i2].id(), count++);\n                                      tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                                      tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                                    }\n                                  });\n                                  indexesToBeDeleted.push(index);\n                                }\n                              });\n                              if (toBeTiledNodes.length > 1) {\n                                var _boundingBox = toBeTiledNodes.boundingBox();\n                                componentCenters.push({ x: _boundingBox.x1 + _boundingBox.w / 2, y: _boundingBox.y1 + _boundingBox.h / 2 });\n                                components.push(toBeTiledNodes);\n                                spectralResult.push(tempSpectralResult);\n                                for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                                  components.splice(indexesToBeDeleted[i], 1);\n                                  spectralResult.splice(indexesToBeDeleted[i], 1);\n                                  componentCenters.splice(indexesToBeDeleted[i], 1);\n                                }\n                                ;\n                              }\n                            }\n                            components.forEach(function(component, index) {\n                              options.eles = component;\n                              coseResult.push(coseLayout(options, spectralResult[index]));\n                              aux.relocateComponent(componentCenters[index], coseResult[index], options);\n                            });\n                          } else {\n                            components.forEach(function(component, index) {\n                              aux.relocateComponent(componentCenters[index], spectralResult[index], options);\n                            });\n                          }\n                          var componentsEvaluated = /* @__PURE__ */ new Set();\n                          if (components.length > 1) {\n                            var subgraphs = [];\n                            var hiddenEles = eles.filter(function(ele) {\n                              return ele.css(\"display\") == \"none\";\n                            });\n                            components.forEach(function(component, index) {\n                              var nodeIndexes2 = void 0;\n                              if (options.quality == \"draft\") {\n                                nodeIndexes2 = spectralResult[index].nodeIndexes;\n                              }\n                              if (component.nodes().not(hiddenEles).length > 0) {\n                                var subgraph = {};\n                                subgraph.edges = [];\n                                subgraph.nodes = [];\n                                var nodeIndex = void 0;\n                                component.nodes().not(hiddenEles).forEach(function(node) {\n                                  if (options.quality == \"draft\") {\n                                    if (!node.isParent()) {\n                                      nodeIndex = nodeIndexes2.get(node.id());\n                                      subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n                                    } else {\n                                      var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes2);\n                                      subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n                                    }\n                                  } else {\n                                    if (coseResult[index][node.id()]) {\n                                      subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n                                    }\n                                  }\n                                });\n                                component.edges().forEach(function(edge) {\n                                  var source = edge.source();\n                                  var target = edge.target();\n                                  if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                                    if (options.quality == \"draft\") {\n                                      var sourceNodeIndex = nodeIndexes2.get(source.id());\n                                      var targetNodeIndex = nodeIndexes2.get(target.id());\n                                      var sourceCenter = [];\n                                      var targetCenter = [];\n                                      if (source.isParent()) {\n                                        var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes2);\n                                        sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                                        sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                                      } else {\n                                        sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                                        sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                                      }\n                                      if (target.isParent()) {\n                                        var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes2);\n                                        targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                                        targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                                      } else {\n                                        targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                                        targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                                      }\n                                      subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n                                    } else {\n                                      if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                                        subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n                                      }\n                                    }\n                                  }\n                                });\n                                if (subgraph.nodes.length > 0) {\n                                  subgraphs.push(subgraph);\n                                  componentsEvaluated.add(index);\n                                }\n                              }\n                            });\n                            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n                            if (options.quality == \"draft\") {\n                              spectralResult.forEach(function(result2, index) {\n                                var newXCoords = result2.xCoords.map(function(x) {\n                                  return x + shiftResult[index].dx;\n                                });\n                                var newYCoords = result2.yCoords.map(function(y) {\n                                  return y + shiftResult[index].dy;\n                                });\n                                result2.xCoords = newXCoords;\n                                result2.yCoords = newYCoords;\n                              });\n                            } else {\n                              var _count = 0;\n                              componentsEvaluated.forEach(function(index) {\n                                Object.keys(coseResult[index]).forEach(function(item) {\n                                  var nodeRectangle = coseResult[index][item];\n                                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                                });\n                                _count++;\n                              });\n                            }\n                          }\n                        }\n                      }\n                      var getPositions = /* @__PURE__ */ __name(function getPositions2(ele, i2) {\n                        if (options.quality == \"default\" || options.quality == \"proof\") {\n                          if (typeof ele === \"number\") {\n                            ele = i2;\n                          }\n                          var pos = void 0;\n                          var node = void 0;\n                          var theId = ele.data(\"id\");\n                          coseResult.forEach(function(result2) {\n                            if (theId in result2) {\n                              pos = { x: result2[theId].getRect().getCenterX(), y: result2[theId].getRect().getCenterY() };\n                              node = result2[theId];\n                            }\n                          });\n                          if (options.nodeDimensionsIncludeLabels) {\n                            if (node.labelWidth) {\n                              if (node.labelPosHorizontal == \"left\") {\n                                pos.x += node.labelWidth / 2;\n                              } else if (node.labelPosHorizontal == \"right\") {\n                                pos.x -= node.labelWidth / 2;\n                              }\n                            }\n                            if (node.labelHeight) {\n                              if (node.labelPosVertical == \"top\") {\n                                pos.y += node.labelHeight / 2;\n                              } else if (node.labelPosVertical == \"bottom\") {\n                                pos.y -= node.labelHeight / 2;\n                              }\n                            }\n                          }\n                          if (pos == void 0) pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n                          return {\n                            x: pos.x,\n                            y: pos.y\n                          };\n                        } else {\n                          var _pos = void 0;\n                          spectralResult.forEach(function(result2) {\n                            var index = result2.nodeIndexes.get(ele.id());\n                            if (index != void 0) {\n                              _pos = { x: result2.xCoords[index], y: result2.yCoords[index] };\n                            }\n                          });\n                          if (_pos == void 0) _pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n                          return {\n                            x: _pos.x,\n                            y: _pos.y\n                          };\n                        }\n                      }, \"getPositions\");\n                      if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n                        var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n                        var _hiddenEles = eles.filter(function(ele) {\n                          return ele.css(\"display\") == \"none\";\n                        });\n                        options.eles = eles.not(_hiddenEles);\n                        eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n                        if (parentsWithoutChildren.length > 0) {\n                          parentsWithoutChildren.forEach(function(ele) {\n                            ele.position(getPositions(ele));\n                          });\n                        }\n                      } else {\n                        console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n                      }\n                    }, \"run\")\n                  }]);\n                  return Layout3;\n                }();\n                module2.exports = Layout2;\n              }\n            ),\n            /***/\n            657: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var aux = __webpack_require__2(548);\n                var Matrix = __webpack_require__2(140).layoutBase.Matrix;\n                var SVD = __webpack_require__2(140).layoutBase.SVD;\n                var spectralLayout = /* @__PURE__ */ __name(function spectralLayout2(options) {\n                  var cy = options.cy;\n                  var eles = options.eles;\n                  var nodes = eles.nodes();\n                  var parentNodes = eles.nodes(\":parent\");\n                  var dummyNodes = /* @__PURE__ */ new Map();\n                  var nodeIndexes = /* @__PURE__ */ new Map();\n                  var parentChildMap = /* @__PURE__ */ new Map();\n                  var allNodesNeighborhood = [];\n                  var xCoords = [];\n                  var yCoords = [];\n                  var samplesColumn = [];\n                  var minDistancesColumn = [];\n                  var C = [];\n                  var PHI = [];\n                  var INV = [];\n                  var firstSample = void 0;\n                  var nodeSize = void 0;\n                  var infinity = 1e8;\n                  var small = 1e-9;\n                  var piTol = options.piTol;\n                  var samplingType = options.samplingType;\n                  var nodeSeparation = options.nodeSeparation;\n                  var sampleSize = void 0;\n                  var randomSampleCR = /* @__PURE__ */ __name(function randomSampleCR2() {\n                    var sample2 = 0;\n                    var count = 0;\n                    var flag = false;\n                    while (count < sampleSize) {\n                      sample2 = Math.floor(Math.random() * nodeSize);\n                      flag = false;\n                      for (var i2 = 0; i2 < count; i2++) {\n                        if (samplesColumn[i2] == sample2) {\n                          flag = true;\n                          break;\n                        }\n                      }\n                      if (!flag) {\n                        samplesColumn[count] = sample2;\n                        count++;\n                      } else {\n                        continue;\n                      }\n                    }\n                  }, \"randomSampleCR\");\n                  var BFS = /* @__PURE__ */ __name(function BFS2(pivot, index2, samplingMethod) {\n                    var path = [];\n                    var front = 0;\n                    var back = 0;\n                    var current = 0;\n                    var temp = void 0;\n                    var distance = [];\n                    var max_dist = 0;\n                    var max_ind = 1;\n                    for (var i2 = 0; i2 < nodeSize; i2++) {\n                      distance[i2] = infinity;\n                    }\n                    path[back] = pivot;\n                    distance[pivot] = 0;\n                    while (back >= front) {\n                      current = path[front++];\n                      var neighbors = allNodesNeighborhood[current];\n                      for (var _i = 0; _i < neighbors.length; _i++) {\n                        temp = nodeIndexes.get(neighbors[_i]);\n                        if (distance[temp] == infinity) {\n                          distance[temp] = distance[current] + 1;\n                          path[++back] = temp;\n                        }\n                      }\n                      C[current][index2] = distance[current] * nodeSeparation;\n                    }\n                    if (samplingMethod) {\n                      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n                        if (C[_i2][index2] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index2];\n                      }\n                      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n                        if (minDistancesColumn[_i3] > max_dist) {\n                          max_dist = minDistancesColumn[_i3];\n                          max_ind = _i3;\n                        }\n                      }\n                    }\n                    return max_ind;\n                  }, \"BFS\");\n                  var allBFS = /* @__PURE__ */ __name(function allBFS2(samplingMethod) {\n                    var sample2 = void 0;\n                    if (!samplingMethod) {\n                      randomSampleCR();\n                      for (var i2 = 0; i2 < sampleSize; i2++) {\n                        BFS(samplesColumn[i2], i2, samplingMethod, false);\n                      }\n                    } else {\n                      sample2 = Math.floor(Math.random() * nodeSize);\n                      firstSample = sample2;\n                      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n                        minDistancesColumn[_i4] = infinity;\n                      }\n                      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n                        samplesColumn[_i5] = sample2;\n                        sample2 = BFS(sample2, _i5, samplingMethod);\n                      }\n                    }\n                    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n                      for (var j = 0; j < sampleSize; j++) {\n                        C[_i6][j] *= C[_i6][j];\n                      }\n                    }\n                    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n                      PHI[_i7] = [];\n                    }\n                    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n                      for (var _j = 0; _j < sampleSize; _j++) {\n                        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n                      }\n                    }\n                  }, \"allBFS\");\n                  var sample = /* @__PURE__ */ __name(function sample2() {\n                    var SVDResult = SVD.svd(PHI);\n                    var a_q = SVDResult.S;\n                    var a_u = SVDResult.U;\n                    var a_v = SVDResult.V;\n                    var max_s = a_q[0] * a_q[0] * a_q[0];\n                    var a_Sig = [];\n                    for (var i2 = 0; i2 < sampleSize; i2++) {\n                      a_Sig[i2] = [];\n                      for (var j = 0; j < sampleSize; j++) {\n                        a_Sig[i2][j] = 0;\n                        if (i2 == j) {\n                          a_Sig[i2][j] = a_q[i2] / (a_q[i2] * a_q[i2] + max_s / (a_q[i2] * a_q[i2]));\n                        }\n                      }\n                    }\n                    INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n                  }, \"sample\");\n                  var powerIteration = /* @__PURE__ */ __name(function powerIteration2() {\n                    var theta1 = void 0;\n                    var theta2 = void 0;\n                    var Y1 = [];\n                    var Y2 = [];\n                    var V1 = [];\n                    var V2 = [];\n                    for (var i2 = 0; i2 < nodeSize; i2++) {\n                      Y1[i2] = Math.random();\n                      Y2[i2] = Math.random();\n                    }\n                    Y1 = Matrix.normalize(Y1);\n                    Y2 = Matrix.normalize(Y2);\n                    var count = 0;\n                    var current = small;\n                    var previous = small;\n                    var temp = void 0;\n                    while (true) {\n                      count++;\n                      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n                        V1[_i9] = Y1[_i9];\n                      }\n                      Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n                      theta1 = Matrix.dotProduct(V1, Y1);\n                      Y1 = Matrix.normalize(Y1);\n                      current = Matrix.dotProduct(V1, Y1);\n                      temp = Math.abs(current / previous);\n                      if (temp <= 1 + piTol && temp >= 1) {\n                        break;\n                      }\n                      previous = current;\n                    }\n                    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n                      V1[_i10] = Y1[_i10];\n                    }\n                    count = 0;\n                    previous = small;\n                    while (true) {\n                      count++;\n                      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n                        V2[_i11] = Y2[_i11];\n                      }\n                      V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n                      Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n                      theta2 = Matrix.dotProduct(V2, Y2);\n                      Y2 = Matrix.normalize(Y2);\n                      current = Matrix.dotProduct(V2, Y2);\n                      temp = Math.abs(current / previous);\n                      if (temp <= 1 + piTol && temp >= 1) {\n                        break;\n                      }\n                      previous = current;\n                    }\n                    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n                      V2[_i12] = Y2[_i12];\n                    }\n                    xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n                    yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n                  }, \"powerIteration\");\n                  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n                  parentNodes.forEach(function(ele) {\n                    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n                  });\n                  var index = 0;\n                  for (var i = 0; i < nodes.length; i++) {\n                    if (!nodes[i].isParent()) {\n                      nodeIndexes.set(nodes[i].id(), index++);\n                    }\n                  }\n                  var _iteratorNormalCompletion = true;\n                  var _didIteratorError = false;\n                  var _iteratorError = void 0;\n                  try {\n                    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                      var key = _step.value;\n                      nodeIndexes.set(key, index++);\n                    }\n                  } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                      }\n                    } finally {\n                      if (_didIteratorError) {\n                        throw _iteratorError;\n                      }\n                    }\n                  }\n                  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n                    allNodesNeighborhood[_i13] = [];\n                  }\n                  parentNodes.forEach(function(ele) {\n                    var children = ele.children().intersection(eles);\n                    while (children.nodes(\":childless\").length == 0) {\n                      children = children.nodes()[0].children().intersection(eles);\n                    }\n                    var index2 = 0;\n                    var min = children.nodes(\":childless\")[0].connectedEdges().length;\n                    children.nodes(\":childless\").forEach(function(ele2, i2) {\n                      if (ele2.connectedEdges().length < min) {\n                        min = ele2.connectedEdges().length;\n                        index2 = i2;\n                      }\n                    });\n                    parentChildMap.set(ele.id(), children.nodes(\":childless\")[index2].id());\n                  });\n                  nodes.forEach(function(ele) {\n                    var eleIndex = void 0;\n                    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));\n                    else eleIndex = nodeIndexes.get(ele.id());\n                    ele.neighborhood().nodes().forEach(function(node) {\n                      if (eles.intersection(ele.edgesWith(node)).length > 0) {\n                        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));\n                        else allNodesNeighborhood[eleIndex].push(node.id());\n                      }\n                    });\n                  });\n                  var _loop = /* @__PURE__ */ __name(function _loop2(_key2) {\n                    var eleIndex = nodeIndexes.get(_key2);\n                    var disconnectedId = void 0;\n                    dummyNodes.get(_key2).forEach(function(id) {\n                      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);\n                      else disconnectedId = id;\n                      allNodesNeighborhood[eleIndex].push(disconnectedId);\n                      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key2);\n                    });\n                  }, \"_loop\");\n                  var _iteratorNormalCompletion2 = true;\n                  var _didIteratorError2 = false;\n                  var _iteratorError2 = void 0;\n                  try {\n                    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                      var _key = _step2.value;\n                      _loop(_key);\n                    }\n                  } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                      }\n                    } finally {\n                      if (_didIteratorError2) {\n                        throw _iteratorError2;\n                      }\n                    }\n                  }\n                  nodeSize = nodeIndexes.size;\n                  var spectralResult = void 0;\n                  if (nodeSize > 2) {\n                    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n                    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n                      C[_i14] = [];\n                    }\n                    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n                      INV[_i15] = [];\n                    }\n                    if (options.quality == \"draft\" || options.step == \"all\") {\n                      allBFS(samplingType);\n                      sample();\n                      powerIteration();\n                      spectralResult = { nodeIndexes, xCoords, yCoords };\n                    } else {\n                      nodeIndexes.forEach(function(value, key2) {\n                        xCoords.push(cy.getElementById(key2).position(\"x\"));\n                        yCoords.push(cy.getElementById(key2).position(\"y\"));\n                      });\n                      spectralResult = { nodeIndexes, xCoords, yCoords };\n                    }\n                    return spectralResult;\n                  } else {\n                    var iterator = nodeIndexes.keys();\n                    var firstNode = cy.getElementById(iterator.next().value);\n                    var firstNodePos = firstNode.position();\n                    var firstNodeWidth = firstNode.outerWidth();\n                    xCoords.push(firstNodePos.x);\n                    yCoords.push(firstNodePos.y);\n                    if (nodeSize == 2) {\n                      var secondNode = cy.getElementById(iterator.next().value);\n                      var secondNodeWidth = secondNode.outerWidth();\n                      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n                      yCoords.push(firstNodePos.y);\n                    }\n                    spectralResult = { nodeIndexes, xCoords, yCoords };\n                    return spectralResult;\n                  }\n                }, \"spectralLayout\");\n                module2.exports = { spectralLayout };\n              }\n            ),\n            /***/\n            579: (\n              /***/\n              (module2, __unused_webpack_exports, __webpack_require__2) => {\n                var impl = __webpack_require__2(212);\n                var register = /* @__PURE__ */ __name(function register2(cytoscape3) {\n                  if (!cytoscape3) {\n                    return;\n                  }\n                  cytoscape3(\"layout\", \"fcose\", impl);\n                }, \"register\");\n                if (typeof cytoscape !== \"undefined\") {\n                  register(cytoscape);\n                }\n                module2.exports = register;\n              }\n            ),\n            /***/\n            140: (\n              /***/\n              (module2) => {\n                module2.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n              }\n            )\n            /******/\n          };\n          var __webpack_module_cache__ = {};\n          function __webpack_require__(moduleId) {\n            var cachedModule = __webpack_module_cache__[moduleId];\n            if (cachedModule !== void 0) {\n              return cachedModule.exports;\n            }\n            var module2 = __webpack_module_cache__[moduleId] = {\n              /******/\n              // no module.id needed\n              /******/\n              // no module.loaded needed\n              /******/\n              exports: {}\n              /******/\n            };\n            __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);\n            return module2.exports;\n          }\n          __name(__webpack_require__, \"__webpack_require__\");\n          var __webpack_exports__ = __webpack_require__(579);\n          return __webpack_exports__;\n        })()\n      );\n    });\n  }\n});\n\n// src/diagrams/architecture/architectureTypes.ts\nvar ArchitectureDirectionName = {\n  L: \"left\",\n  R: \"right\",\n  T: \"top\",\n  B: \"bottom\"\n};\nvar ArchitectureDirectionArrow = {\n  L: /* @__PURE__ */ __name((scale) => `${scale},${scale / 2} 0,${scale} 0,0`, \"L\"),\n  R: /* @__PURE__ */ __name((scale) => `0,${scale / 2} ${scale},0 ${scale},${scale}`, \"R\"),\n  T: /* @__PURE__ */ __name((scale) => `0,0 ${scale},0 ${scale / 2},${scale}`, \"T\"),\n  B: /* @__PURE__ */ __name((scale) => `${scale / 2},0 ${scale},${scale} 0,${scale}`, \"B\")\n};\nvar ArchitectureDirectionArrowShift = {\n  L: /* @__PURE__ */ __name((orig, arrowSize) => orig - arrowSize + 2, \"L\"),\n  R: /* @__PURE__ */ __name((orig, _arrowSize) => orig - 2, \"R\"),\n  T: /* @__PURE__ */ __name((orig, arrowSize) => orig - arrowSize + 2, \"T\"),\n  B: /* @__PURE__ */ __name((orig, _arrowSize) => orig - 2, \"B\")\n};\nvar getOppositeArchitectureDirection = /* @__PURE__ */ __name(function(x) {\n  if (isArchitectureDirectionX(x)) {\n    return x === \"L\" ? \"R\" : \"L\";\n  } else {\n    return x === \"T\" ? \"B\" : \"T\";\n  }\n}, \"getOppositeArchitectureDirection\");\nvar isArchitectureDirection = /* @__PURE__ */ __name(function(x) {\n  const temp = x;\n  return temp === \"L\" || temp === \"R\" || temp === \"T\" || temp === \"B\";\n}, \"isArchitectureDirection\");\nvar isArchitectureDirectionX = /* @__PURE__ */ __name(function(x) {\n  const temp = x;\n  return temp === \"L\" || temp === \"R\";\n}, \"isArchitectureDirectionX\");\nvar isArchitectureDirectionY = /* @__PURE__ */ __name(function(x) {\n  const temp = x;\n  return temp === \"T\" || temp === \"B\";\n}, \"isArchitectureDirectionY\");\nvar isArchitectureDirectionXY = /* @__PURE__ */ __name(function(a, b) {\n  const aX_bY = isArchitectureDirectionX(a) && isArchitectureDirectionY(b);\n  const aY_bX = isArchitectureDirectionY(a) && isArchitectureDirectionX(b);\n  return aX_bY || aY_bX;\n}, \"isArchitectureDirectionXY\");\nvar isArchitecturePairXY = /* @__PURE__ */ __name(function(pair) {\n  const lhs = pair[0];\n  const rhs = pair[1];\n  const aX_bY = isArchitectureDirectionX(lhs) && isArchitectureDirectionY(rhs);\n  const aY_bX = isArchitectureDirectionY(lhs) && isArchitectureDirectionX(rhs);\n  return aX_bY || aY_bX;\n}, \"isArchitecturePairXY\");\nvar isValidArchitectureDirectionPair = /* @__PURE__ */ __name(function(x) {\n  return x !== \"LL\" && x !== \"RR\" && x !== \"TT\" && x !== \"BB\";\n}, \"isValidArchitectureDirectionPair\");\nvar getArchitectureDirectionPair = /* @__PURE__ */ __name(function(sourceDir, targetDir) {\n  const pair = `${sourceDir}${targetDir}`;\n  return isValidArchitectureDirectionPair(pair) ? pair : void 0;\n}, \"getArchitectureDirectionPair\");\nvar shiftPositionByArchitectureDirectionPair = /* @__PURE__ */ __name(function([x, y], pair) {\n  const lhs = pair[0];\n  const rhs = pair[1];\n  if (isArchitectureDirectionX(lhs)) {\n    if (isArchitectureDirectionY(rhs)) {\n      return [x + (lhs === \"L\" ? -1 : 1), y + (rhs === \"T\" ? 1 : -1)];\n    } else {\n      return [x + (lhs === \"L\" ? -1 : 1), y];\n    }\n  } else {\n    if (isArchitectureDirectionX(rhs)) {\n      return [x + (rhs === \"L\" ? 1 : -1), y + (lhs === \"T\" ? 1 : -1)];\n    } else {\n      return [x, y + (lhs === \"T\" ? 1 : -1)];\n    }\n  }\n}, \"shiftPositionByArchitectureDirectionPair\");\nvar getArchitectureDirectionXYFactors = /* @__PURE__ */ __name(function(pair) {\n  if (pair === \"LT\" || pair === \"TL\") {\n    return [1, 1];\n  } else if (pair === \"BL\" || pair === \"LB\") {\n    return [1, -1];\n  } else if (pair === \"BR\" || pair === \"RB\") {\n    return [-1, -1];\n  } else {\n    return [-1, 1];\n  }\n}, \"getArchitectureDirectionXYFactors\");\nvar getArchitectureDirectionAlignment = /* @__PURE__ */ __name(function(a, b) {\n  if (isArchitectureDirectionXY(a, b)) {\n    return \"bend\";\n  } else if (isArchitectureDirectionX(a)) {\n    return \"horizontal\";\n  }\n  return \"vertical\";\n}, \"getArchitectureDirectionAlignment\");\nvar isArchitectureService = /* @__PURE__ */ __name(function(x) {\n  const temp = x;\n  return temp.type === \"service\";\n}, \"isArchitectureService\");\nvar isArchitectureJunction = /* @__PURE__ */ __name(function(x) {\n  const temp = x;\n  return temp.type === \"junction\";\n}, \"isArchitectureJunction\");\nvar edgeData = /* @__PURE__ */ __name((edge) => {\n  return edge.data();\n}, \"edgeData\");\nvar nodeData = /* @__PURE__ */ __name((node) => {\n  return node.data();\n}, \"nodeData\");\n\n// src/diagrams/architecture/architectureDb.ts\nvar DEFAULT_ARCHITECTURE_CONFIG = defaultConfig_default.architecture;\nvar state = new ImperativeState(() => ({\n  nodes: {},\n  groups: {},\n  edges: [],\n  registeredIds: {},\n  config: DEFAULT_ARCHITECTURE_CONFIG,\n  dataStructures: void 0,\n  elements: {}\n}));\nvar clear2 = /* @__PURE__ */ __name(() => {\n  state.reset();\n  clear();\n}, \"clear\");\nvar addService = /* @__PURE__ */ __name(function({\n  id,\n  icon,\n  in: parent,\n  title,\n  iconText\n}) {\n  if (state.records.registeredIds[id] !== void 0) {\n    throw new Error(\n      `The service id [${id}] is already in use by another ${state.records.registeredIds[id]}`\n    );\n  }\n  if (parent !== void 0) {\n    if (id === parent) {\n      throw new Error(`The service [${id}] cannot be placed within itself`);\n    }\n    if (state.records.registeredIds[parent] === void 0) {\n      throw new Error(\n        `The service [${id}]'s parent does not exist. Please make sure the parent is created before this service`\n      );\n    }\n    if (state.records.registeredIds[parent] === \"node\") {\n      throw new Error(`The service [${id}]'s parent is not a group`);\n    }\n  }\n  state.records.registeredIds[id] = \"node\";\n  state.records.nodes[id] = {\n    id,\n    type: \"service\",\n    icon,\n    iconText,\n    title,\n    edges: [],\n    in: parent\n  };\n}, \"addService\");\nvar getServices = /* @__PURE__ */ __name(() => Object.values(state.records.nodes).filter(isArchitectureService), \"getServices\");\nvar addJunction = /* @__PURE__ */ __name(function({ id, in: parent }) {\n  state.records.registeredIds[id] = \"node\";\n  state.records.nodes[id] = {\n    id,\n    type: \"junction\",\n    edges: [],\n    in: parent\n  };\n}, \"addJunction\");\nvar getJunctions = /* @__PURE__ */ __name(() => Object.values(state.records.nodes).filter(isArchitectureJunction), \"getJunctions\");\nvar getNodes = /* @__PURE__ */ __name(() => Object.values(state.records.nodes), \"getNodes\");\nvar getNode = /* @__PURE__ */ __name((id) => state.records.nodes[id], \"getNode\");\nvar addGroup = /* @__PURE__ */ __name(function({ id, icon, in: parent, title }) {\n  if (state.records.registeredIds[id] !== void 0) {\n    throw new Error(\n      `The group id [${id}] is already in use by another ${state.records.registeredIds[id]}`\n    );\n  }\n  if (parent !== void 0) {\n    if (id === parent) {\n      throw new Error(`The group [${id}] cannot be placed within itself`);\n    }\n    if (state.records.registeredIds[parent] === void 0) {\n      throw new Error(\n        `The group [${id}]'s parent does not exist. Please make sure the parent is created before this group`\n      );\n    }\n    if (state.records.registeredIds[parent] === \"node\") {\n      throw new Error(`The group [${id}]'s parent is not a group`);\n    }\n  }\n  state.records.registeredIds[id] = \"group\";\n  state.records.groups[id] = {\n    id,\n    icon,\n    title,\n    in: parent\n  };\n}, \"addGroup\");\nvar getGroups = /* @__PURE__ */ __name(() => {\n  return Object.values(state.records.groups);\n}, \"getGroups\");\nvar addEdge = /* @__PURE__ */ __name(function({\n  lhsId,\n  rhsId,\n  lhsDir,\n  rhsDir,\n  lhsInto,\n  rhsInto,\n  lhsGroup,\n  rhsGroup,\n  title\n}) {\n  if (!isArchitectureDirection(lhsDir)) {\n    throw new Error(\n      `Invalid direction given for left hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${lhsDir}`\n    );\n  }\n  if (!isArchitectureDirection(rhsDir)) {\n    throw new Error(\n      `Invalid direction given for right hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${rhsDir}`\n    );\n  }\n  if (state.records.nodes[lhsId] === void 0 && state.records.groups[lhsId] === void 0) {\n    throw new Error(\n      `The left-hand id [${lhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`\n    );\n  }\n  if (state.records.nodes[rhsId] === void 0 && state.records.groups[lhsId] === void 0) {\n    throw new Error(\n      `The right-hand id [${rhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`\n    );\n  }\n  const lhsGroupId = state.records.nodes[lhsId].in;\n  const rhsGroupId = state.records.nodes[rhsId].in;\n  if (lhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {\n    throw new Error(\n      `The left-hand id [${lhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`\n    );\n  }\n  if (rhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {\n    throw new Error(\n      `The right-hand id [${rhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`\n    );\n  }\n  const edge = {\n    lhsId,\n    lhsDir,\n    lhsInto,\n    lhsGroup,\n    rhsId,\n    rhsDir,\n    rhsInto,\n    rhsGroup,\n    title\n  };\n  state.records.edges.push(edge);\n  if (state.records.nodes[lhsId] && state.records.nodes[rhsId]) {\n    state.records.nodes[lhsId].edges.push(state.records.edges[state.records.edges.length - 1]);\n    state.records.nodes[rhsId].edges.push(state.records.edges[state.records.edges.length - 1]);\n  }\n}, \"addEdge\");\nvar getEdges = /* @__PURE__ */ __name(() => state.records.edges, \"getEdges\");\nvar getDataStructures = /* @__PURE__ */ __name(() => {\n  if (state.records.dataStructures === void 0) {\n    const groupAlignments = {};\n    const adjList = Object.entries(state.records.nodes).reduce((prevOuter, [id, service]) => {\n      prevOuter[id] = service.edges.reduce((prevInner, edge) => {\n        const lhsGroupId = getNode(edge.lhsId)?.in;\n        const rhsGroupId = getNode(edge.rhsId)?.in;\n        if (lhsGroupId && rhsGroupId && lhsGroupId !== rhsGroupId) {\n          const alignment = getArchitectureDirectionAlignment(edge.lhsDir, edge.rhsDir);\n          if (alignment !== \"bend\") {\n            groupAlignments[lhsGroupId] ??= {};\n            groupAlignments[lhsGroupId][rhsGroupId] = alignment;\n            groupAlignments[rhsGroupId] ??= {};\n            groupAlignments[rhsGroupId][lhsGroupId] = alignment;\n          }\n        }\n        if (edge.lhsId === id) {\n          const pair = getArchitectureDirectionPair(edge.lhsDir, edge.rhsDir);\n          if (pair) {\n            prevInner[pair] = edge.rhsId;\n          }\n        } else {\n          const pair = getArchitectureDirectionPair(edge.rhsDir, edge.lhsDir);\n          if (pair) {\n            prevInner[pair] = edge.lhsId;\n          }\n        }\n        return prevInner;\n      }, {});\n      return prevOuter;\n    }, {});\n    const firstId = Object.keys(adjList)[0];\n    const visited = { [firstId]: 1 };\n    const notVisited = Object.keys(adjList).reduce(\n      (prev, id) => id === firstId ? prev : { ...prev, [id]: 1 },\n      {}\n    );\n    const BFS = /* @__PURE__ */ __name((startingId) => {\n      const spatialMap = { [startingId]: [0, 0] };\n      const queue = [startingId];\n      while (queue.length > 0) {\n        const id = queue.shift();\n        if (id) {\n          visited[id] = 1;\n          delete notVisited[id];\n          const adj = adjList[id];\n          const [posX, posY] = spatialMap[id];\n          Object.entries(adj).forEach(([dir, rhsId]) => {\n            if (!visited[rhsId]) {\n              spatialMap[rhsId] = shiftPositionByArchitectureDirectionPair(\n                [posX, posY],\n                dir\n              );\n              queue.push(rhsId);\n            }\n          });\n        }\n      }\n      return spatialMap;\n    }, \"BFS\");\n    const spatialMaps = [BFS(firstId)];\n    while (Object.keys(notVisited).length > 0) {\n      spatialMaps.push(BFS(Object.keys(notVisited)[0]));\n    }\n    state.records.dataStructures = {\n      adjList,\n      spatialMaps,\n      groupAlignments\n    };\n  }\n  return state.records.dataStructures;\n}, \"getDataStructures\");\nvar setElementForId = /* @__PURE__ */ __name((id, element) => {\n  state.records.elements[id] = element;\n}, \"setElementForId\");\nvar getElementById = /* @__PURE__ */ __name((id) => state.records.elements[id], \"getElementById\");\nvar db = {\n  clear: clear2,\n  setDiagramTitle,\n  getDiagramTitle,\n  setAccTitle,\n  getAccTitle,\n  setAccDescription,\n  getAccDescription,\n  addService,\n  getServices,\n  addJunction,\n  getJunctions,\n  getNodes,\n  getNode,\n  addGroup,\n  getGroups,\n  addEdge,\n  getEdges,\n  setElementForId,\n  getElementById,\n  getDataStructures\n};\nfunction getConfigField(field) {\n  const arch = getConfig().architecture;\n  if (arch?.[field]) {\n    return arch[field];\n  }\n  return DEFAULT_ARCHITECTURE_CONFIG[field];\n}\n__name(getConfigField, \"getConfigField\");\n\n// src/diagrams/architecture/architectureParser.ts\nvar populateDb = /* @__PURE__ */ __name((ast, db2) => {\n  populateCommonDb(ast, db2);\n  ast.groups.map(db2.addGroup);\n  ast.services.map((service) => db2.addService({ ...service, type: \"service\" }));\n  ast.junctions.map((service) => db2.addJunction({ ...service, type: \"junction\" }));\n  ast.edges.map(db2.addEdge);\n}, \"populateDb\");\nvar parser = {\n  parse: /* @__PURE__ */ __name(async (input) => {\n    const ast = await parse(\"architecture\", input);\n    log.debug(ast);\n    populateDb(ast, db);\n  }, \"parse\")\n};\n\n// src/diagrams/architecture/architectureStyles.ts\nvar getStyles = /* @__PURE__ */ __name((options) => `\n  .edge {\n    stroke-width: ${options.archEdgeWidth};\n    stroke: ${options.archEdgeColor};\n    fill: none;\n  }\n\n  .arrow {\n    fill: ${options.archEdgeArrowColor};\n  }\n\n  .node-bkg {\n    fill: none;\n    stroke: ${options.archGroupBorderColor};\n    stroke-width: ${options.archGroupBorderWidth};\n    stroke-dasharray: 8;\n  }\n  .node-icon-text {\n    display: flex; \n    align-items: center;\n  }\n  \n  .node-icon-text > div {\n    color: #fff;\n    margin: 1px;\n    height: fit-content;\n    text-align: center;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n  }\n`, \"getStyles\");\nvar architectureStyles_default = getStyles;\n\n// src/diagrams/architecture/architectureRenderer.ts\nvar import_cytoscape_fcose = __toESM(require_cytoscape_fcose(), 1);\n\n// src/diagrams/architecture/architectureIcons.ts\nvar wrapIcon = /* @__PURE__ */ __name((icon) => {\n  return `<g><rect width=\"80\" height=\"80\" style=\"fill: #087ebf; stroke-width: 0px;\"/>${icon}</g>`;\n}, \"wrapIcon\");\nvar architectureIcons = {\n  prefix: \"mermaid-architecture\",\n  height: 80,\n  width: 80,\n  icons: {\n    database: {\n      body: wrapIcon(\n        '<path id=\"b\" data-name=\"4\" d=\"m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path id=\"c\" data-name=\"3\" d=\"m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path id=\"d\" data-name=\"2\" d=\"m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse id=\"e\" data-name=\"1\" cx=\"40\" cy=\"22.14\" rx=\"20\" ry=\"7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"20\" y1=\"57.86\" x2=\"20\" y2=\"22.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"60\" y1=\"57.86\" x2=\"60\" y2=\"22.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>'\n      )\n    },\n    server: {\n      body: wrapIcon(\n        '<rect x=\"17.5\" y=\"17.5\" width=\"45\" height=\"45\" rx=\"2\" ry=\"2\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"32.5\" x2=\"62.5\" y2=\"32.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"47.5\" x2=\"62.5\" y2=\"47.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><g><path d=\"m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><path d=\"m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><path d=\"m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g>'\n      )\n    },\n    disk: {\n      body: wrapIcon(\n        '<rect x=\"20\" y=\"15\" width=\"40\" height=\"50\" rx=\"1\" ry=\"1\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"24\" cy=\"19.17\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"56\" cy=\"19.17\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"24\" cy=\"60.83\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"56\" cy=\"60.83\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"40\" cy=\"33.75\" rx=\"14\" ry=\"14.58\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"40\" cy=\"33.75\" rx=\"4\" ry=\"4.17\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z\" style=\"fill: #fff; stroke-width: 0px;\"/>'\n      )\n    },\n    internet: {\n      body: wrapIcon(\n        '<circle cx=\"40\" cy=\"40\" r=\"22.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"40\" y1=\"17.5\" x2=\"40\" y2=\"62.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"40\" x2=\"62.5\" y2=\"40\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"19.75\" y1=\"30.1\" x2=\"60.25\" y2=\"30.1\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"19.75\" y1=\"49.9\" x2=\"60.25\" y2=\"49.9\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>'\n      )\n    },\n    cloud: {\n      body: wrapIcon(\n        '<path d=\"m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>'\n      )\n    },\n    unknown: unknownIcon,\n    blank: {\n      body: wrapIcon(\"\")\n    }\n  }\n};\n\n// src/diagrams/architecture/svgDraw.ts\nvar drawEdges = /* @__PURE__ */ __name(async function(edgesEl, cy) {\n  const padding = getConfigField(\"padding\");\n  const iconSize = getConfigField(\"iconSize\");\n  const halfIconSize = iconSize / 2;\n  const arrowSize = iconSize / 6;\n  const halfArrowSize = arrowSize / 2;\n  await Promise.all(\n    cy.edges().map(async (edge) => {\n      const {\n        source,\n        sourceDir,\n        sourceArrow,\n        sourceGroup,\n        target,\n        targetDir,\n        targetArrow,\n        targetGroup,\n        label\n      } = edgeData(edge);\n      let { x: startX, y: startY } = edge[0].sourceEndpoint();\n      const { x: midX, y: midY } = edge[0].midpoint();\n      let { x: endX, y: endY } = edge[0].targetEndpoint();\n      const groupEdgeShift = padding + 4;\n      if (sourceGroup) {\n        if (isArchitectureDirectionX(sourceDir)) {\n          startX += sourceDir === \"L\" ? -groupEdgeShift : groupEdgeShift;\n        } else {\n          startY += sourceDir === \"T\" ? -groupEdgeShift : groupEdgeShift + 18;\n        }\n      }\n      if (targetGroup) {\n        if (isArchitectureDirectionX(targetDir)) {\n          endX += targetDir === \"L\" ? -groupEdgeShift : groupEdgeShift;\n        } else {\n          endY += targetDir === \"T\" ? -groupEdgeShift : groupEdgeShift + 18;\n        }\n      }\n      if (!sourceGroup && db.getNode(source)?.type === \"junction\") {\n        if (isArchitectureDirectionX(sourceDir)) {\n          startX += sourceDir === \"L\" ? halfIconSize : -halfIconSize;\n        } else {\n          startY += sourceDir === \"T\" ? halfIconSize : -halfIconSize;\n        }\n      }\n      if (!targetGroup && db.getNode(target)?.type === \"junction\") {\n        if (isArchitectureDirectionX(targetDir)) {\n          endX += targetDir === \"L\" ? halfIconSize : -halfIconSize;\n        } else {\n          endY += targetDir === \"T\" ? halfIconSize : -halfIconSize;\n        }\n      }\n      if (edge[0]._private.rscratch) {\n        const g = edgesEl.insert(\"g\");\n        g.insert(\"path\").attr(\"d\", `M ${startX},${startY} L ${midX},${midY} L${endX},${endY} `).attr(\"class\", \"edge\");\n        if (sourceArrow) {\n          const xShift = isArchitectureDirectionX(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startX, arrowSize) : startX - halfArrowSize;\n          const yShift = isArchitectureDirectionY(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startY, arrowSize) : startY - halfArrowSize;\n          g.insert(\"polygon\").attr(\"points\", ArchitectureDirectionArrow[sourceDir](arrowSize)).attr(\"transform\", `translate(${xShift},${yShift})`).attr(\"class\", \"arrow\");\n        }\n        if (targetArrow) {\n          const xShift = isArchitectureDirectionX(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endX, arrowSize) : endX - halfArrowSize;\n          const yShift = isArchitectureDirectionY(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endY, arrowSize) : endY - halfArrowSize;\n          g.insert(\"polygon\").attr(\"points\", ArchitectureDirectionArrow[targetDir](arrowSize)).attr(\"transform\", `translate(${xShift},${yShift})`).attr(\"class\", \"arrow\");\n        }\n        if (label) {\n          const axis = !isArchitectureDirectionXY(sourceDir, targetDir) ? isArchitectureDirectionX(sourceDir) ? \"X\" : \"Y\" : \"XY\";\n          let width = 0;\n          if (axis === \"X\") {\n            width = Math.abs(startX - endX);\n          } else if (axis === \"Y\") {\n            width = Math.abs(startY - endY) / 1.5;\n          } else {\n            width = Math.abs(startX - endX) / 2;\n          }\n          const textElem = g.append(\"g\");\n          await createText(\n            textElem,\n            label,\n            {\n              useHtmlLabels: false,\n              width,\n              classes: \"architecture-service-label\"\n            },\n            getConfig()\n          );\n          textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"text-anchor\", \"middle\");\n          if (axis === \"X\") {\n            textElem.attr(\"transform\", \"translate(\" + midX + \", \" + midY + \")\");\n          } else if (axis === \"Y\") {\n            textElem.attr(\"transform\", \"translate(\" + midX + \", \" + midY + \") rotate(-90)\");\n          } else if (axis === \"XY\") {\n            const pair = getArchitectureDirectionPair(sourceDir, targetDir);\n            if (pair && isArchitecturePairXY(pair)) {\n              const bboxOrig = textElem.node().getBoundingClientRect();\n              const [x, y] = getArchitectureDirectionXYFactors(pair);\n              textElem.attr(\"dominant-baseline\", \"auto\").attr(\"transform\", `rotate(${-1 * x * y * 45})`);\n              const bboxNew = textElem.node().getBoundingClientRect();\n              textElem.attr(\n                \"transform\",\n                `\n                translate(${midX}, ${midY - bboxOrig.height / 2})\n                translate(${x * bboxNew.width / 2}, ${y * bboxNew.height / 2})\n                rotate(${-1 * x * y * 45}, 0, ${bboxOrig.height / 2})\n              `\n              );\n            }\n          }\n        }\n      }\n    })\n  );\n}, \"drawEdges\");\nvar drawGroups = /* @__PURE__ */ __name(async function(groupsEl, cy) {\n  const padding = getConfigField(\"padding\");\n  const groupIconSize = padding * 0.75;\n  const fontSize = getConfigField(\"fontSize\");\n  const iconSize = getConfigField(\"iconSize\");\n  const halfIconSize = iconSize / 2;\n  await Promise.all(\n    cy.nodes().map(async (node) => {\n      const data = nodeData(node);\n      if (data.type === \"group\") {\n        const { h, w, x1, y1 } = node.boundingBox();\n        groupsEl.append(\"rect\").attr(\"x\", x1 + halfIconSize).attr(\"y\", y1 + halfIconSize).attr(\"width\", w).attr(\"height\", h).attr(\"class\", \"node-bkg\");\n        const groupLabelContainer = groupsEl.append(\"g\");\n        let shiftedX1 = x1;\n        let shiftedY1 = y1;\n        if (data.icon) {\n          const bkgElem = groupLabelContainer.append(\"g\");\n          bkgElem.html(\n            `<g>${await getIconSVG(data.icon, { height: groupIconSize, width: groupIconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n          );\n          bkgElem.attr(\n            \"transform\",\n            \"translate(\" + (shiftedX1 + halfIconSize + 1) + \", \" + (shiftedY1 + halfIconSize + 1) + \")\"\n          );\n          shiftedX1 += groupIconSize;\n          shiftedY1 += fontSize / 2 - 1 - 2;\n        }\n        if (data.label) {\n          const textElem = groupLabelContainer.append(\"g\");\n          await createText(\n            textElem,\n            data.label,\n            {\n              useHtmlLabels: false,\n              width: w,\n              classes: \"architecture-service-label\"\n            },\n            getConfig()\n          );\n          textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"start\").attr(\"text-anchor\", \"start\");\n          textElem.attr(\n            \"transform\",\n            \"translate(\" + (shiftedX1 + halfIconSize + 4) + \", \" + (shiftedY1 + halfIconSize + 2) + \")\"\n          );\n        }\n      }\n    })\n  );\n}, \"drawGroups\");\nvar drawServices = /* @__PURE__ */ __name(async function(db2, elem, services) {\n  for (const service of services) {\n    const serviceElem = elem.append(\"g\");\n    const iconSize = getConfigField(\"iconSize\");\n    if (service.title) {\n      const textElem = serviceElem.append(\"g\");\n      await createText(\n        textElem,\n        service.title,\n        {\n          useHtmlLabels: false,\n          width: iconSize * 1.5,\n          classes: \"architecture-service-label\"\n        },\n        getConfig()\n      );\n      textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"text-anchor\", \"middle\");\n      textElem.attr(\"transform\", \"translate(\" + iconSize / 2 + \", \" + iconSize + \")\");\n    }\n    const bkgElem = serviceElem.append(\"g\");\n    if (service.icon) {\n      bkgElem.html(\n        `<g>${await getIconSVG(service.icon, { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n      );\n    } else if (service.iconText) {\n      bkgElem.html(\n        `<g>${await getIconSVG(\"blank\", { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n      );\n      const textElemContainer = bkgElem.append(\"g\");\n      const fo = textElemContainer.append(\"foreignObject\").attr(\"width\", iconSize).attr(\"height\", iconSize);\n      const divElem = fo.append(\"div\").attr(\"class\", \"node-icon-text\").attr(\"style\", `height: ${iconSize}px;`).append(\"div\").html(service.iconText);\n      const fontSize = parseInt(\n        window.getComputedStyle(divElem.node(), null).getPropertyValue(\"font-size\").replace(/\\D/g, \"\")\n      ) ?? 16;\n      divElem.attr(\"style\", `-webkit-line-clamp: ${Math.floor((iconSize - 2) / fontSize)};`);\n    } else {\n      bkgElem.append(\"path\").attr(\"class\", \"node-bkg\").attr(\"id\", \"node-\" + service.id).attr(\n        \"d\",\n        `M0 ${iconSize} v${-iconSize} q0,-5 5,-5 h${iconSize} q5,0 5,5 v${iconSize} H0 Z`\n      );\n    }\n    serviceElem.attr(\"class\", \"architecture-service\");\n    const { width, height } = serviceElem._groups[0][0].getBBox();\n    service.width = width;\n    service.height = height;\n    db2.setElementForId(service.id, serviceElem);\n  }\n  return 0;\n}, \"drawServices\");\nvar drawJunctions = /* @__PURE__ */ __name(function(db2, elem, junctions) {\n  junctions.forEach((junction) => {\n    const junctionElem = elem.append(\"g\");\n    const iconSize = getConfigField(\"iconSize\");\n    const bkgElem = junctionElem.append(\"g\");\n    bkgElem.append(\"rect\").attr(\"id\", \"node-\" + junction.id).attr(\"fill-opacity\", \"0\").attr(\"width\", iconSize).attr(\"height\", iconSize);\n    junctionElem.attr(\"class\", \"architecture-junction\");\n    const { width, height } = junctionElem._groups[0][0].getBBox();\n    junctionElem.width = width;\n    junctionElem.height = height;\n    db2.setElementForId(junction.id, junctionElem);\n  });\n}, \"drawJunctions\");\n\n// src/diagrams/architecture/architectureRenderer.ts\nregisterIconPacks([\n  {\n    name: architectureIcons.prefix,\n    icons: architectureIcons\n  }\n]);\ncytoscape2.use(import_cytoscape_fcose.default);\nfunction addServices(services, cy) {\n  services.forEach((service) => {\n    cy.add({\n      group: \"nodes\",\n      data: {\n        type: \"service\",\n        id: service.id,\n        icon: service.icon,\n        label: service.title,\n        parent: service.in,\n        width: getConfigField(\"iconSize\"),\n        height: getConfigField(\"iconSize\")\n      },\n      classes: \"node-service\"\n    });\n  });\n}\n__name(addServices, \"addServices\");\nfunction addJunctions(junctions, cy) {\n  junctions.forEach((junction) => {\n    cy.add({\n      group: \"nodes\",\n      data: {\n        type: \"junction\",\n        id: junction.id,\n        parent: junction.in,\n        width: getConfigField(\"iconSize\"),\n        height: getConfigField(\"iconSize\")\n      },\n      classes: \"node-junction\"\n    });\n  });\n}\n__name(addJunctions, \"addJunctions\");\nfunction positionNodes(db2, cy) {\n  cy.nodes().map((node) => {\n    const data = nodeData(node);\n    if (data.type === \"group\") {\n      return;\n    }\n    data.x = node.position().x;\n    data.y = node.position().y;\n    const nodeElem = db2.getElementById(data.id);\n    nodeElem.attr(\"transform\", \"translate(\" + (data.x || 0) + \",\" + (data.y || 0) + \")\");\n  });\n}\n__name(positionNodes, \"positionNodes\");\nfunction addGroups(groups, cy) {\n  groups.forEach((group) => {\n    cy.add({\n      group: \"nodes\",\n      data: {\n        type: \"group\",\n        id: group.id,\n        icon: group.icon,\n        label: group.title,\n        parent: group.in\n      },\n      classes: \"node-group\"\n    });\n  });\n}\n__name(addGroups, \"addGroups\");\nfunction addEdges(edges, cy) {\n  edges.forEach((parsedEdge) => {\n    const { lhsId, rhsId, lhsInto, lhsGroup, rhsInto, lhsDir, rhsDir, rhsGroup, title } = parsedEdge;\n    const edgeType = isArchitectureDirectionXY(parsedEdge.lhsDir, parsedEdge.rhsDir) ? \"segments\" : \"straight\";\n    const edge = {\n      id: `${lhsId}-${rhsId}`,\n      label: title,\n      source: lhsId,\n      sourceDir: lhsDir,\n      sourceArrow: lhsInto,\n      sourceGroup: lhsGroup,\n      sourceEndpoint: lhsDir === \"L\" ? \"0 50%\" : lhsDir === \"R\" ? \"100% 50%\" : lhsDir === \"T\" ? \"50% 0\" : \"50% 100%\",\n      target: rhsId,\n      targetDir: rhsDir,\n      targetArrow: rhsInto,\n      targetGroup: rhsGroup,\n      targetEndpoint: rhsDir === \"L\" ? \"0 50%\" : rhsDir === \"R\" ? \"100% 50%\" : rhsDir === \"T\" ? \"50% 0\" : \"50% 100%\"\n    };\n    cy.add({\n      group: \"edges\",\n      data: edge,\n      classes: edgeType\n    });\n  });\n}\n__name(addEdges, \"addEdges\");\nfunction getAlignments(db2, spatialMaps, groupAlignments) {\n  const flattenAlignments = /* @__PURE__ */ __name((alignmentObj, alignmentDir) => {\n    return Object.entries(alignmentObj).reduce(\n      (prev, [dir, alignments2]) => {\n        let cnt = 0;\n        const arr = Object.entries(alignments2);\n        if (arr.length === 1) {\n          prev[dir] = arr[0][1];\n          return prev;\n        }\n        for (let i = 0; i < arr.length - 1; i++) {\n          for (let j = i + 1; j < arr.length; j++) {\n            const [aGroupId, aNodeIds] = arr[i];\n            const [bGroupId, bNodeIds] = arr[j];\n            const alignment = groupAlignments[aGroupId]?.[bGroupId];\n            if (alignment === alignmentDir) {\n              prev[dir] ??= [];\n              prev[dir] = [...prev[dir], ...aNodeIds, ...bNodeIds];\n            } else if (aGroupId === \"default\" || bGroupId === \"default\") {\n              prev[dir] ??= [];\n              prev[dir] = [...prev[dir], ...aNodeIds, ...bNodeIds];\n            } else {\n              const keyA = `${dir}-${cnt++}`;\n              prev[keyA] = aNodeIds;\n              const keyB = `${dir}-${cnt++}`;\n              prev[keyB] = bNodeIds;\n            }\n          }\n        }\n        return prev;\n      },\n      {}\n    );\n  }, \"flattenAlignments\");\n  const alignments = spatialMaps.map((spatialMap) => {\n    const horizontalAlignments = {};\n    const verticalAlignments = {};\n    Object.entries(spatialMap).forEach(([id, [x, y]]) => {\n      const nodeGroup = db2.getNode(id)?.in ?? \"default\";\n      horizontalAlignments[y] ??= {};\n      horizontalAlignments[y][nodeGroup] ??= [];\n      horizontalAlignments[y][nodeGroup].push(id);\n      verticalAlignments[x] ??= {};\n      verticalAlignments[x][nodeGroup] ??= [];\n      verticalAlignments[x][nodeGroup].push(id);\n    });\n    return {\n      horiz: Object.values(flattenAlignments(horizontalAlignments, \"horizontal\")).filter(\n        (arr) => arr.length > 1\n      ),\n      vert: Object.values(flattenAlignments(verticalAlignments, \"vertical\")).filter(\n        (arr) => arr.length > 1\n      )\n    };\n  });\n  const [horizontal, vertical] = alignments.reduce(\n    ([prevHoriz, prevVert], { horiz, vert }) => {\n      return [\n        [...prevHoriz, ...horiz],\n        [...prevVert, ...vert]\n      ];\n    },\n    [[], []]\n  );\n  return {\n    horizontal,\n    vertical\n  };\n}\n__name(getAlignments, \"getAlignments\");\nfunction getRelativeConstraints(spatialMaps) {\n  const relativeConstraints = [];\n  const posToStr = /* @__PURE__ */ __name((pos) => `${pos[0]},${pos[1]}`, \"posToStr\");\n  const strToPos = /* @__PURE__ */ __name((pos) => pos.split(\",\").map((p) => parseInt(p)), \"strToPos\");\n  spatialMaps.forEach((spatialMap) => {\n    const invSpatialMap = Object.fromEntries(\n      Object.entries(spatialMap).map(([id, pos]) => [posToStr(pos), id])\n    );\n    const queue = [posToStr([0, 0])];\n    const visited = {};\n    const directions = {\n      L: [-1, 0],\n      R: [1, 0],\n      T: [0, 1],\n      B: [0, -1]\n    };\n    while (queue.length > 0) {\n      const curr = queue.shift();\n      if (curr) {\n        visited[curr] = 1;\n        const currId = invSpatialMap[curr];\n        if (currId) {\n          const currPos = strToPos(curr);\n          Object.entries(directions).forEach(([dir, shift]) => {\n            const newPos = posToStr([currPos[0] + shift[0], currPos[1] + shift[1]]);\n            const newId = invSpatialMap[newPos];\n            if (newId && !visited[newPos]) {\n              queue.push(newPos);\n              relativeConstraints.push({\n                [ArchitectureDirectionName[dir]]: newId,\n                [ArchitectureDirectionName[getOppositeArchitectureDirection(dir)]]: currId,\n                gap: 1.5 * getConfigField(\"iconSize\")\n              });\n            }\n          });\n        }\n      }\n    }\n  });\n  return relativeConstraints;\n}\n__name(getRelativeConstraints, \"getRelativeConstraints\");\nfunction layoutArchitecture(services, junctions, groups, edges, db2, { spatialMaps, groupAlignments }) {\n  return new Promise((resolve) => {\n    const renderEl = select_default(\"body\").append(\"div\").attr(\"id\", \"cy\").attr(\"style\", \"display:none\");\n    const cy = cytoscape2({\n      container: document.getElementById(\"cy\"),\n      style: [\n        {\n          selector: \"edge\",\n          style: {\n            \"curve-style\": \"straight\",\n            label: \"data(label)\",\n            \"source-endpoint\": \"data(sourceEndpoint)\",\n            \"target-endpoint\": \"data(targetEndpoint)\"\n          }\n        },\n        {\n          selector: \"edge.segments\",\n          style: {\n            \"curve-style\": \"segments\",\n            \"segment-weights\": \"0\",\n            \"segment-distances\": [0.5],\n            // @ts-ignore Incorrect library types\n            \"edge-distances\": \"endpoints\",\n            \"source-endpoint\": \"data(sourceEndpoint)\",\n            \"target-endpoint\": \"data(targetEndpoint)\"\n          }\n        },\n        {\n          selector: \"node\",\n          style: {\n            // @ts-ignore Incorrect library types\n            \"compound-sizing-wrt-labels\": \"include\"\n          }\n        },\n        {\n          selector: \"node[label]\",\n          style: {\n            \"text-valign\": \"bottom\",\n            \"text-halign\": \"center\",\n            \"font-size\": `${getConfigField(\"fontSize\")}px`\n          }\n        },\n        {\n          selector: \".node-service\",\n          style: {\n            label: \"data(label)\",\n            width: \"data(width)\",\n            height: \"data(height)\"\n          }\n        },\n        {\n          selector: \".node-junction\",\n          style: {\n            width: \"data(width)\",\n            height: \"data(height)\"\n          }\n        },\n        {\n          selector: \".node-group\",\n          style: {\n            // @ts-ignore Incorrect library types\n            padding: `${getConfigField(\"padding\")}px`\n          }\n        }\n      ]\n    });\n    renderEl.remove();\n    addGroups(groups, cy);\n    addServices(services, cy);\n    addJunctions(junctions, cy);\n    addEdges(edges, cy);\n    const alignmentConstraint = getAlignments(db2, spatialMaps, groupAlignments);\n    const relativePlacementConstraint = getRelativeConstraints(spatialMaps);\n    const layout = cy.layout({\n      name: \"fcose\",\n      quality: \"proof\",\n      styleEnabled: false,\n      animate: false,\n      nodeDimensionsIncludeLabels: false,\n      // Adjust the edge parameters if it passes through the border of a group\n      // Hacky fix for: https://github.com/iVis-at-Bilkent/cytoscape.js-fcose/issues/67\n      idealEdgeLength(edge) {\n        const [nodeA, nodeB] = edge.connectedNodes();\n        const { parent: parentA } = nodeData(nodeA);\n        const { parent: parentB } = nodeData(nodeB);\n        const elasticity = parentA === parentB ? 1.5 * getConfigField(\"iconSize\") : 0.5 * getConfigField(\"iconSize\");\n        return elasticity;\n      },\n      edgeElasticity(edge) {\n        const [nodeA, nodeB] = edge.connectedNodes();\n        const { parent: parentA } = nodeData(nodeA);\n        const { parent: parentB } = nodeData(nodeB);\n        const elasticity = parentA === parentB ? 0.45 : 1e-3;\n        return elasticity;\n      },\n      alignmentConstraint,\n      relativePlacementConstraint\n    });\n    layout.one(\"layoutstop\", () => {\n      function getSegmentWeights(source, target, pointX, pointY) {\n        let W, D;\n        const { x: sX, y: sY } = source;\n        const { x: tX, y: tY } = target;\n        D = (pointY - sY + (sX - pointX) * (sY - tY) / (sX - tX)) / Math.sqrt(1 + Math.pow((sY - tY) / (sX - tX), 2));\n        W = Math.sqrt(Math.pow(pointY - sY, 2) + Math.pow(pointX - sX, 2) - Math.pow(D, 2));\n        const distAB = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2));\n        W = W / distAB;\n        let delta1 = (tX - sX) * (pointY - sY) - (tY - sY) * (pointX - sX);\n        switch (true) {\n          case delta1 >= 0:\n            delta1 = 1;\n            break;\n          case delta1 < 0:\n            delta1 = -1;\n            break;\n        }\n        let delta2 = (tX - sX) * (pointX - sX) + (tY - sY) * (pointY - sY);\n        switch (true) {\n          case delta2 >= 0:\n            delta2 = 1;\n            break;\n          case delta2 < 0:\n            delta2 = -1;\n            break;\n        }\n        D = Math.abs(D) * delta1;\n        W = W * delta2;\n        return {\n          distances: D,\n          weights: W\n        };\n      }\n      __name(getSegmentWeights, \"getSegmentWeights\");\n      cy.startBatch();\n      for (const edge of Object.values(cy.edges())) {\n        if (edge.data?.()) {\n          const { x: sX, y: sY } = edge.source().position();\n          const { x: tX, y: tY } = edge.target().position();\n          if (sX !== tX && sY !== tY) {\n            const sEP = edge.sourceEndpoint();\n            const tEP = edge.targetEndpoint();\n            const { sourceDir } = edgeData(edge);\n            const [pointX, pointY] = isArchitectureDirectionY(sourceDir) ? [sEP.x, tEP.y] : [tEP.x, sEP.y];\n            const { weights, distances } = getSegmentWeights(sEP, tEP, pointX, pointY);\n            edge.style(\"segment-distances\", distances);\n            edge.style(\"segment-weights\", weights);\n          }\n        }\n      }\n      cy.endBatch();\n      layout.run();\n    });\n    layout.run();\n    cy.ready((e) => {\n      log.info(\"Ready\", e);\n      resolve(cy);\n    });\n  });\n}\n__name(layoutArchitecture, \"layoutArchitecture\");\nvar draw = /* @__PURE__ */ __name(async (text, id, _version, diagObj) => {\n  const db2 = diagObj.db;\n  const services = db2.getServices();\n  const junctions = db2.getJunctions();\n  const groups = db2.getGroups();\n  const edges = db2.getEdges();\n  const ds = db2.getDataStructures();\n  const svg = selectSvgElement(id);\n  const edgesElem = svg.append(\"g\");\n  edgesElem.attr(\"class\", \"architecture-edges\");\n  const servicesElem = svg.append(\"g\");\n  servicesElem.attr(\"class\", \"architecture-services\");\n  const groupElem = svg.append(\"g\");\n  groupElem.attr(\"class\", \"architecture-groups\");\n  await drawServices(db2, servicesElem, services);\n  drawJunctions(db2, servicesElem, junctions);\n  const cy = await layoutArchitecture(services, junctions, groups, edges, db2, ds);\n  await drawEdges(edgesElem, cy);\n  await drawGroups(groupElem, cy);\n  positionNodes(db2, cy);\n  setupGraphViewbox(void 0, svg, getConfigField(\"padding\"), getConfigField(\"useMaxWidth\"));\n}, \"draw\");\nvar renderer = { draw };\n\n// src/diagrams/architecture/architectureDiagram.ts\nvar diagram = {\n  parser,\n  db,\n  renderer,\n  styles: architectureStyles_default\n};\nexport {\n  diagram\n};\n",
      "start": 1743409709132,
      "end": 1743409709236,
      "sourcemaps": null
    },
    {
      "name": "unplugin-vue-markdown",
      "start": 1743409709236,
      "end": 1743409709236,
      "order": "pre"
    },
    {
      "name": "slidev:flags",
      "start": 1743409709236,
      "end": 1743409709236,
      "order": "pre"
    },
    {
      "name": "unocss:transformers:pre",
      "start": 1743409709236,
      "end": 1743409709237,
      "order": "pre"
    },
    {
      "name": "unocss:global:build:scan",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "slidev:layout-wrapper",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "slidev:context-injection",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "slidev:hmr-patch",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "unocss:transformers:undefined",
      "start": 1743409709237,
      "end": 1743409709237,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1743409709237,
      "end": 1743409709238,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1743409709238,
      "end": 1743409709238,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1743409709238,
      "end": 1743409709238,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1743409709238,
      "end": 1743409709238,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1743409709238,
      "end": 1743409709239,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1743409709239,
      "end": 1743409709239,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1743409709239,
      "end": 1743409709239,
      "order": "normal"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1743409709239,
      "end": 1743409709239,
      "order": "post"
    },
    {
      "name": "unocss:transformers:post",
      "start": 1743409709239,
      "end": 1743409709239,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1743409709239,
      "end": 1743409709239,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1743409709239,
      "end": 1743409709239,
      "order": "normal"
    }
  ]
}
